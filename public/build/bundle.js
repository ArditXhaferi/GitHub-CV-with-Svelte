
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function append$2(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text$2(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text$2(' ');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr$1(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children$1(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        // Do not reenter flush while dirty components are updated, as this can
        // result in an infinite loop. Instead, let the inner flush handle it.
        // Reentrancy is ok afterwards for bindings etc.
        if (flushidx !== 0) {
            return;
        }
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            try {
                while (flushidx < dirty_components.length) {
                    const component = dirty_components[flushidx];
                    flushidx++;
                    set_current_component(component);
                    update$1(component.$$);
                }
            }
            catch (e) {
                // reset dirty state to not end up in a deadlocked state and then rethrow
                dirty_components.length = 0;
                flushidx = 0;
                throw e;
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update$1($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
                // if the component was destroyed immediately
                // it will update the `$$.on_destroy` reference to `null`.
                // the destructured on_destroy may still reference to the old array
                if (component.$$.on_destroy) {
                    component.$$.on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children$1(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            if (!is_function(callback)) {
                return noop;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.55.1' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append$2(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr$1(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /* src/components/Contributions.svelte generated by Svelte v3.55.1 */

    const file$3 = "src/components/Contributions.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (13:4) {#each contribution_list as contribution}
    function create_each_block$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_style(div, "background-color", /*colors*/ ctx[1][/*contribution*/ ctx[2].intensity]);
    			attr_dev(div, "class", "contribution svelte-1jouf96");
    			add_location(div, file$3, 13, 8, 255);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contribution_list*/ 1) {
    				set_style(div, "background-color", /*colors*/ ctx[1][/*contribution*/ ctx[2].intensity]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(13:4) {#each contribution_list as contribution}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let div;
    	let each_value = /*contribution_list*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "contributions svelte-1jouf96");
    			add_location(div, file$3, 11, 0, 173);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*colors, contribution_list*/ 3) {
    				each_value = /*contribution_list*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Contributions', slots, []);
    	let { contribution_list } = $$props;
    	let colors = ["#f1eef4", "#c5bbd4", "#9a87b4", "#6e5494", "#584376"];

    	$$self.$$.on_mount.push(function () {
    		if (contribution_list === undefined && !('contribution_list' in $$props || $$self.$$.bound[$$self.$$.props['contribution_list']])) {
    			console.warn("<Contributions> was created without expected prop 'contribution_list'");
    		}
    	});

    	const writable_props = ['contribution_list'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Contributions> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('contribution_list' in $$props) $$invalidate(0, contribution_list = $$props.contribution_list);
    	};

    	$$self.$capture_state = () => ({ contribution_list, colors });

    	$$self.$inject_state = $$props => {
    		if ('contribution_list' in $$props) $$invalidate(0, contribution_list = $$props.contribution_list);
    		if ('colors' in $$props) $$invalidate(1, colors = $$props.colors);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [contribution_list, colors];
    }

    class Contributions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { contribution_list: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Contributions",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get contribution_list() {
    		throw new Error("<Contributions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contribution_list(value) {
    		throw new Error("<Contributions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Rating.svelte generated by Svelte v3.55.1 */

    const file$2 = "src/components/Rating.svelte";

    function create_fragment$2(ctx) {
    	let div;
    	let div_aria_label_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "stars svelte-tpw5ek");
    			set_style(div, "--rating", /*rating*/ ctx[0] || 0);
    			attr_dev(div, "aria-label", div_aria_label_value = "Rating of this product is " + (/*rating*/ ctx[0] || 0) + " out of 5.");
    			add_location(div, file$2, 4, 0, 43);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*rating*/ 1) {
    				set_style(div, "--rating", /*rating*/ ctx[0] || 0);
    			}

    			if (dirty & /*rating*/ 1 && div_aria_label_value !== (div_aria_label_value = "Rating of this product is " + (/*rating*/ ctx[0] || 0) + " out of 5.")) {
    				attr_dev(div, "aria-label", div_aria_label_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Rating', slots, []);
    	let { rating } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (rating === undefined && !('rating' in $$props || $$self.$$.bound[$$self.$$.props['rating']])) {
    			console.warn("<Rating> was created without expected prop 'rating'");
    		}
    	});

    	const writable_props = ['rating'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Rating> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('rating' in $$props) $$invalidate(0, rating = $$props.rating);
    	};

    	$$self.$capture_state = () => ({ rating });

    	$$self.$inject_state = $$props => {
    		if ('rating' in $$props) $$invalidate(0, rating = $$props.rating);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [rating];
    }

    class Rating extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { rating: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Rating",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get rating() {
    		throw new Error("<Rating>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rating(value) {
    		throw new Error("<Rating>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Repos.svelte generated by Svelte v3.55.1 */
    const file$1 = "src/components/Repos.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (9:4) {#each repos_list as repo}
    function create_each_block(ctx) {
    	let div;
    	let t0_value = /*repo*/ ctx[1].name + "";
    	let t0;
    	let t1;
    	let t2_value = /*repo*/ ctx[1].stargazers_count + "";
    	let t2;
    	let t3;
    	let rating;
    	let current;

    	rating = new Rating({
    			props: {
    				rating: /*repo*/ ctx[1].stargazers_count / (/*repos_list*/ ctx[0][0].stargazers_count / 5)
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$2(t0_value);
    			t1 = text$2("-");
    			t2 = text$2(t2_value);
    			t3 = space();
    			create_component(rating.$$.fragment);
    			attr_dev(div, "class", "repo");
    			add_location(div, file$1, 9, 8, 248);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			insert_dev(target, t3, anchor);
    			mount_component(rating, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*repos_list*/ 1) && t0_value !== (t0_value = /*repo*/ ctx[1].name + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*repos_list*/ 1) && t2_value !== (t2_value = /*repo*/ ctx[1].stargazers_count + "")) set_data_dev(t2, t2_value);
    			const rating_changes = {};
    			if (dirty & /*repos_list*/ 1) rating_changes.rating = /*repo*/ ctx[1].stargazers_count / (/*repos_list*/ ctx[0][0].stargazers_count / 5);
    			rating.$set(rating_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rating.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rating.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t3);
    			destroy_component(rating, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(9:4) {#each repos_list as repo}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let div;
    	let t0;

    	let t1_value = (/*repos_list*/ ctx[0].length == 0
    	? 1
    	: /*repos_list*/ ctx[0][0].stargazers_count / 5) + "";

    	let t1;
    	let t2;
    	let current;
    	let each_value = /*repos_list*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text$2("Repo stars (");
    			t1 = text$2(t1_value);
    			t2 = text$2(" stars by real)\n    ");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "repos");
    			add_location(div, file$1, 6, 0, 90);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*repos_list*/ 1) && t1_value !== (t1_value = (/*repos_list*/ ctx[0].length == 0
    			? 1
    			: /*repos_list*/ ctx[0][0].stargazers_count / 5) + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*repos_list*/ 1) {
    				each_value = /*repos_list*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Repos', slots, []);
    	let { repos_list } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (repos_list === undefined && !('repos_list' in $$props || $$self.$$.bound[$$self.$$.props['repos_list']])) {
    			console.warn("<Repos> was created without expected prop 'repos_list'");
    		}
    	});

    	const writable_props = ['repos_list'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Repos> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('repos_list' in $$props) $$invalidate(0, repos_list = $$props.repos_list);
    	};

    	$$self.$capture_state = () => ({ Rating, repos_list });

    	$$self.$inject_state = $$props => {
    		if ('repos_list' in $$props) $$invalidate(0, repos_list = $$props.repos_list);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [repos_list];
    }

    class Repos extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { repos_list: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Repos",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get repos_list() {
    		throw new Error("<Repos>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set repos_list(value) {
    		throw new Error("<Repos>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const defaultOpts$2 = {
        xml: false,
        decodeEntities: true,
    };
    const xmlModeDefault = {
        _useHtmlParser2: true,
        xmlMode: true,
    };
    /**
     * Flatten the options for Cheerio.
     *
     * This will set `_useHtmlParser2` to true if `xml` is set to true.
     *
     * @param options - The options to flatten.
     * @returns The flattened options.
     */
    function flatten(options) {
        return (options === null || options === void 0 ? void 0 : options.xml)
            ? typeof options.xml === 'boolean'
                ? xmlModeDefault
                : { ...xmlModeDefault, ...options.xml }
            : options !== null && options !== void 0 ? options : undefined;
    }

    /** Types of elements found in htmlparser2's DOM */
    var ElementType;
    (function (ElementType) {
        /** Type for the root element of a document */
        ElementType["Root"] = "root";
        /** Type for Text */
        ElementType["Text"] = "text";
        /** Type for <? ... ?> */
        ElementType["Directive"] = "directive";
        /** Type for <!-- ... --> */
        ElementType["Comment"] = "comment";
        /** Type for <script> tags */
        ElementType["Script"] = "script";
        /** Type for <style> tags */
        ElementType["Style"] = "style";
        /** Type for Any tag */
        ElementType["Tag"] = "tag";
        /** Type for <![CDATA[ ... ]]> */
        ElementType["CDATA"] = "cdata";
        /** Type for <!doctype ...> */
        ElementType["Doctype"] = "doctype";
    })(ElementType || (ElementType = {}));
    /**
     * Tests whether an element is a tag or not.
     *
     * @param elem Element to test
     */
    function isTag$1(elem) {
        return (elem.type === ElementType.Tag ||
            elem.type === ElementType.Script ||
            elem.type === ElementType.Style);
    }
    // Exports for backwards compatibility
    /** Type for the root element of a document */
    const Root = ElementType.Root;
    /** Type for Text */
    const Text$1 = ElementType.Text;
    /** Type for <? ... ?> */
    const Directive = ElementType.Directive;
    /** Type for <!-- ... --> */
    const Comment$1 = ElementType.Comment;
    /** Type for <script> tags */
    const Script = ElementType.Script;
    /** Type for <style> tags */
    const Style = ElementType.Style;
    /** Type for Any tag */
    const Tag = ElementType.Tag;
    /** Type for <![CDATA[ ... ]]> */
    const CDATA$1 = ElementType.CDATA;
    /** Type for <!doctype ...> */
    const Doctype = ElementType.Doctype;

    /**
     * This object will be used as the prototype for Nodes when creating a
     * DOM-Level-1-compliant structure.
     */
    class Node {
        constructor() {
            /** Parent of the node */
            this.parent = null;
            /** Previous sibling */
            this.prev = null;
            /** Next sibling */
            this.next = null;
            /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
            this.startIndex = null;
            /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
            this.endIndex = null;
        }
        // Read-write aliases for properties
        /**
         * Same as {@link parent}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get parentNode() {
            return this.parent;
        }
        set parentNode(parent) {
            this.parent = parent;
        }
        /**
         * Same as {@link prev}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get previousSibling() {
            return this.prev;
        }
        set previousSibling(prev) {
            this.prev = prev;
        }
        /**
         * Same as {@link next}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get nextSibling() {
            return this.next;
        }
        set nextSibling(next) {
            this.next = next;
        }
        /**
         * Clone this node, and optionally its children.
         *
         * @param recursive Clone child nodes as well.
         * @returns A clone of the node.
         */
        cloneNode(recursive = false) {
            return cloneNode(this, recursive);
        }
    }
    /**
     * A node that contains some data.
     */
    class DataNode extends Node {
        /**
         * @param data The content of the data node
         */
        constructor(data) {
            super();
            this.data = data;
        }
        /**
         * Same as {@link data}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get nodeValue() {
            return this.data;
        }
        set nodeValue(data) {
            this.data = data;
        }
    }
    /**
     * Text within the document.
     */
    class Text extends DataNode {
        constructor() {
            super(...arguments);
            this.type = ElementType.Text;
        }
        get nodeType() {
            return 3;
        }
    }
    /**
     * Comments within the document.
     */
    class Comment extends DataNode {
        constructor() {
            super(...arguments);
            this.type = ElementType.Comment;
        }
        get nodeType() {
            return 8;
        }
    }
    /**
     * Processing instructions, including doc types.
     */
    class ProcessingInstruction extends DataNode {
        constructor(name, data) {
            super(data);
            this.name = name;
            this.type = ElementType.Directive;
        }
        get nodeType() {
            return 1;
        }
    }
    /**
     * A `Node` that can have children.
     */
    class NodeWithChildren extends Node {
        /**
         * @param children Children of the node. Only certain node types can have children.
         */
        constructor(children) {
            super();
            this.children = children;
        }
        // Aliases
        /** First child of the node. */
        get firstChild() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        }
        /** Last child of the node. */
        get lastChild() {
            return this.children.length > 0
                ? this.children[this.children.length - 1]
                : null;
        }
        /**
         * Same as {@link children}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get childNodes() {
            return this.children;
        }
        set childNodes(children) {
            this.children = children;
        }
    }
    class CDATA extends NodeWithChildren {
        constructor() {
            super(...arguments);
            this.type = ElementType.CDATA;
        }
        get nodeType() {
            return 4;
        }
    }
    /**
     * The root node of the document.
     */
    class Document extends NodeWithChildren {
        constructor() {
            super(...arguments);
            this.type = ElementType.Root;
        }
        get nodeType() {
            return 9;
        }
    }
    /**
     * An element within the DOM.
     */
    class Element extends NodeWithChildren {
        /**
         * @param name Name of the tag, eg. `div`, `span`.
         * @param attribs Object mapping attribute names to attribute values.
         * @param children Children of the node.
         */
        constructor(name, attribs, children = [], type = name === "script"
            ? ElementType.Script
            : name === "style"
                ? ElementType.Style
                : ElementType.Tag) {
            super(children);
            this.name = name;
            this.attribs = attribs;
            this.type = type;
        }
        get nodeType() {
            return 1;
        }
        // DOM Level 1 aliases
        /**
         * Same as {@link name}.
         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
         */
        get tagName() {
            return this.name;
        }
        set tagName(name) {
            this.name = name;
        }
        get attributes() {
            return Object.keys(this.attribs).map((name) => {
                var _a, _b;
                return ({
                    name,
                    value: this.attribs[name],
                    namespace: (_a = this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                });
            });
        }
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node is a `Element`, `false` otherwise.
     */
    function isTag(node) {
        return isTag$1(node);
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `CDATA`, `false` otherwise.
     */
    function isCDATA(node) {
        return node.type === ElementType.CDATA;
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `Text`, `false` otherwise.
     */
    function isText(node) {
        return node.type === ElementType.Text;
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `Comment`, `false` otherwise.
     */
    function isComment(node) {
        return node.type === ElementType.Comment;
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
     */
    function isDirective(node) {
        return node.type === ElementType.Directive;
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
     */
    function isDocument(node) {
        return node.type === ElementType.Root;
    }
    /**
     * @param node Node to check.
     * @returns `true` if the node has children, `false` otherwise.
     */
    function hasChildren(node) {
        return Object.prototype.hasOwnProperty.call(node, "children");
    }
    /**
     * Clone a node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    function cloneNode(node, recursive = false) {
        let result;
        if (isText(node)) {
            result = new Text(node.data);
        }
        else if (isComment(node)) {
            result = new Comment(node.data);
        }
        else if (isTag(node)) {
            const children = recursive ? cloneChildren(node.children) : [];
            const clone = new Element(node.name, { ...node.attribs }, children);
            children.forEach((child) => (child.parent = clone));
            if (node.namespace != null) {
                clone.namespace = node.namespace;
            }
            if (node["x-attribsNamespace"]) {
                clone["x-attribsNamespace"] = { ...node["x-attribsNamespace"] };
            }
            if (node["x-attribsPrefix"]) {
                clone["x-attribsPrefix"] = { ...node["x-attribsPrefix"] };
            }
            result = clone;
        }
        else if (isCDATA(node)) {
            const children = recursive ? cloneChildren(node.children) : [];
            const clone = new CDATA(children);
            children.forEach((child) => (child.parent = clone));
            result = clone;
        }
        else if (isDocument(node)) {
            const children = recursive ? cloneChildren(node.children) : [];
            const clone = new Document(children);
            children.forEach((child) => (child.parent = clone));
            if (node["x-mode"]) {
                clone["x-mode"] = node["x-mode"];
            }
            result = clone;
        }
        else if (isDirective(node)) {
            const instruction = new ProcessingInstruction(node.name, node.data);
            if (node["x-name"] != null) {
                instruction["x-name"] = node["x-name"];
                instruction["x-publicId"] = node["x-publicId"];
                instruction["x-systemId"] = node["x-systemId"];
            }
            result = instruction;
        }
        else {
            throw new Error(`Not implemented yet: ${node.type}`);
        }
        result.startIndex = node.startIndex;
        result.endIndex = node.endIndex;
        if (node.sourceCodeLocation != null) {
            result.sourceCodeLocation = node.sourceCodeLocation;
        }
        return result;
    }
    function cloneChildren(childs) {
        const children = childs.map((child) => cloneNode(child, true));
        for (let i = 1; i < children.length; i++) {
            children[i].prev = children[i - 1];
            children[i - 1].next = children[i];
        }
        return children;
    }

    // Default options
    const defaultOpts$1 = {
        withStartIndices: false,
        withEndIndices: false,
        xmlMode: false,
    };
    class DomHandler {
        /**
         * @param callback Called once parsing has completed.
         * @param options Settings for the handler.
         * @param elementCB Callback whenever a tag is closed.
         */
        constructor(callback, options, elementCB) {
            /** The elements of the DOM */
            this.dom = [];
            /** The root element for the DOM */
            this.root = new Document(this.dom);
            /** Indicated whether parsing has been completed. */
            this.done = false;
            /** Stack of open tags. */
            this.tagStack = [this.root];
            /** A data node that is still being written to. */
            this.lastNode = null;
            /** Reference to the parser instance. Used for location information. */
            this.parser = null;
            // Make it possible to skip arguments, for backwards-compatibility
            if (typeof options === "function") {
                elementCB = options;
                options = defaultOpts$1;
            }
            if (typeof callback === "object") {
                options = callback;
                callback = undefined;
            }
            this.callback = callback !== null && callback !== void 0 ? callback : null;
            this.options = options !== null && options !== void 0 ? options : defaultOpts$1;
            this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        onparserinit(parser) {
            this.parser = parser;
        }
        // Resets the handler back to starting state
        onreset() {
            this.dom = [];
            this.root = new Document(this.dom);
            this.done = false;
            this.tagStack = [this.root];
            this.lastNode = null;
            this.parser = null;
        }
        // Signals the handler that parsing is done
        onend() {
            if (this.done)
                return;
            this.done = true;
            this.parser = null;
            this.handleCallback(null);
        }
        onerror(error) {
            this.handleCallback(error);
        }
        onclosetag() {
            this.lastNode = null;
            const elem = this.tagStack.pop();
            if (this.options.withEndIndices) {
                elem.endIndex = this.parser.endIndex;
            }
            if (this.elementCB)
                this.elementCB(elem);
        }
        onopentag(name, attribs) {
            const type = this.options.xmlMode ? ElementType.Tag : undefined;
            const element = new Element(name, attribs, undefined, type);
            this.addNode(element);
            this.tagStack.push(element);
        }
        ontext(data) {
            const { lastNode } = this;
            if (lastNode && lastNode.type === ElementType.Text) {
                lastNode.data += data;
                if (this.options.withEndIndices) {
                    lastNode.endIndex = this.parser.endIndex;
                }
            }
            else {
                const node = new Text(data);
                this.addNode(node);
                this.lastNode = node;
            }
        }
        oncomment(data) {
            if (this.lastNode && this.lastNode.type === ElementType.Comment) {
                this.lastNode.data += data;
                return;
            }
            const node = new Comment(data);
            this.addNode(node);
            this.lastNode = node;
        }
        oncommentend() {
            this.lastNode = null;
        }
        oncdatastart() {
            const text = new Text("");
            const node = new CDATA([text]);
            this.addNode(node);
            text.parent = node;
            this.lastNode = text;
        }
        oncdataend() {
            this.lastNode = null;
        }
        onprocessinginstruction(name, data) {
            const node = new ProcessingInstruction(name, data);
            this.addNode(node);
        }
        handleCallback(error) {
            if (typeof this.callback === "function") {
                this.callback(error, this.dom);
            }
            else if (error) {
                throw error;
            }
        }
        addNode(node) {
            const parent = this.tagStack[this.tagStack.length - 1];
            const previousSibling = parent.children[parent.children.length - 1];
            if (this.options.withStartIndices) {
                node.startIndex = this.parser.startIndex;
            }
            if (this.options.withEndIndices) {
                node.endIndex = this.parser.endIndex;
            }
            parent.children.push(node);
            if (previousSibling) {
                node.prev = previousSibling;
                previousSibling.next = node;
            }
            node.parent = parent;
            this.lastNode = null;
        }
    }

    // Generated using scripts/write-decode-map.ts
    var htmlDecodeTree = new Uint16Array(
    // prettier-ignore
    "\u1d41<\xd5\u0131\u028a\u049d\u057b\u05d0\u0675\u06de\u07a2\u07d6\u080f\u0a4a\u0a91\u0da1\u0e6d\u0f09\u0f26\u10ca\u1228\u12e1\u1415\u149d\u14c3\u14df\u1525\0\0\0\0\0\0\u156b\u16cd\u198d\u1c12\u1ddd\u1f7e\u2060\u21b0\u228d\u23c0\u23fb\u2442\u2824\u2912\u2d08\u2e48\u2fce\u3016\u32ba\u3639\u37ac\u38fe\u3a28\u3a71\u3ae0\u3b2e\u0800EMabcfglmnoprstu\\bfms\x7f\x84\x8b\x90\x95\x98\xa6\xb3\xb9\xc8\xcflig\u803b\xc6\u40c6P\u803b&\u4026cute\u803b\xc1\u40c1reve;\u4102\u0100iyx}rc\u803b\xc2\u40c2;\u4410r;\uc000\ud835\udd04rave\u803b\xc0\u40c0pha;\u4391acr;\u4100d;\u6a53\u0100gp\x9d\xa1on;\u4104f;\uc000\ud835\udd38plyFunction;\u6061ing\u803b\xc5\u40c5\u0100cs\xbe\xc3r;\uc000\ud835\udc9cign;\u6254ilde\u803b\xc3\u40c3ml\u803b\xc4\u40c4\u0400aceforsu\xe5\xfb\xfe\u0117\u011c\u0122\u0127\u012a\u0100cr\xea\xf2kslash;\u6216\u0176\xf6\xf8;\u6ae7ed;\u6306y;\u4411\u0180crt\u0105\u010b\u0114ause;\u6235noullis;\u612ca;\u4392r;\uc000\ud835\udd05pf;\uc000\ud835\udd39eve;\u42d8c\xf2\u0113mpeq;\u624e\u0700HOacdefhilorsu\u014d\u0151\u0156\u0180\u019e\u01a2\u01b5\u01b7\u01ba\u01dc\u0215\u0273\u0278\u027ecy;\u4427PY\u803b\xa9\u40a9\u0180cpy\u015d\u0162\u017aute;\u4106\u0100;i\u0167\u0168\u62d2talDifferentialD;\u6145leys;\u612d\u0200aeio\u0189\u018e\u0194\u0198ron;\u410cdil\u803b\xc7\u40c7rc;\u4108nint;\u6230ot;\u410a\u0100dn\u01a7\u01adilla;\u40b8terDot;\u40b7\xf2\u017fi;\u43a7rcle\u0200DMPT\u01c7\u01cb\u01d1\u01d6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01e2\u01f8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020foubleQuote;\u601duote;\u6019\u0200lnpu\u021e\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6a74\u0180git\u022f\u0236\u023aruent;\u6261nt;\u622fourIntegral;\u622e\u0100fr\u024c\u024e;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6a2fcr;\uc000\ud835\udc9ep\u0100;C\u0284\u0285\u62d3ap;\u624d\u0580DJSZacefios\u02a0\u02ac\u02b0\u02b4\u02b8\u02cb\u02d7\u02e1\u02e6\u0333\u048d\u0100;o\u0179\u02a5trahd;\u6911cy;\u4402cy;\u4405cy;\u440f\u0180grs\u02bf\u02c4\u02c7ger;\u6021r;\u61a1hv;\u6ae4\u0100ay\u02d0\u02d5ron;\u410e;\u4414l\u0100;t\u02dd\u02de\u6207a;\u4394r;\uc000\ud835\udd07\u0100af\u02eb\u0327\u0100cm\u02f0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031ccute;\u40b4o\u0174\u030b\u030d;\u42d9bleAcute;\u42ddrave;\u4060ilde;\u42dcond;\u62c4ferentialD;\u6146\u0470\u033d\0\0\0\u0342\u0354\0\u0405f;\uc000\ud835\udd3b\u0180;DE\u0348\u0349\u034d\u40a8ot;\u60dcqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03cf\u03e2\u03f8ontourIntegra\xec\u0239o\u0274\u0379\0\0\u037b\xbb\u0349nArrow;\u61d3\u0100eo\u0387\u03a4ft\u0180ART\u0390\u0396\u03a1rrow;\u61d0ightArrow;\u61d4e\xe5\u02cang\u0100LR\u03ab\u03c4eft\u0100AR\u03b3\u03b9rrow;\u67f8ightArrow;\u67faightArrow;\u67f9ight\u0100AT\u03d8\u03derrow;\u61d2ee;\u62a8p\u0241\u03e9\0\0\u03efrrow;\u61d1ownArrow;\u61d5erticalBar;\u6225n\u0300ABLRTa\u0412\u042a\u0430\u045e\u047f\u037crrow\u0180;BU\u041d\u041e\u0422\u6193ar;\u6913pArrow;\u61f5reve;\u4311eft\u02d2\u043a\0\u0446\0\u0450ightVector;\u6950eeVector;\u695eector\u0100;B\u0459\u045a\u61bdar;\u6956ight\u01d4\u0467\0\u0471eeVector;\u695fector\u0100;B\u047a\u047b\u61c1ar;\u6957ee\u0100;A\u0486\u0487\u62a4rrow;\u61a7\u0100ct\u0492\u0497r;\uc000\ud835\udc9frok;\u4110\u0800NTacdfglmopqstux\u04bd\u04c0\u04c4\u04cb\u04de\u04e2\u04e7\u04ee\u04f5\u0521\u052f\u0536\u0552\u055d\u0560\u0565G;\u414aH\u803b\xd0\u40d0cute\u803b\xc9\u40c9\u0180aiy\u04d2\u04d7\u04dcron;\u411arc\u803b\xca\u40ca;\u442dot;\u4116r;\uc000\ud835\udd08rave\u803b\xc8\u40c8ement;\u6208\u0100ap\u04fa\u04fecr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65fberySmallSquare;\u65ab\u0100gp\u0526\u052aon;\u4118f;\uc000\ud835\udd3csilon;\u4395u\u0100ai\u053c\u0549l\u0100;T\u0542\u0543\u6a75ilde;\u6242librium;\u61cc\u0100ci\u0557\u055ar;\u6130m;\u6a73a;\u4397ml\u803b\xcb\u40cb\u0100ip\u056a\u056fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058d\u05b2\u05ccy;\u4424r;\uc000\ud835\udd09lled\u0253\u0597\0\0\u05a3mallSquare;\u65fcerySmallSquare;\u65aa\u0370\u05ba\0\u05bf\0\0\u05c4f;\uc000\ud835\udd3dAll;\u6200riertrf;\u6131c\xf2\u05cb\u0600JTabcdfgorst\u05e8\u05ec\u05ef\u05fa\u0600\u0612\u0616\u061b\u061d\u0623\u066c\u0672cy;\u4403\u803b>\u403emma\u0100;d\u05f7\u05f8\u4393;\u43dcreve;\u411e\u0180eiy\u0607\u060c\u0610dil;\u4122rc;\u411c;\u4413ot;\u4120r;\uc000\ud835\udd0a;\u62d9pf;\uc000\ud835\udd3eeater\u0300EFGLST\u0635\u0644\u064e\u0656\u065b\u0666qual\u0100;L\u063e\u063f\u6265ess;\u62dbullEqual;\u6267reater;\u6aa2ess;\u6277lantEqual;\u6a7eilde;\u6273cr;\uc000\ud835\udca2;\u626b\u0400Aacfiosu\u0685\u068b\u0696\u069b\u069e\u06aa\u06be\u06caRDcy;\u442a\u0100ct\u0690\u0694ek;\u42c7;\u405eirc;\u4124r;\u610clbertSpace;\u610b\u01f0\u06af\0\u06b2f;\u610dizontalLine;\u6500\u0100ct\u06c3\u06c5\xf2\u06a9rok;\u4126mp\u0144\u06d0\u06d8ownHum\xf0\u012fqual;\u624f\u0700EJOacdfgmnostu\u06fa\u06fe\u0703\u0707\u070e\u071a\u071e\u0721\u0728\u0744\u0778\u078b\u078f\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803b\xcd\u40cd\u0100iy\u0713\u0718rc\u803b\xce\u40ce;\u4418ot;\u4130r;\u6111rave\u803b\xcc\u40cc\u0180;ap\u0720\u072f\u073f\u0100cg\u0734\u0737r;\u412ainaryI;\u6148lie\xf3\u03dd\u01f4\u0749\0\u0762\u0100;e\u074d\u074e\u622c\u0100gr\u0753\u0758ral;\u622bsection;\u62c2isible\u0100CT\u076c\u0772omma;\u6063imes;\u6062\u0180gpt\u077f\u0783\u0788on;\u412ef;\uc000\ud835\udd40a;\u4399cr;\u6110ilde;\u4128\u01eb\u079a\0\u079ecy;\u4406l\u803b\xcf\u40cf\u0280cfosu\u07ac\u07b7\u07bc\u07c2\u07d0\u0100iy\u07b1\u07b5rc;\u4134;\u4419r;\uc000\ud835\udd0dpf;\uc000\ud835\udd41\u01e3\u07c7\0\u07ccr;\uc000\ud835\udca5rcy;\u4408kcy;\u4404\u0380HJacfos\u07e4\u07e8\u07ec\u07f1\u07fd\u0802\u0808cy;\u4425cy;\u440cppa;\u439a\u0100ey\u07f6\u07fbdil;\u4136;\u441ar;\uc000\ud835\udd0epf;\uc000\ud835\udd42cr;\uc000\ud835\udca6\u0580JTaceflmost\u0825\u0829\u082c\u0850\u0863\u09b3\u09b8\u09c7\u09cd\u0a37\u0a47cy;\u4409\u803b<\u403c\u0280cmnpr\u0837\u083c\u0841\u0844\u084dute;\u4139bda;\u439bg;\u67ealacetrf;\u6112r;\u619e\u0180aey\u0857\u085c\u0861ron;\u413ddil;\u413b;\u441b\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087e\u08a9\u08b1\u08e0\u08e6\u08fc\u092f\u095b\u0390\u096a\u0100nr\u0883\u088fgleBracket;\u67e8row\u0180;BR\u0899\u089a\u089e\u6190ar;\u61e4ightArrow;\u61c6eiling;\u6308o\u01f5\u08b7\0\u08c3bleBracket;\u67e6n\u01d4\u08c8\0\u08d2eeVector;\u6961ector\u0100;B\u08db\u08dc\u61c3ar;\u6959loor;\u630aight\u0100AV\u08ef\u08f5rrow;\u6194ector;\u694e\u0100er\u0901\u0917e\u0180;AV\u0909\u090a\u0910\u62a3rrow;\u61a4ector;\u695aiangle\u0180;BE\u0924\u0925\u0929\u62b2ar;\u69cfqual;\u62b4p\u0180DTV\u0937\u0942\u094cownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61bfar;\u6958ector\u0100;B\u0965\u0966\u61bcar;\u6952ight\xe1\u039cs\u0300EFGLST\u097e\u098b\u0995\u099d\u09a2\u09adqualGreater;\u62daullEqual;\u6266reater;\u6276ess;\u6aa1lantEqual;\u6a7dilde;\u6272r;\uc000\ud835\udd0f\u0100;e\u09bd\u09be\u62d8ftarrow;\u61daidot;\u413f\u0180npw\u09d4\u0a16\u0a1bg\u0200LRlr\u09de\u09f7\u0a02\u0a10eft\u0100AR\u09e6\u09ecrrow;\u67f5ightArrow;\u67f7ightArrow;\u67f6eft\u0100ar\u03b3\u0a0aight\xe1\u03bfight\xe1\u03caf;\uc000\ud835\udd43er\u0100LR\u0a22\u0a2ceftArrow;\u6199ightArrow;\u6198\u0180cht\u0a3e\u0a40\u0a42\xf2\u084c;\u61b0rok;\u4141;\u626a\u0400acefiosu\u0a5a\u0a5d\u0a60\u0a77\u0a7c\u0a85\u0a8b\u0a8ep;\u6905y;\u441c\u0100dl\u0a65\u0a6fiumSpace;\u605flintrf;\u6133r;\uc000\ud835\udd10nusPlus;\u6213pf;\uc000\ud835\udd44c\xf2\u0a76;\u439c\u0480Jacefostu\u0aa3\u0aa7\u0aad\u0ac0\u0b14\u0b19\u0d91\u0d97\u0d9ecy;\u440acute;\u4143\u0180aey\u0ab4\u0ab9\u0aberon;\u4147dil;\u4145;\u441d\u0180gsw\u0ac7\u0af0\u0b0eative\u0180MTV\u0ad3\u0adf\u0ae8ediumSpace;\u600bhi\u0100cn\u0ae6\u0ad8\xeb\u0ad9eryThi\xee\u0ad9ted\u0100GL\u0af8\u0b06reaterGreate\xf2\u0673essLes\xf3\u0a48Line;\u400ar;\uc000\ud835\udd11\u0200Bnpt\u0b22\u0b28\u0b37\u0b3areak;\u6060BreakingSpace;\u40a0f;\u6115\u0680;CDEGHLNPRSTV\u0b55\u0b56\u0b6a\u0b7c\u0ba1\u0beb\u0c04\u0c5e\u0c84\u0ca6\u0cd8\u0d61\u0d85\u6aec\u0100ou\u0b5b\u0b64ngruent;\u6262pCap;\u626doubleVerticalBar;\u6226\u0180lqx\u0b83\u0b8a\u0b9bement;\u6209ual\u0100;T\u0b92\u0b93\u6260ilde;\uc000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0bb6\u0bb7\u0bbd\u0bc9\u0bd3\u0bd8\u0be5\u626fqual;\u6271ullEqual;\uc000\u2267\u0338reater;\uc000\u226b\u0338ess;\u6279lantEqual;\uc000\u2a7e\u0338ilde;\u6275ump\u0144\u0bf2\u0bfdownHump;\uc000\u224e\u0338qual;\uc000\u224f\u0338e\u0100fs\u0c0a\u0c27tTriangle\u0180;BE\u0c1a\u0c1b\u0c21\u62eaar;\uc000\u29cf\u0338qual;\u62ecs\u0300;EGLST\u0c35\u0c36\u0c3c\u0c44\u0c4b\u0c58\u626equal;\u6270reater;\u6278ess;\uc000\u226a\u0338lantEqual;\uc000\u2a7d\u0338ilde;\u6274ested\u0100GL\u0c68\u0c79reaterGreater;\uc000\u2aa2\u0338essLess;\uc000\u2aa1\u0338recedes\u0180;ES\u0c92\u0c93\u0c9b\u6280qual;\uc000\u2aaf\u0338lantEqual;\u62e0\u0100ei\u0cab\u0cb9verseElement;\u620cghtTriangle\u0180;BE\u0ccb\u0ccc\u0cd2\u62ebar;\uc000\u29d0\u0338qual;\u62ed\u0100qu\u0cdd\u0d0cuareSu\u0100bp\u0ce8\u0cf9set\u0100;E\u0cf0\u0cf3\uc000\u228f\u0338qual;\u62e2erset\u0100;E\u0d03\u0d06\uc000\u2290\u0338qual;\u62e3\u0180bcp\u0d13\u0d24\u0d4eset\u0100;E\u0d1b\u0d1e\uc000\u2282\u20d2qual;\u6288ceeds\u0200;EST\u0d32\u0d33\u0d3b\u0d46\u6281qual;\uc000\u2ab0\u0338lantEqual;\u62e1ilde;\uc000\u227f\u0338erset\u0100;E\u0d58\u0d5b\uc000\u2283\u20d2qual;\u6289ilde\u0200;EFT\u0d6e\u0d6f\u0d75\u0d7f\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uc000\ud835\udca9ilde\u803b\xd1\u40d1;\u439d\u0700Eacdfgmoprstuv\u0dbd\u0dc2\u0dc9\u0dd5\u0ddb\u0de0\u0de7\u0dfc\u0e02\u0e20\u0e22\u0e32\u0e3f\u0e44lig;\u4152cute\u803b\xd3\u40d3\u0100iy\u0dce\u0dd3rc\u803b\xd4\u40d4;\u441eblac;\u4150r;\uc000\ud835\udd12rave\u803b\xd2\u40d2\u0180aei\u0dee\u0df2\u0df6cr;\u414cga;\u43a9cron;\u439fpf;\uc000\ud835\udd46enCurly\u0100DQ\u0e0e\u0e1aoubleQuote;\u601cuote;\u6018;\u6a54\u0100cl\u0e27\u0e2cr;\uc000\ud835\udcaaash\u803b\xd8\u40d8i\u016c\u0e37\u0e3cde\u803b\xd5\u40d5es;\u6a37ml\u803b\xd6\u40d6er\u0100BP\u0e4b\u0e60\u0100ar\u0e50\u0e53r;\u603eac\u0100ek\u0e5a\u0e5c;\u63deet;\u63b4arenthesis;\u63dc\u0480acfhilors\u0e7f\u0e87\u0e8a\u0e8f\u0e92\u0e94\u0e9d\u0eb0\u0efcrtialD;\u6202y;\u441fr;\uc000\ud835\udd13i;\u43a6;\u43a0usMinus;\u40b1\u0100ip\u0ea2\u0eadncareplan\xe5\u069df;\u6119\u0200;eio\u0eb9\u0eba\u0ee0\u0ee4\u6abbcedes\u0200;EST\u0ec8\u0ec9\u0ecf\u0eda\u627aqual;\u6aaflantEqual;\u627cilde;\u627eme;\u6033\u0100dp\u0ee9\u0eeeuct;\u620fortion\u0100;a\u0225\u0ef9l;\u621d\u0100ci\u0f01\u0f06r;\uc000\ud835\udcab;\u43a8\u0200Ufos\u0f11\u0f16\u0f1b\u0f1fOT\u803b\"\u4022r;\uc000\ud835\udd14pf;\u611acr;\uc000\ud835\udcac\u0600BEacefhiorsu\u0f3e\u0f43\u0f47\u0f60\u0f73\u0fa7\u0faa\u0fad\u1096\u10a9\u10b4\u10bearr;\u6910G\u803b\xae\u40ae\u0180cnr\u0f4e\u0f53\u0f56ute;\u4154g;\u67ebr\u0100;t\u0f5c\u0f5d\u61a0l;\u6916\u0180aey\u0f67\u0f6c\u0f71ron;\u4158dil;\u4156;\u4420\u0100;v\u0f78\u0f79\u611cerse\u0100EU\u0f82\u0f99\u0100lq\u0f87\u0f8eement;\u620builibrium;\u61cbpEquilibrium;\u696fr\xbb\u0f79o;\u43a1ght\u0400ACDFTUVa\u0fc1\u0feb\u0ff3\u1022\u1028\u105b\u1087\u03d8\u0100nr\u0fc6\u0fd2gleBracket;\u67e9row\u0180;BL\u0fdc\u0fdd\u0fe1\u6192ar;\u61e5eftArrow;\u61c4eiling;\u6309o\u01f5\u0ff9\0\u1005bleBracket;\u67e7n\u01d4\u100a\0\u1014eeVector;\u695dector\u0100;B\u101d\u101e\u61c2ar;\u6955loor;\u630b\u0100er\u102d\u1043e\u0180;AV\u1035\u1036\u103c\u62a2rrow;\u61a6ector;\u695biangle\u0180;BE\u1050\u1051\u1055\u62b3ar;\u69d0qual;\u62b5p\u0180DTV\u1063\u106e\u1078ownVector;\u694feeVector;\u695cector\u0100;B\u1082\u1083\u61bear;\u6954ector\u0100;B\u1091\u1092\u61c0ar;\u6953\u0100pu\u109b\u109ef;\u611dndImplies;\u6970ightarrow;\u61db\u0100ch\u10b9\u10bcr;\u611b;\u61b1leDelayed;\u69f4\u0680HOacfhimoqstu\u10e4\u10f1\u10f7\u10fd\u1119\u111e\u1151\u1156\u1161\u1167\u11b5\u11bb\u11bf\u0100Cc\u10e9\u10eeHcy;\u4429y;\u4428FTcy;\u442ccute;\u415a\u0280;aeiy\u1108\u1109\u110e\u1113\u1117\u6abcron;\u4160dil;\u415erc;\u415c;\u4421r;\uc000\ud835\udd16ort\u0200DLRU\u112a\u1134\u113e\u1149ownArrow\xbb\u041eeftArrow\xbb\u089aightArrow\xbb\u0fddpArrow;\u6191gma;\u43a3allCircle;\u6218pf;\uc000\ud835\udd4a\u0272\u116d\0\0\u1170t;\u621aare\u0200;ISU\u117b\u117c\u1189\u11af\u65a1ntersection;\u6293u\u0100bp\u118f\u119eset\u0100;E\u1197\u1198\u628fqual;\u6291erset\u0100;E\u11a8\u11a9\u6290qual;\u6292nion;\u6294cr;\uc000\ud835\udcaear;\u62c6\u0200bcmp\u11c8\u11db\u1209\u120b\u0100;s\u11cd\u11ce\u62d0et\u0100;E\u11cd\u11d5qual;\u6286\u0100ch\u11e0\u1205eeds\u0200;EST\u11ed\u11ee\u11f4\u11ff\u627bqual;\u6ab0lantEqual;\u627dilde;\u627fTh\xe1\u0f8c;\u6211\u0180;es\u1212\u1213\u1223\u62d1rset\u0100;E\u121c\u121d\u6283qual;\u6287et\xbb\u1213\u0580HRSacfhiors\u123e\u1244\u1249\u1255\u125e\u1271\u1276\u129f\u12c2\u12c8\u12d1ORN\u803b\xde\u40deADE;\u6122\u0100Hc\u124e\u1252cy;\u440by;\u4426\u0100bu\u125a\u125c;\u4009;\u43a4\u0180aey\u1265\u126a\u126fron;\u4164dil;\u4162;\u4422r;\uc000\ud835\udd17\u0100ei\u127b\u1289\u01f2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128e\u1298kSpace;\uc000\u205f\u200aSpace;\u6009lde\u0200;EFT\u12ab\u12ac\u12b2\u12bc\u623cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uc000\ud835\udd4bipleDot;\u60db\u0100ct\u12d6\u12dbr;\uc000\ud835\udcafrok;\u4166\u0ae1\u12f7\u130e\u131a\u1326\0\u132c\u1331\0\0\0\0\0\u1338\u133d\u1377\u1385\0\u13ff\u1404\u140a\u1410\u0100cr\u12fb\u1301ute\u803b\xda\u40dar\u0100;o\u1307\u1308\u619fcir;\u6949r\u01e3\u1313\0\u1316y;\u440eve;\u416c\u0100iy\u131e\u1323rc\u803b\xdb\u40db;\u4423blac;\u4170r;\uc000\ud835\udd18rave\u803b\xd9\u40d9acr;\u416a\u0100di\u1341\u1369er\u0100BP\u1348\u135d\u0100ar\u134d\u1350r;\u405fac\u0100ek\u1357\u1359;\u63dfet;\u63b5arenthesis;\u63ddon\u0100;P\u1370\u1371\u62c3lus;\u628e\u0100gp\u137b\u137fon;\u4172f;\uc000\ud835\udd4c\u0400ADETadps\u1395\u13ae\u13b8\u13c4\u03e8\u13d2\u13d7\u13f3rrow\u0180;BD\u1150\u13a0\u13a4ar;\u6912ownArrow;\u61c5ownArrow;\u6195quilibrium;\u696eee\u0100;A\u13cb\u13cc\u62a5rrow;\u61a5own\xe1\u03f3er\u0100LR\u13de\u13e8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13f9\u13fa\u43d2on;\u43a5ing;\u416ecr;\uc000\ud835\udcb0ilde;\u4168ml\u803b\xdc\u40dc\u0480Dbcdefosv\u1427\u142c\u1430\u1433\u143e\u1485\u148a\u1490\u1496ash;\u62abar;\u6aeby;\u4412ash\u0100;l\u143b\u143c\u62a9;\u6ae6\u0100er\u1443\u1445;\u62c1\u0180bty\u144c\u1450\u147aar;\u6016\u0100;i\u144f\u1455cal\u0200BLST\u1461\u1465\u146a\u1474ar;\u6223ine;\u407ceparator;\u6758ilde;\u6240ThinSpace;\u600ar;\uc000\ud835\udd19pf;\uc000\ud835\udd4dcr;\uc000\ud835\udcb1dash;\u62aa\u0280cefos\u14a7\u14ac\u14b1\u14b6\u14bcirc;\u4174dge;\u62c0r;\uc000\ud835\udd1apf;\uc000\ud835\udd4ecr;\uc000\ud835\udcb2\u0200fios\u14cb\u14d0\u14d2\u14d8r;\uc000\ud835\udd1b;\u439epf;\uc000\ud835\udd4fcr;\uc000\ud835\udcb3\u0480AIUacfosu\u14f1\u14f5\u14f9\u14fd\u1504\u150f\u1514\u151a\u1520cy;\u442fcy;\u4407cy;\u442ecute\u803b\xdd\u40dd\u0100iy\u1509\u150drc;\u4176;\u442br;\uc000\ud835\udd1cpf;\uc000\ud835\udd50cr;\uc000\ud835\udcb4ml;\u4178\u0400Hacdefos\u1535\u1539\u153f\u154b\u154f\u155d\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417d;\u4417ot;\u417b\u01f2\u1554\0\u155boWidt\xe8\u0ad9a;\u4396r;\u6128pf;\u6124cr;\uc000\ud835\udcb5\u0be1\u1583\u158a\u1590\0\u15b0\u15b6\u15bf\0\0\0\0\u15c6\u15db\u15eb\u165f\u166d\0\u1695\u169b\u16b2\u16b9\0\u16becute\u803b\xe1\u40e1reve;\u4103\u0300;Ediuy\u159c\u159d\u15a1\u15a3\u15a8\u15ad\u623e;\uc000\u223e\u0333;\u623frc\u803b\xe2\u40e2te\u80bb\xb4\u0306;\u4430lig\u803b\xe6\u40e6\u0100;r\xb2\u15ba;\uc000\ud835\udd1erave\u803b\xe0\u40e0\u0100ep\u15ca\u15d6\u0100fp\u15cf\u15d4sym;\u6135\xe8\u15d3ha;\u43b1\u0100ap\u15dfc\u0100cl\u15e4\u15e7r;\u4101g;\u6a3f\u0264\u15f0\0\0\u160a\u0280;adsv\u15fa\u15fb\u15ff\u1601\u1607\u6227nd;\u6a55;\u6a5clope;\u6a58;\u6a5a\u0380;elmrsz\u1618\u1619\u161b\u161e\u163f\u164f\u1659\u6220;\u69a4e\xbb\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163a\u163c\u163e;\u69a8;\u69a9;\u69aa;\u69ab;\u69ac;\u69ad;\u69ae;\u69aft\u0100;v\u1645\u1646\u621fb\u0100;d\u164c\u164d\u62be;\u699d\u0100pt\u1654\u1657h;\u6222\xbb\xb9arr;\u637c\u0100gp\u1663\u1667on;\u4105f;\uc000\ud835\udd52\u0380;Eaeiop\u12c1\u167b\u167d\u1682\u1684\u1687\u168a;\u6a70cir;\u6a6f;\u624ad;\u624bs;\u4027rox\u0100;e\u12c1\u1692\xf1\u1683ing\u803b\xe5\u40e5\u0180cty\u16a1\u16a6\u16a8r;\uc000\ud835\udcb6;\u402amp\u0100;e\u12c1\u16af\xf1\u0288ilde\u803b\xe3\u40e3ml\u803b\xe4\u40e4\u0100ci\u16c2\u16c8onin\xf4\u0272nt;\u6a11\u0800Nabcdefiklnoprsu\u16ed\u16f1\u1730\u173c\u1743\u1748\u1778\u177d\u17e0\u17e6\u1839\u1850\u170d\u193d\u1948\u1970ot;\u6aed\u0100cr\u16f6\u171ek\u0200ceps\u1700\u1705\u170d\u1713ong;\u624cpsilon;\u43f6rime;\u6035im\u0100;e\u171a\u171b\u623dq;\u62cd\u0176\u1722\u1726ee;\u62bded\u0100;g\u172c\u172d\u6305e\xbb\u172drk\u0100;t\u135c\u1737brk;\u63b6\u0100oy\u1701\u1741;\u4431quo;\u601e\u0280cmprt\u1753\u175b\u1761\u1764\u1768aus\u0100;e\u010a\u0109ptyv;\u69b0s\xe9\u170cno\xf5\u0113\u0180ahw\u176f\u1771\u1773;\u43b2;\u6136een;\u626cr;\uc000\ud835\udd1fg\u0380costuvw\u178d\u179d\u17b3\u17c1\u17d5\u17db\u17de\u0180aiu\u1794\u1796\u179a\xf0\u0760rc;\u65efp\xbb\u1371\u0180dpt\u17a4\u17a8\u17adot;\u6a00lus;\u6a01imes;\u6a02\u0271\u17b9\0\0\u17becup;\u6a06ar;\u6605riangle\u0100du\u17cd\u17d2own;\u65bdp;\u65b3plus;\u6a04e\xe5\u1444\xe5\u14adarow;\u690d\u0180ako\u17ed\u1826\u1835\u0100cn\u17f2\u1823k\u0180lst\u17fa\u05ab\u1802ozenge;\u69ebriangle\u0200;dlr\u1812\u1813\u1818\u181d\u65b4own;\u65beeft;\u65c2ight;\u65b8k;\u6423\u01b1\u182b\0\u1833\u01b2\u182f\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183e\u184d\u0100;q\u1843\u1846\uc000=\u20e5uiv;\uc000\u2261\u20e5t;\u6310\u0200ptwx\u1859\u185e\u1867\u186cf;\uc000\ud835\udd53\u0100;t\u13cb\u1863om\xbb\u13cctie;\u62c8\u0600DHUVbdhmptuv\u1885\u1896\u18aa\u18bb\u18d7\u18db\u18ec\u18ff\u1905\u190a\u1910\u1921\u0200LRlr\u188e\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18a1\u18a2\u18a4\u18a6\u18a8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18b3\u18b5\u18b7\u18b9;\u655d;\u655a;\u655c;\u6559\u0380;HLRhlr\u18ca\u18cb\u18cd\u18cf\u18d1\u18d3\u18d5\u6551;\u656c;\u6563;\u6560;\u656b;\u6562;\u655fox;\u69c9\u0200LRlr\u18e4\u18e6\u18e8\u18ea;\u6555;\u6552;\u6510;\u650c\u0280;DUdu\u06bd\u18f7\u18f9\u18fb\u18fd;\u6565;\u6568;\u652c;\u6534inus;\u629flus;\u629eimes;\u62a0\u0200LRlr\u1919\u191b\u191d\u191f;\u655b;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193b\u6502;\u656a;\u6561;\u655e;\u653c;\u6524;\u651c\u0100ev\u0123\u1942bar\u803b\xa6\u40a6\u0200ceio\u1951\u1956\u195a\u1960r;\uc000\ud835\udcb7mi;\u604fm\u0100;e\u171a\u171cl\u0180;bh\u1968\u1969\u196b\u405c;\u69c5sub;\u67c8\u016c\u1974\u197el\u0100;e\u1979\u197a\u6022t\xbb\u197ap\u0180;Ee\u012f\u1985\u1987;\u6aae\u0100;q\u06dc\u06db\u0ce1\u19a7\0\u19e8\u1a11\u1a15\u1a32\0\u1a37\u1a50\0\0\u1ab4\0\0\u1ac1\0\0\u1b21\u1b2e\u1b4d\u1b52\0\u1bfd\0\u1c0c\u0180cpr\u19ad\u19b2\u19ddute;\u4107\u0300;abcds\u19bf\u19c0\u19c4\u19ca\u19d5\u19d9\u6229nd;\u6a44rcup;\u6a49\u0100au\u19cf\u19d2p;\u6a4bp;\u6a47ot;\u6a40;\uc000\u2229\ufe00\u0100eo\u19e2\u19e5t;\u6041\xee\u0693\u0200aeiu\u19f0\u19fb\u1a01\u1a05\u01f0\u19f5\0\u19f8s;\u6a4don;\u410ddil\u803b\xe7\u40e7rc;\u4109ps\u0100;s\u1a0c\u1a0d\u6a4cm;\u6a50ot;\u410b\u0180dmn\u1a1b\u1a20\u1a26il\u80bb\xb8\u01adptyv;\u69b2t\u8100\xa2;e\u1a2d\u1a2e\u40a2r\xe4\u01b2r;\uc000\ud835\udd20\u0180cei\u1a3d\u1a40\u1a4dy;\u4447ck\u0100;m\u1a47\u1a48\u6713ark\xbb\u1a48;\u43c7r\u0380;Ecefms\u1a5f\u1a60\u1a62\u1a6b\u1aa4\u1aaa\u1aae\u65cb;\u69c3\u0180;el\u1a69\u1a6a\u1a6d\u42c6q;\u6257e\u0261\u1a74\0\0\u1a88rrow\u0100lr\u1a7c\u1a81eft;\u61baight;\u61bb\u0280RSacd\u1a92\u1a94\u1a96\u1a9a\u1a9f\xbb\u0f47;\u64c8st;\u629birc;\u629aash;\u629dnint;\u6a10id;\u6aefcir;\u69c2ubs\u0100;u\u1abb\u1abc\u6663it\xbb\u1abc\u02ec\u1ac7\u1ad4\u1afa\0\u1b0aon\u0100;e\u1acd\u1ace\u403a\u0100;q\xc7\xc6\u026d\u1ad9\0\0\u1ae2a\u0100;t\u1ade\u1adf\u402c;\u4040\u0180;fl\u1ae8\u1ae9\u1aeb\u6201\xee\u1160e\u0100mx\u1af1\u1af6ent\xbb\u1ae9e\xf3\u024d\u01e7\u1afe\0\u1b07\u0100;d\u12bb\u1b02ot;\u6a6dn\xf4\u0246\u0180fry\u1b10\u1b14\u1b17;\uc000\ud835\udd54o\xe4\u0254\u8100\xa9;s\u0155\u1b1dr;\u6117\u0100ao\u1b25\u1b29rr;\u61b5ss;\u6717\u0100cu\u1b32\u1b37r;\uc000\ud835\udcb8\u0100bp\u1b3c\u1b44\u0100;e\u1b41\u1b42\u6acf;\u6ad1\u0100;e\u1b49\u1b4a\u6ad0;\u6ad2dot;\u62ef\u0380delprvw\u1b60\u1b6c\u1b77\u1b82\u1bac\u1bd4\u1bf9arr\u0100lr\u1b68\u1b6a;\u6938;\u6935\u0270\u1b72\0\0\u1b75r;\u62dec;\u62dfarr\u0100;p\u1b7f\u1b80\u61b6;\u693d\u0300;bcdos\u1b8f\u1b90\u1b96\u1ba1\u1ba5\u1ba8\u622arcap;\u6a48\u0100au\u1b9b\u1b9ep;\u6a46p;\u6a4aot;\u628dr;\u6a45;\uc000\u222a\ufe00\u0200alrv\u1bb5\u1bbf\u1bde\u1be3rr\u0100;m\u1bbc\u1bbd\u61b7;\u693cy\u0180evw\u1bc7\u1bd4\u1bd8q\u0270\u1bce\0\0\u1bd2re\xe3\u1b73u\xe3\u1b75ee;\u62ceedge;\u62cfen\u803b\xa4\u40a4earrow\u0100lr\u1bee\u1bf3eft\xbb\u1b80ight\xbb\u1bbde\xe4\u1bdd\u0100ci\u1c01\u1c07onin\xf4\u01f7nt;\u6231lcty;\u632d\u0980AHabcdefhijlorstuwz\u1c38\u1c3b\u1c3f\u1c5d\u1c69\u1c75\u1c8a\u1c9e\u1cac\u1cb7\u1cfb\u1cff\u1d0d\u1d7b\u1d91\u1dab\u1dbb\u1dc6\u1dcdr\xf2\u0381ar;\u6965\u0200glrs\u1c48\u1c4d\u1c52\u1c54ger;\u6020eth;\u6138\xf2\u1133h\u0100;v\u1c5a\u1c5b\u6010\xbb\u090a\u016b\u1c61\u1c67arow;\u690fa\xe3\u0315\u0100ay\u1c6e\u1c73ron;\u410f;\u4434\u0180;ao\u0332\u1c7c\u1c84\u0100gr\u02bf\u1c81r;\u61catseq;\u6a77\u0180glm\u1c91\u1c94\u1c98\u803b\xb0\u40b0ta;\u43b4ptyv;\u69b1\u0100ir\u1ca3\u1ca8sht;\u697f;\uc000\ud835\udd21ar\u0100lr\u1cb3\u1cb5\xbb\u08dc\xbb\u101e\u0280aegsv\u1cc2\u0378\u1cd6\u1cdc\u1ce0m\u0180;os\u0326\u1cca\u1cd4nd\u0100;s\u0326\u1cd1uit;\u6666amma;\u43ddin;\u62f2\u0180;io\u1ce7\u1ce8\u1cf8\u40f7de\u8100\xf7;o\u1ce7\u1cf0ntimes;\u62c7n\xf8\u1cf7cy;\u4452c\u026f\u1d06\0\0\u1d0arn;\u631eop;\u630d\u0280lptuw\u1d18\u1d1d\u1d22\u1d49\u1d55lar;\u4024f;\uc000\ud835\udd55\u0280;emps\u030b\u1d2d\u1d37\u1d3d\u1d42q\u0100;d\u0352\u1d33ot;\u6251inus;\u6238lus;\u6214quare;\u62a1blebarwedg\xe5\xfan\u0180adh\u112e\u1d5d\u1d67ownarrow\xf3\u1c83arpoon\u0100lr\u1d72\u1d76ef\xf4\u1cb4igh\xf4\u1cb6\u0162\u1d7f\u1d85karo\xf7\u0f42\u026f\u1d8a\0\0\u1d8ern;\u631fop;\u630c\u0180cot\u1d98\u1da3\u1da6\u0100ry\u1d9d\u1da1;\uc000\ud835\udcb9;\u4455l;\u69f6rok;\u4111\u0100dr\u1db0\u1db4ot;\u62f1i\u0100;f\u1dba\u1816\u65bf\u0100ah\u1dc0\u1dc3r\xf2\u0429a\xf2\u0fa6angle;\u69a6\u0100ci\u1dd2\u1dd5y;\u445fgrarr;\u67ff\u0900Dacdefglmnopqrstux\u1e01\u1e09\u1e19\u1e38\u0578\u1e3c\u1e49\u1e61\u1e7e\u1ea5\u1eaf\u1ebd\u1ee1\u1f2a\u1f37\u1f44\u1f4e\u1f5a\u0100Do\u1e06\u1d34o\xf4\u1c89\u0100cs\u1e0e\u1e14ute\u803b\xe9\u40e9ter;\u6a6e\u0200aioy\u1e22\u1e27\u1e31\u1e36ron;\u411br\u0100;c\u1e2d\u1e2e\u6256\u803b\xea\u40ealon;\u6255;\u444dot;\u4117\u0100Dr\u1e41\u1e45ot;\u6252;\uc000\ud835\udd22\u0180;rs\u1e50\u1e51\u1e57\u6a9aave\u803b\xe8\u40e8\u0100;d\u1e5c\u1e5d\u6a96ot;\u6a98\u0200;ils\u1e6a\u1e6b\u1e72\u1e74\u6a99nters;\u63e7;\u6113\u0100;d\u1e79\u1e7a\u6a95ot;\u6a97\u0180aps\u1e85\u1e89\u1e97cr;\u4113ty\u0180;sv\u1e92\u1e93\u1e95\u6205et\xbb\u1e93p\u01001;\u1e9d\u1ea4\u0133\u1ea1\u1ea3;\u6004;\u6005\u6003\u0100gs\u1eaa\u1eac;\u414bp;\u6002\u0100gp\u1eb4\u1eb8on;\u4119f;\uc000\ud835\udd56\u0180als\u1ec4\u1ece\u1ed2r\u0100;s\u1eca\u1ecb\u62d5l;\u69e3us;\u6a71i\u0180;lv\u1eda\u1edb\u1edf\u43b5on\xbb\u1edb;\u43f5\u0200csuv\u1eea\u1ef3\u1f0b\u1f23\u0100io\u1eef\u1e31rc\xbb\u1e2e\u0269\u1ef9\0\0\u1efb\xed\u0548ant\u0100gl\u1f02\u1f06tr\xbb\u1e5dess\xbb\u1e7a\u0180aei\u1f12\u1f16\u1f1als;\u403dst;\u625fv\u0100;D\u0235\u1f20D;\u6a78parsl;\u69e5\u0100Da\u1f2f\u1f33ot;\u6253rr;\u6971\u0180cdi\u1f3e\u1f41\u1ef8r;\u612fo\xf4\u0352\u0100ah\u1f49\u1f4b;\u43b7\u803b\xf0\u40f0\u0100mr\u1f53\u1f57l\u803b\xeb\u40ebo;\u60ac\u0180cip\u1f61\u1f64\u1f67l;\u4021s\xf4\u056e\u0100eo\u1f6c\u1f74ctatio\xee\u0559nential\xe5\u0579\u09e1\u1f92\0\u1f9e\0\u1fa1\u1fa7\0\0\u1fc6\u1fcc\0\u1fd3\0\u1fe6\u1fea\u2000\0\u2008\u205allingdotse\xf1\u1e44y;\u4444male;\u6640\u0180ilr\u1fad\u1fb3\u1fc1lig;\u8000\ufb03\u0269\u1fb9\0\0\u1fbdg;\u8000\ufb00ig;\u8000\ufb04;\uc000\ud835\udd23lig;\u8000\ufb01lig;\uc000fj\u0180alt\u1fd9\u1fdc\u1fe1t;\u666dig;\u8000\ufb02ns;\u65b1of;\u4192\u01f0\u1fee\0\u1ff3f;\uc000\ud835\udd57\u0100ak\u05bf\u1ff7\u0100;v\u1ffc\u1ffd\u62d4;\u6ad9artint;\u6a0d\u0100ao\u200c\u2055\u0100cs\u2011\u2052\u03b1\u201a\u2030\u2038\u2045\u2048\0\u2050\u03b2\u2022\u2025\u2027\u202a\u202c\0\u202e\u803b\xbd\u40bd;\u6153\u803b\xbc\u40bc;\u6155;\u6159;\u615b\u01b3\u2034\0\u2036;\u6154;\u6156\u02b4\u203e\u2041\0\0\u2043\u803b\xbe\u40be;\u6157;\u615c5;\u6158\u01b6\u204c\0\u204e;\u615a;\u615d8;\u615el;\u6044wn;\u6322cr;\uc000\ud835\udcbb\u0880Eabcdefgijlnorstv\u2082\u2089\u209f\u20a5\u20b0\u20b4\u20f0\u20f5\u20fa\u20ff\u2103\u2112\u2138\u0317\u213e\u2152\u219e\u0100;l\u064d\u2087;\u6a8c\u0180cmp\u2090\u2095\u209dute;\u41f5ma\u0100;d\u209c\u1cda\u43b3;\u6a86reve;\u411f\u0100iy\u20aa\u20aerc;\u411d;\u4433ot;\u4121\u0200;lqs\u063e\u0642\u20bd\u20c9\u0180;qs\u063e\u064c\u20c4lan\xf4\u0665\u0200;cdl\u0665\u20d2\u20d5\u20e5c;\u6aa9ot\u0100;o\u20dc\u20dd\u6a80\u0100;l\u20e2\u20e3\u6a82;\u6a84\u0100;e\u20ea\u20ed\uc000\u22db\ufe00s;\u6a94r;\uc000\ud835\udd24\u0100;g\u0673\u061bmel;\u6137cy;\u4453\u0200;Eaj\u065a\u210c\u210e\u2110;\u6a92;\u6aa5;\u6aa4\u0200Eaes\u211b\u211d\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6a8arox\xbb\u2124\u0100;q\u212e\u212f\u6a88\u0100;q\u212e\u211bim;\u62e7pf;\uc000\ud835\udd58\u0100ci\u2143\u2146r;\u610am\u0180;el\u066b\u214e\u2150;\u6a8e;\u6a90\u8300>;cdlqr\u05ee\u2160\u216a\u216e\u2173\u2179\u0100ci\u2165\u2167;\u6aa7r;\u6a7aot;\u62d7Par;\u6995uest;\u6a7c\u0280adels\u2184\u216a\u2190\u0656\u219b\u01f0\u2189\0\u218epro\xf8\u209er;\u6978q\u0100lq\u063f\u2196les\xf3\u2088i\xed\u066b\u0100en\u21a3\u21adrtneqq;\uc000\u2269\ufe00\xc5\u21aa\u0500Aabcefkosy\u21c4\u21c7\u21f1\u21f5\u21fa\u2218\u221d\u222f\u2268\u227dr\xf2\u03a0\u0200ilmr\u21d0\u21d4\u21d7\u21dbrs\xf0\u1484f\xbb\u2024il\xf4\u06a9\u0100dr\u21e0\u21e4cy;\u444a\u0180;cw\u08f4\u21eb\u21efir;\u6948;\u61adar;\u610firc;\u4125\u0180alr\u2201\u220e\u2213rts\u0100;u\u2209\u220a\u6665it\xbb\u220alip;\u6026con;\u62b9r;\uc000\ud835\udd25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223a\u223e\u2243\u225e\u2263rr;\u61fftht;\u623bk\u0100lr\u2249\u2253eftarrow;\u61a9ightarrow;\u61aaf;\uc000\ud835\udd59bar;\u6015\u0180clt\u226f\u2274\u2278r;\uc000\ud835\udcbdas\xe8\u21f4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xbb\u1c5b\u0ae1\u22a3\0\u22aa\0\u22b8\u22c5\u22ce\0\u22d5\u22f3\0\0\u22f8\u2322\u2367\u2362\u237f\0\u2386\u23aa\u23b4cute\u803b\xed\u40ed\u0180;iy\u0771\u22b0\u22b5rc\u803b\xee\u40ee;\u4438\u0100cx\u22bc\u22bfy;\u4435cl\u803b\xa1\u40a1\u0100fr\u039f\u22c9;\uc000\ud835\udd26rave\u803b\xec\u40ec\u0200;ino\u073e\u22dd\u22e9\u22ee\u0100in\u22e2\u22e6nt;\u6a0ct;\u622dfin;\u69dcta;\u6129lig;\u4133\u0180aop\u22fe\u231a\u231d\u0180cgt\u2305\u2308\u2317r;\u412b\u0180elp\u071f\u230f\u2313in\xe5\u078ear\xf4\u0720h;\u4131f;\u62b7ed;\u41b5\u0280;cfot\u04f4\u232c\u2331\u233d\u2341are;\u6105in\u0100;t\u2338\u2339\u621eie;\u69dddo\xf4\u2319\u0280;celp\u0757\u234c\u2350\u235b\u2361al;\u62ba\u0100gr\u2355\u2359er\xf3\u1563\xe3\u234darhk;\u6a17rod;\u6a3c\u0200cgpt\u236f\u2372\u2376\u237by;\u4451on;\u412ff;\uc000\ud835\udd5aa;\u43b9uest\u803b\xbf\u40bf\u0100ci\u238a\u238fr;\uc000\ud835\udcben\u0280;Edsv\u04f4\u239b\u239d\u23a1\u04f3;\u62f9ot;\u62f5\u0100;v\u23a6\u23a7\u62f4;\u62f3\u0100;i\u0777\u23aelde;\u4129\u01eb\u23b8\0\u23bccy;\u4456l\u803b\xef\u40ef\u0300cfmosu\u23cc\u23d7\u23dc\u23e1\u23e7\u23f5\u0100iy\u23d1\u23d5rc;\u4135;\u4439r;\uc000\ud835\udd27ath;\u4237pf;\uc000\ud835\udd5b\u01e3\u23ec\0\u23f1r;\uc000\ud835\udcbfrcy;\u4458kcy;\u4454\u0400acfghjos\u240b\u2416\u2422\u2427\u242d\u2431\u2435\u243bppa\u0100;v\u2413\u2414\u43ba;\u43f0\u0100ey\u241b\u2420dil;\u4137;\u443ar;\uc000\ud835\udd28reen;\u4138cy;\u4445cy;\u445cpf;\uc000\ud835\udd5ccr;\uc000\ud835\udcc0\u0b80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248d\u2491\u250e\u253d\u255a\u2580\u264e\u265e\u2665\u2679\u267d\u269a\u26b2\u26d8\u275d\u2768\u278b\u27c0\u2801\u2812\u0180art\u2477\u247a\u247cr\xf2\u09c6\xf2\u0395ail;\u691barr;\u690e\u0100;g\u0994\u248b;\u6a8bar;\u6962\u0963\u24a5\0\u24aa\0\u24b1\0\0\0\0\0\u24b5\u24ba\0\u24c6\u24c8\u24cd\0\u24f9ute;\u413amptyv;\u69b4ra\xee\u084cbda;\u43bbg\u0180;dl\u088e\u24c1\u24c3;\u6991\xe5\u088e;\u6a85uo\u803b\xab\u40abr\u0400;bfhlpst\u0899\u24de\u24e6\u24e9\u24eb\u24ee\u24f1\u24f5\u0100;f\u089d\u24e3s;\u691fs;\u691d\xeb\u2252p;\u61abl;\u6939im;\u6973l;\u61a2\u0180;ae\u24ff\u2500\u2504\u6aabil;\u6919\u0100;s\u2509\u250a\u6aad;\uc000\u2aad\ufe00\u0180abr\u2515\u2519\u251drr;\u690crk;\u6772\u0100ak\u2522\u252cc\u0100ek\u2528\u252a;\u407b;\u405b\u0100es\u2531\u2533;\u698bl\u0100du\u2539\u253b;\u698f;\u698d\u0200aeuy\u2546\u254b\u2556\u2558ron;\u413e\u0100di\u2550\u2554il;\u413c\xec\u08b0\xe2\u2529;\u443b\u0200cqrs\u2563\u2566\u256d\u257da;\u6936uo\u0100;r\u0e19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694bh;\u61b2\u0280;fgqs\u258b\u258c\u0989\u25f3\u25ff\u6264t\u0280ahlrt\u2598\u25a4\u25b7\u25c2\u25e8rrow\u0100;t\u0899\u25a1a\xe9\u24f6arpoon\u0100du\u25af\u25b4own\xbb\u045ap\xbb\u0966eftarrows;\u61c7ight\u0180ahs\u25cd\u25d6\u25derrow\u0100;s\u08f4\u08a7arpoon\xf3\u0f98quigarro\xf7\u21f0hreetimes;\u62cb\u0180;qs\u258b\u0993\u25falan\xf4\u09ac\u0280;cdgs\u09ac\u260a\u260d\u261d\u2628c;\u6aa8ot\u0100;o\u2614\u2615\u6a7f\u0100;r\u261a\u261b\u6a81;\u6a83\u0100;e\u2622\u2625\uc000\u22da\ufe00s;\u6a93\u0280adegs\u2633\u2639\u263d\u2649\u264bppro\xf8\u24c6ot;\u62d6q\u0100gq\u2643\u2645\xf4\u0989gt\xf2\u248c\xf4\u099bi\xed\u09b2\u0180ilr\u2655\u08e1\u265asht;\u697c;\uc000\ud835\udd29\u0100;E\u099c\u2663;\u6a91\u0161\u2669\u2676r\u0100du\u25b2\u266e\u0100;l\u0965\u2673;\u696alk;\u6584cy;\u4459\u0280;acht\u0a48\u2688\u268b\u2691\u2696r\xf2\u25c1orne\xf2\u1d08ard;\u696bri;\u65fa\u0100io\u269f\u26a4dot;\u4140ust\u0100;a\u26ac\u26ad\u63b0che\xbb\u26ad\u0200Eaes\u26bb\u26bd\u26c9\u26d4;\u6268p\u0100;p\u26c3\u26c4\u6a89rox\xbb\u26c4\u0100;q\u26ce\u26cf\u6a87\u0100;q\u26ce\u26bbim;\u62e6\u0400abnoptwz\u26e9\u26f4\u26f7\u271a\u272f\u2741\u2747\u2750\u0100nr\u26ee\u26f1g;\u67ecr;\u61fdr\xeb\u08c1g\u0180lmr\u26ff\u270d\u2714eft\u0100ar\u09e6\u2707ight\xe1\u09f2apsto;\u67fcight\xe1\u09fdparrow\u0100lr\u2725\u2729ef\xf4\u24edight;\u61ac\u0180afl\u2736\u2739\u273dr;\u6985;\uc000\ud835\udd5dus;\u6a2dimes;\u6a34\u0161\u274b\u274fst;\u6217\xe1\u134e\u0180;ef\u2757\u2758\u1800\u65cange\xbb\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277c\u2785\u2787r\xf2\u08a8orne\xf2\u1d8car\u0100;d\u0f98\u2783;\u696d;\u600eri;\u62bf\u0300achiqt\u2798\u279d\u0a40\u27a2\u27ae\u27bbquo;\u6039r;\uc000\ud835\udcc1m\u0180;eg\u09b2\u27aa\u27ac;\u6a8d;\u6a8f\u0100bu\u252a\u27b3o\u0100;r\u0e1f\u27b9;\u601arok;\u4142\u8400<;cdhilqr\u082b\u27d2\u2639\u27dc\u27e0\u27e5\u27ea\u27f0\u0100ci\u27d7\u27d9;\u6aa6r;\u6a79re\xe5\u25f2mes;\u62c9arr;\u6976uest;\u6a7b\u0100Pi\u27f5\u27f9ar;\u6996\u0180;ef\u2800\u092d\u181b\u65c3r\u0100du\u2807\u280dshar;\u694ahar;\u6966\u0100en\u2817\u2821rtneqq;\uc000\u2268\ufe00\xc5\u281e\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288e\u2893\u28a0\u28a5\u28a8\u28da\u28e2\u28e4\u0a83\u28f3\u2902Dot;\u623a\u0200clpr\u284e\u2852\u2863\u287dr\u803b\xaf\u40af\u0100et\u2857\u2859;\u6642\u0100;e\u285e\u285f\u6720se\xbb\u285f\u0100;s\u103b\u2868to\u0200;dlu\u103b\u2873\u2877\u287bow\xee\u048cef\xf4\u090f\xf0\u13d1ker;\u65ae\u0100oy\u2887\u288cmma;\u6a29;\u443cash;\u6014asuredangle\xbb\u1626r;\uc000\ud835\udd2ao;\u6127\u0180cdn\u28af\u28b4\u28c9ro\u803b\xb5\u40b5\u0200;acd\u1464\u28bd\u28c0\u28c4s\xf4\u16a7ir;\u6af0ot\u80bb\xb7\u01b5us\u0180;bd\u28d2\u1903\u28d3\u6212\u0100;u\u1d3c\u28d8;\u6a2a\u0163\u28de\u28e1p;\u6adb\xf2\u2212\xf0\u0a81\u0100dp\u28e9\u28eeels;\u62a7f;\uc000\ud835\udd5e\u0100ct\u28f8\u28fdr;\uc000\ud835\udcc2pos\xbb\u159d\u0180;lm\u2909\u290a\u290d\u43bctimap;\u62b8\u0c00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297e\u2989\u2998\u29da\u29e9\u2a15\u2a1a\u2a58\u2a5d\u2a83\u2a95\u2aa4\u2aa8\u2b04\u2b07\u2b44\u2b7f\u2bae\u2c34\u2c67\u2c7c\u2ce9\u0100gt\u2947\u294b;\uc000\u22d9\u0338\u0100;v\u2950\u0bcf\uc000\u226b\u20d2\u0180elt\u295a\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61cdightarrow;\u61ce;\uc000\u22d8\u0338\u0100;v\u297b\u0c47\uc000\u226a\u20d2ightarrow;\u61cf\u0100Dd\u298e\u2993ash;\u62afash;\u62ae\u0280bcnpt\u29a3\u29a7\u29ac\u29b1\u29ccla\xbb\u02deute;\u4144g;\uc000\u2220\u20d2\u0280;Eiop\u0d84\u29bc\u29c0\u29c5\u29c8;\uc000\u2a70\u0338d;\uc000\u224b\u0338s;\u4149ro\xf8\u0d84ur\u0100;a\u29d3\u29d4\u666el\u0100;s\u29d3\u0b38\u01f3\u29df\0\u29e3p\u80bb\xa0\u0b37mp\u0100;e\u0bf9\u0c00\u0280aeouy\u29f4\u29fe\u2a03\u2a10\u2a13\u01f0\u29f9\0\u29fb;\u6a43on;\u4148dil;\u4146ng\u0100;d\u0d7e\u2a0aot;\uc000\u2a6d\u0338p;\u6a42;\u443dash;\u6013\u0380;Aadqsx\u0b92\u2a29\u2a2d\u2a3b\u2a41\u2a45\u2a50rr;\u61d7r\u0100hr\u2a33\u2a36k;\u6924\u0100;o\u13f2\u13f0ot;\uc000\u2250\u0338ui\xf6\u0b63\u0100ei\u2a4a\u2a4ear;\u6928\xed\u0b98ist\u0100;s\u0ba0\u0b9fr;\uc000\ud835\udd2b\u0200Eest\u0bc5\u2a66\u2a79\u2a7c\u0180;qs\u0bbc\u2a6d\u0be1\u0180;qs\u0bbc\u0bc5\u2a74lan\xf4\u0be2i\xed\u0bea\u0100;r\u0bb6\u2a81\xbb\u0bb7\u0180Aap\u2a8a\u2a8d\u2a91r\xf2\u2971rr;\u61aear;\u6af2\u0180;sv\u0f8d\u2a9c\u0f8c\u0100;d\u2aa1\u2aa2\u62fc;\u62facy;\u445a\u0380AEadest\u2ab7\u2aba\u2abe\u2ac2\u2ac5\u2af6\u2af9r\xf2\u2966;\uc000\u2266\u0338rr;\u619ar;\u6025\u0200;fqs\u0c3b\u2ace\u2ae3\u2aeft\u0100ar\u2ad4\u2ad9rro\xf7\u2ac1ightarro\xf7\u2a90\u0180;qs\u0c3b\u2aba\u2aealan\xf4\u0c55\u0100;s\u0c55\u2af4\xbb\u0c36i\xed\u0c5d\u0100;r\u0c35\u2afei\u0100;e\u0c1a\u0c25i\xe4\u0d90\u0100pt\u2b0c\u2b11f;\uc000\ud835\udd5f\u8180\xac;in\u2b19\u2b1a\u2b36\u40acn\u0200;Edv\u0b89\u2b24\u2b28\u2b2e;\uc000\u22f9\u0338ot;\uc000\u22f5\u0338\u01e1\u0b89\u2b33\u2b35;\u62f7;\u62f6i\u0100;v\u0cb8\u2b3c\u01e1\u0cb8\u2b41\u2b43;\u62fe;\u62fd\u0180aor\u2b4b\u2b63\u2b69r\u0200;ast\u0b7b\u2b55\u2b5a\u2b5flle\xec\u0b7bl;\uc000\u2afd\u20e5;\uc000\u2202\u0338lint;\u6a14\u0180;ce\u0c92\u2b70\u2b73u\xe5\u0ca5\u0100;c\u0c98\u2b78\u0100;e\u0c92\u2b7d\xf1\u0c98\u0200Aait\u2b88\u2b8b\u2b9d\u2ba7r\xf2\u2988rr\u0180;cw\u2b94\u2b95\u2b99\u619b;\uc000\u2933\u0338;\uc000\u219d\u0338ghtarrow\xbb\u2b95ri\u0100;e\u0ccb\u0cd6\u0380chimpqu\u2bbd\u2bcd\u2bd9\u2b04\u0b78\u2be4\u2bef\u0200;cer\u0d32\u2bc6\u0d37\u2bc9u\xe5\u0d45;\uc000\ud835\udcc3ort\u026d\u2b05\0\0\u2bd6ar\xe1\u2b56m\u0100;e\u0d6e\u2bdf\u0100;q\u0d74\u0d73su\u0100bp\u2beb\u2bed\xe5\u0cf8\xe5\u0d0b\u0180bcp\u2bf6\u2c11\u2c19\u0200;Ees\u2bff\u2c00\u0d22\u2c04\u6284;\uc000\u2ac5\u0338et\u0100;e\u0d1b\u2c0bq\u0100;q\u0d23\u2c00c\u0100;e\u0d32\u2c17\xf1\u0d38\u0200;Ees\u2c22\u2c23\u0d5f\u2c27\u6285;\uc000\u2ac6\u0338et\u0100;e\u0d58\u2c2eq\u0100;q\u0d60\u2c23\u0200gilr\u2c3d\u2c3f\u2c45\u2c47\xec\u0bd7lde\u803b\xf1\u40f1\xe7\u0c43iangle\u0100lr\u2c52\u2c5ceft\u0100;e\u0c1a\u2c5a\xf1\u0c26ight\u0100;e\u0ccb\u2c65\xf1\u0cd7\u0100;m\u2c6c\u2c6d\u43bd\u0180;es\u2c74\u2c75\u2c79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2c8f\u2c94\u2c99\u2c9e\u2ca3\u2cb0\u2cb6\u2cd3\u2ce3ash;\u62adarr;\u6904p;\uc000\u224d\u20d2ash;\u62ac\u0100et\u2ca8\u2cac;\uc000\u2265\u20d2;\uc000>\u20d2nfin;\u69de\u0180Aet\u2cbd\u2cc1\u2cc5rr;\u6902;\uc000\u2264\u20d2\u0100;r\u2cca\u2ccd\uc000<\u20d2ie;\uc000\u22b4\u20d2\u0100At\u2cd8\u2cdcrr;\u6903rie;\uc000\u22b5\u20d2im;\uc000\u223c\u20d2\u0180Aan\u2cf0\u2cf4\u2d02rr;\u61d6r\u0100hr\u2cfa\u2cfdk;\u6923\u0100;o\u13e7\u13e5ear;\u6927\u1253\u1a95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2d2d\0\u2d38\u2d48\u2d60\u2d65\u2d72\u2d84\u1b07\0\0\u2d8d\u2dab\0\u2dc8\u2dce\0\u2ddc\u2e19\u2e2b\u2e3e\u2e43\u0100cs\u2d31\u1a97ute\u803b\xf3\u40f3\u0100iy\u2d3c\u2d45r\u0100;c\u1a9e\u2d42\u803b\xf4\u40f4;\u443e\u0280abios\u1aa0\u2d52\u2d57\u01c8\u2d5alac;\u4151v;\u6a38old;\u69bclig;\u4153\u0100cr\u2d69\u2d6dir;\u69bf;\uc000\ud835\udd2c\u036f\u2d79\0\0\u2d7c\0\u2d82n;\u42dbave\u803b\xf2\u40f2;\u69c1\u0100bm\u2d88\u0df4ar;\u69b5\u0200acit\u2d95\u2d98\u2da5\u2da8r\xf2\u1a80\u0100ir\u2d9d\u2da0r;\u69beoss;\u69bbn\xe5\u0e52;\u69c0\u0180aei\u2db1\u2db5\u2db9cr;\u414dga;\u43c9\u0180cdn\u2dc0\u2dc5\u01cdron;\u43bf;\u69b6pf;\uc000\ud835\udd60\u0180ael\u2dd4\u2dd7\u01d2r;\u69b7rp;\u69b9\u0380;adiosv\u2dea\u2deb\u2dee\u2e08\u2e0d\u2e10\u2e16\u6228r\xf2\u1a86\u0200;efm\u2df7\u2df8\u2e02\u2e05\u6a5dr\u0100;o\u2dfe\u2dff\u6134f\xbb\u2dff\u803b\xaa\u40aa\u803b\xba\u40bagof;\u62b6r;\u6a56lope;\u6a57;\u6a5b\u0180clo\u2e1f\u2e21\u2e27\xf2\u2e01ash\u803b\xf8\u40f8l;\u6298i\u016c\u2e2f\u2e34de\u803b\xf5\u40f5es\u0100;a\u01db\u2e3as;\u6a36ml\u803b\xf6\u40f6bar;\u633d\u0ae1\u2e5e\0\u2e7d\0\u2e80\u2e9d\0\u2ea2\u2eb9\0\0\u2ecb\u0e9c\0\u2f13\0\0\u2f2b\u2fbc\0\u2fc8r\u0200;ast\u0403\u2e67\u2e72\u0e85\u8100\xb6;l\u2e6d\u2e6e\u40b6le\xec\u0403\u0269\u2e78\0\0\u2e7bm;\u6af3;\u6afdy;\u443fr\u0280cimpt\u2e8b\u2e8f\u2e93\u1865\u2e97nt;\u4025od;\u402eil;\u6030enk;\u6031r;\uc000\ud835\udd2d\u0180imo\u2ea8\u2eb0\u2eb4\u0100;v\u2ead\u2eae\u43c6;\u43d5ma\xf4\u0a76ne;\u660e\u0180;tv\u2ebf\u2ec0\u2ec8\u43c0chfork\xbb\u1ffd;\u43d6\u0100au\u2ecf\u2edfn\u0100ck\u2ed5\u2eddk\u0100;h\u21f4\u2edb;\u610e\xf6\u21f4s\u0480;abcdemst\u2ef3\u2ef4\u1908\u2ef9\u2efd\u2f04\u2f06\u2f0a\u2f0e\u402bcir;\u6a23ir;\u6a22\u0100ou\u1d40\u2f02;\u6a25;\u6a72n\u80bb\xb1\u0e9dim;\u6a26wo;\u6a27\u0180ipu\u2f19\u2f20\u2f25ntint;\u6a15f;\uc000\ud835\udd61nd\u803b\xa3\u40a3\u0500;Eaceinosu\u0ec8\u2f3f\u2f41\u2f44\u2f47\u2f81\u2f89\u2f92\u2f7e\u2fb6;\u6ab3p;\u6ab7u\xe5\u0ed9\u0100;c\u0ece\u2f4c\u0300;acens\u0ec8\u2f59\u2f5f\u2f66\u2f68\u2f7eppro\xf8\u2f43urlye\xf1\u0ed9\xf1\u0ece\u0180aes\u2f6f\u2f76\u2f7approx;\u6ab9qq;\u6ab5im;\u62e8i\xed\u0edfme\u0100;s\u2f88\u0eae\u6032\u0180Eas\u2f78\u2f90\u2f7a\xf0\u2f75\u0180dfp\u0eec\u2f99\u2faf\u0180als\u2fa0\u2fa5\u2faalar;\u632eine;\u6312urf;\u6313\u0100;t\u0efb\u2fb4\xef\u0efbrel;\u62b0\u0100ci\u2fc0\u2fc5r;\uc000\ud835\udcc5;\u43c8ncsp;\u6008\u0300fiopsu\u2fda\u22e2\u2fdf\u2fe5\u2feb\u2ff1r;\uc000\ud835\udd2epf;\uc000\ud835\udd62rime;\u6057cr;\uc000\ud835\udcc6\u0180aeo\u2ff8\u3009\u3013t\u0100ei\u2ffe\u3005rnion\xf3\u06b0nt;\u6a16st\u0100;e\u3010\u3011\u403f\xf1\u1f19\xf4\u0f14\u0a80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30e0\u310e\u312b\u3147\u3162\u3172\u318e\u3206\u3215\u3224\u3229\u3258\u326e\u3272\u3290\u32b0\u32b7\u0180art\u3047\u304a\u304cr\xf2\u10b3\xf2\u03ddail;\u691car\xf2\u1c65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307f\u308f\u3094\u30cc\u0100eu\u306d\u3071;\uc000\u223d\u0331te;\u4155i\xe3\u116emptyv;\u69b3g\u0200;del\u0fd1\u3089\u308b\u308d;\u6992;\u69a5\xe5\u0fd1uo\u803b\xbb\u40bbr\u0580;abcfhlpstw\u0fdc\u30ac\u30af\u30b7\u30b9\u30bc\u30be\u30c0\u30c3\u30c7\u30cap;\u6975\u0100;f\u0fe0\u30b4s;\u6920;\u6933s;\u691e\xeb\u225d\xf0\u272el;\u6945im;\u6974l;\u61a3;\u619d\u0100ai\u30d1\u30d5il;\u691ao\u0100;n\u30db\u30dc\u6236al\xf3\u0f1e\u0180abr\u30e7\u30ea\u30eer\xf2\u17e5rk;\u6773\u0100ak\u30f3\u30fdc\u0100ek\u30f9\u30fb;\u407d;\u405d\u0100es\u3102\u3104;\u698cl\u0100du\u310a\u310c;\u698e;\u6990\u0200aeuy\u3117\u311c\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xec\u0ff2\xe2\u30fa;\u4440\u0200clqs\u3134\u3137\u313d\u3144a;\u6937dhar;\u6969uo\u0100;r\u020e\u020dh;\u61b3\u0180acg\u314e\u315f\u0f44l\u0200;ips\u0f78\u3158\u315b\u109cn\xe5\u10bbar\xf4\u0fa9t;\u65ad\u0180ilr\u3169\u1023\u316esht;\u697d;\uc000\ud835\udd2f\u0100ao\u3177\u3186r\u0100du\u317d\u317f\xbb\u047b\u0100;l\u1091\u3184;\u696c\u0100;v\u318b\u318c\u43c1;\u43f1\u0180gns\u3195\u31f9\u31fcht\u0300ahlrst\u31a4\u31b0\u31c2\u31d8\u31e4\u31eerrow\u0100;t\u0fdc\u31ada\xe9\u30c8arpoon\u0100du\u31bb\u31bfow\xee\u317ep\xbb\u1092eft\u0100ah\u31ca\u31d0rrow\xf3\u0feaarpoon\xf3\u0551ightarrows;\u61c9quigarro\xf7\u30cbhreetimes;\u62ccg;\u42daingdotse\xf1\u1f32\u0180ahm\u320d\u3210\u3213r\xf2\u0feaa\xf2\u0551;\u600foust\u0100;a\u321e\u321f\u63b1che\xbb\u321fmid;\u6aee\u0200abpt\u3232\u323d\u3240\u3252\u0100nr\u3237\u323ag;\u67edr;\u61fer\xeb\u1003\u0180afl\u3247\u324a\u324er;\u6986;\uc000\ud835\udd63us;\u6a2eimes;\u6a35\u0100ap\u325d\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6a12ar\xf2\u31e3\u0200achq\u327b\u3280\u10bc\u3285quo;\u603ar;\uc000\ud835\udcc7\u0100bu\u30fb\u328ao\u0100;r\u0214\u0213\u0180hir\u3297\u329b\u32a0re\xe5\u31f8mes;\u62cai\u0200;efl\u32aa\u1059\u1821\u32ab\u65b9tri;\u69celuhar;\u6968;\u611e\u0d61\u32d5\u32db\u32df\u332c\u3338\u3371\0\u337a\u33a4\0\0\u33ec\u33f0\0\u3428\u3448\u345a\u34ad\u34b1\u34ca\u34f1\0\u3616\0\0\u3633cute;\u415bqu\xef\u27ba\u0500;Eaceinpsy\u11ed\u32f3\u32f5\u32ff\u3302\u330b\u330f\u331f\u3326\u3329;\u6ab4\u01f0\u32fa\0\u32fc;\u6ab8on;\u4161u\xe5\u11fe\u0100;d\u11f3\u3307il;\u415frc;\u415d\u0180Eas\u3316\u3318\u331b;\u6ab6p;\u6abaim;\u62e9olint;\u6a13i\xed\u1204;\u4441ot\u0180;be\u3334\u1d47\u3335\u62c5;\u6a66\u0380Aacmstx\u3346\u334a\u3357\u335b\u335e\u3363\u336drr;\u61d8r\u0100hr\u3350\u3352\xeb\u2228\u0100;o\u0a36\u0a34t\u803b\xa7\u40a7i;\u403bwar;\u6929m\u0100in\u3369\xf0nu\xf3\xf1t;\u6736r\u0100;o\u3376\u2055\uc000\ud835\udd30\u0200acoy\u3382\u3386\u3391\u33a0rp;\u666f\u0100hy\u338b\u338fcy;\u4449;\u4448rt\u026d\u3399\0\0\u339ci\xe4\u1464ara\xec\u2e6f\u803b\xad\u40ad\u0100gm\u33a8\u33b4ma\u0180;fv\u33b1\u33b2\u33b2\u43c3;\u43c2\u0400;deglnpr\u12ab\u33c5\u33c9\u33ce\u33d6\u33de\u33e1\u33e6ot;\u6a6a\u0100;q\u12b1\u12b0\u0100;E\u33d3\u33d4\u6a9e;\u6aa0\u0100;E\u33db\u33dc\u6a9d;\u6a9fe;\u6246lus;\u6a24arr;\u6972ar\xf2\u113d\u0200aeit\u33f8\u3408\u340f\u3417\u0100ls\u33fd\u3404lsetm\xe9\u336ahp;\u6a33parsl;\u69e4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341c\u341d\u6aaa\u0100;s\u3422\u3423\u6aac;\uc000\u2aac\ufe00\u0180flp\u342e\u3433\u3442tcy;\u444c\u0100;b\u3438\u3439\u402f\u0100;a\u343e\u343f\u69c4r;\u633ff;\uc000\ud835\udd64a\u0100dr\u344d\u0402es\u0100;u\u3454\u3455\u6660it\xbb\u3455\u0180csu\u3460\u3479\u349f\u0100au\u3465\u346fp\u0100;s\u1188\u346b;\uc000\u2293\ufe00p\u0100;s\u11b4\u3475;\uc000\u2294\ufe00u\u0100bp\u347f\u348f\u0180;es\u1197\u119c\u3486et\u0100;e\u1197\u348d\xf1\u119d\u0180;es\u11a8\u11ad\u3496et\u0100;e\u11a8\u349d\xf1\u11ae\u0180;af\u117b\u34a6\u05b0r\u0165\u34ab\u05b1\xbb\u117car\xf2\u1148\u0200cemt\u34b9\u34be\u34c2\u34c5r;\uc000\ud835\udcc8tm\xee\xf1i\xec\u3415ar\xe6\u11be\u0100ar\u34ce\u34d5r\u0100;f\u34d4\u17bf\u6606\u0100an\u34da\u34edight\u0100ep\u34e3\u34eapsilo\xee\u1ee0h\xe9\u2eafs\xbb\u2852\u0280bcmnp\u34fb\u355e\u1209\u358b\u358e\u0480;Edemnprs\u350e\u350f\u3511\u3515\u351e\u3523\u352c\u3531\u3536\u6282;\u6ac5ot;\u6abd\u0100;d\u11da\u351aot;\u6ac3ult;\u6ac1\u0100Ee\u3528\u352a;\u6acb;\u628alus;\u6abfarr;\u6979\u0180eiu\u353d\u3552\u3555t\u0180;en\u350e\u3545\u354bq\u0100;q\u11da\u350feq\u0100;q\u352b\u3528m;\u6ac7\u0100bp\u355a\u355c;\u6ad5;\u6ad3c\u0300;acens\u11ed\u356c\u3572\u3579\u357b\u3326ppro\xf8\u32faurlye\xf1\u11fe\xf1\u11f3\u0180aes\u3582\u3588\u331bppro\xf8\u331aq\xf1\u3317g;\u666a\u0680123;Edehlmnps\u35a9\u35ac\u35af\u121c\u35b2\u35b4\u35c0\u35c9\u35d5\u35da\u35df\u35e8\u35ed\u803b\xb9\u40b9\u803b\xb2\u40b2\u803b\xb3\u40b3;\u6ac6\u0100os\u35b9\u35bct;\u6abeub;\u6ad8\u0100;d\u1222\u35c5ot;\u6ac4s\u0100ou\u35cf\u35d2l;\u67c9b;\u6ad7arr;\u697bult;\u6ac2\u0100Ee\u35e4\u35e6;\u6acc;\u628blus;\u6ac0\u0180eiu\u35f4\u3609\u360ct\u0180;en\u121c\u35fc\u3602q\u0100;q\u1222\u35b2eq\u0100;q\u35e7\u35e4m;\u6ac8\u0100bp\u3611\u3613;\u6ad4;\u6ad6\u0180Aan\u361c\u3620\u362drr;\u61d9r\u0100hr\u3626\u3628\xeb\u222e\u0100;o\u0a2b\u0a29war;\u692alig\u803b\xdf\u40df\u0be1\u3651\u365d\u3660\u12ce\u3673\u3679\0\u367e\u36c2\0\0\0\0\0\u36db\u3703\0\u3709\u376c\0\0\0\u3787\u0272\u3656\0\0\u365bget;\u6316;\u43c4r\xeb\u0e5f\u0180aey\u3666\u366b\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uc000\ud835\udd31\u0200eiko\u3686\u369d\u36b5\u36bc\u01f2\u368b\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369b\u43b8ym;\u43d1\u0100cn\u36a2\u36b2k\u0100as\u36a8\u36aeppro\xf8\u12c1im\xbb\u12acs\xf0\u129e\u0100as\u36ba\u36ae\xf0\u12c1rn\u803b\xfe\u40fe\u01ec\u031f\u36c6\u22e7es\u8180\xd7;bd\u36cf\u36d0\u36d8\u40d7\u0100;a\u190f\u36d5r;\u6a31;\u6a30\u0180eps\u36e1\u36e3\u3700\xe1\u2a4d\u0200;bcf\u0486\u36ec\u36f0\u36f4ot;\u6336ir;\u6af1\u0100;o\u36f9\u36fc\uc000\ud835\udd65rk;\u6ada\xe1\u3362rime;\u6034\u0180aip\u370f\u3712\u3764d\xe5\u1248\u0380adempst\u3721\u374d\u3740\u3751\u3757\u375c\u375fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65b5own\xbb\u1dbbeft\u0100;e\u2800\u373e\xf1\u092e;\u625cight\u0100;e\u32aa\u374b\xf1\u105aot;\u65ecinus;\u6a3alus;\u6a39b;\u69cdime;\u6a3bezium;\u63e2\u0180cht\u3772\u377d\u3781\u0100ry\u3777\u377b;\uc000\ud835\udcc9;\u4446cy;\u445brok;\u4167\u0100io\u378b\u378ex\xf4\u1777head\u0100lr\u3797\u37a0eftarro\xf7\u084fightarrow\xbb\u0f5d\u0900AHabcdfghlmoprstuw\u37d0\u37d3\u37d7\u37e4\u37f0\u37fc\u380e\u381c\u3823\u3834\u3851\u385d\u386b\u38a9\u38cc\u38d2\u38ea\u38f6r\xf2\u03edar;\u6963\u0100cr\u37dc\u37e2ute\u803b\xfa\u40fa\xf2\u1150r\u01e3\u37ea\0\u37edy;\u445eve;\u416d\u0100iy\u37f5\u37farc\u803b\xfb\u40fb;\u4443\u0180abh\u3803\u3806\u380br\xf2\u13adlac;\u4171a\xf2\u13c3\u0100ir\u3813\u3818sht;\u697e;\uc000\ud835\udd32rave\u803b\xf9\u40f9\u0161\u3827\u3831r\u0100lr\u382c\u382e\xbb\u0957\xbb\u1083lk;\u6580\u0100ct\u3839\u384d\u026f\u383f\0\0\u384arn\u0100;e\u3845\u3846\u631cr\xbb\u3846op;\u630fri;\u65f8\u0100al\u3856\u385acr;\u416b\u80bb\xa8\u0349\u0100gp\u3862\u3866on;\u4173f;\uc000\ud835\udd66\u0300adhlsu\u114b\u3878\u387d\u1372\u3891\u38a0own\xe1\u13b3arpoon\u0100lr\u3888\u388cef\xf4\u382digh\xf4\u382fi\u0180;hl\u3899\u389a\u389c\u43c5\xbb\u13faon\xbb\u389aparrows;\u61c8\u0180cit\u38b0\u38c4\u38c8\u026f\u38b6\0\0\u38c1rn\u0100;e\u38bc\u38bd\u631dr\xbb\u38bdop;\u630eng;\u416fri;\u65f9cr;\uc000\ud835\udcca\u0180dir\u38d9\u38dd\u38e2ot;\u62f0lde;\u4169i\u0100;f\u3730\u38e8\xbb\u1813\u0100am\u38ef\u38f2r\xf2\u38a8l\u803b\xfc\u40fcangle;\u69a7\u0780ABDacdeflnoprsz\u391c\u391f\u3929\u392d\u39b5\u39b8\u39bd\u39df\u39e4\u39e8\u39f3\u39f9\u39fd\u3a01\u3a20r\xf2\u03f7ar\u0100;v\u3926\u3927\u6ae8;\u6ae9as\xe8\u03e1\u0100nr\u3932\u3937grt;\u699c\u0380eknprst\u34e3\u3946\u394b\u3952\u395d\u3964\u3996app\xe1\u2415othin\xe7\u1e96\u0180hir\u34eb\u2ec8\u3959op\xf4\u2fb5\u0100;h\u13b7\u3962\xef\u318d\u0100iu\u3969\u396dgm\xe1\u33b3\u0100bp\u3972\u3984setneq\u0100;q\u397d\u3980\uc000\u228a\ufe00;\uc000\u2acb\ufe00setneq\u0100;q\u398f\u3992\uc000\u228b\ufe00;\uc000\u2acc\ufe00\u0100hr\u399b\u399fet\xe1\u369ciangle\u0100lr\u39aa\u39afeft\xbb\u0925ight\xbb\u1051y;\u4432ash\xbb\u1036\u0180elr\u39c4\u39d2\u39d7\u0180;be\u2dea\u39cb\u39cfar;\u62bbq;\u625alip;\u62ee\u0100bt\u39dc\u1468a\xf2\u1469r;\uc000\ud835\udd33tr\xe9\u39aesu\u0100bp\u39ef\u39f1\xbb\u0d1c\xbb\u0d59pf;\uc000\ud835\udd67ro\xf0\u0efbtr\xe9\u39b4\u0100cu\u3a06\u3a0br;\uc000\ud835\udccb\u0100bp\u3a10\u3a18n\u0100Ee\u3980\u3a16\xbb\u397en\u0100Ee\u3992\u3a1e\xbb\u3990igzag;\u699a\u0380cefoprs\u3a36\u3a3b\u3a56\u3a5b\u3a54\u3a61\u3a6airc;\u4175\u0100di\u3a40\u3a51\u0100bg\u3a45\u3a49ar;\u6a5fe\u0100;q\u15fa\u3a4f;\u6259erp;\u6118r;\uc000\ud835\udd34pf;\uc000\ud835\udd68\u0100;e\u1479\u3a66at\xe8\u1479cr;\uc000\ud835\udccc\u0ae3\u178e\u3a87\0\u3a8b\0\u3a90\u3a9b\0\0\u3a9d\u3aa8\u3aab\u3aaf\0\0\u3ac3\u3ace\0\u3ad8\u17dc\u17dftr\xe9\u17d1r;\uc000\ud835\udd35\u0100Aa\u3a94\u3a97r\xf2\u03c3r\xf2\u09f6;\u43be\u0100Aa\u3aa1\u3aa4r\xf2\u03b8r\xf2\u09eba\xf0\u2713is;\u62fb\u0180dpt\u17a4\u3ab5\u3abe\u0100fl\u3aba\u17a9;\uc000\ud835\udd69im\xe5\u17b2\u0100Aa\u3ac7\u3acar\xf2\u03cer\xf2\u0a01\u0100cq\u3ad2\u17b8r;\uc000\ud835\udccd\u0100pt\u17d6\u3adcr\xe9\u17d4\u0400acefiosu\u3af0\u3afd\u3b08\u3b0c\u3b11\u3b15\u3b1b\u3b21c\u0100uy\u3af6\u3afbte\u803b\xfd\u40fd;\u444f\u0100iy\u3b02\u3b06rc;\u4177;\u444bn\u803b\xa5\u40a5r;\uc000\ud835\udd36cy;\u4457pf;\uc000\ud835\udd6acr;\uc000\ud835\udcce\u0100cm\u3b26\u3b29y;\u444el\u803b\xff\u40ff\u0500acdefhiosw\u3b42\u3b48\u3b54\u3b58\u3b64\u3b69\u3b6d\u3b74\u3b7a\u3b80cute;\u417a\u0100ay\u3b4d\u3b52ron;\u417e;\u4437ot;\u417c\u0100et\u3b5d\u3b61tr\xe6\u155fa;\u43b6r;\uc000\ud835\udd37cy;\u4436grarr;\u61ddpf;\uc000\ud835\udd6bcr;\uc000\ud835\udccf\u0100jn\u3b85\u3b87;\u600dj;\u600c"
        .split("")
        .map((c) => c.charCodeAt(0)));

    // Generated using scripts/write-decode-map.ts
    var xmlDecodeTree = new Uint16Array(
    // prettier-ignore
    "\u0200aglq\t\x15\x18\x1b\u026d\x0f\0\0\x12p;\u4026os;\u4027t;\u403et;\u403cuot;\u4022"
        .split("")
        .map((c) => c.charCodeAt(0)));

    // Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134
    var _a;
    const decodeMap = new Map([
        [0, 65533],
        [128, 8364],
        [130, 8218],
        [131, 402],
        [132, 8222],
        [133, 8230],
        [134, 8224],
        [135, 8225],
        [136, 710],
        [137, 8240],
        [138, 352],
        [139, 8249],
        [140, 338],
        [142, 381],
        [145, 8216],
        [146, 8217],
        [147, 8220],
        [148, 8221],
        [149, 8226],
        [150, 8211],
        [151, 8212],
        [152, 732],
        [153, 8482],
        [154, 353],
        [155, 8250],
        [156, 339],
        [158, 382],
        [159, 376],
    ]);
    const fromCodePoint = 
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {
        let output = "";
        if (codePoint > 0xffff) {
            codePoint -= 0x10000;
            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
            codePoint = 0xdc00 | (codePoint & 0x3ff);
        }
        output += String.fromCharCode(codePoint);
        return output;
    };
    function replaceCodePoint(codePoint) {
        var _a;
        if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
            return 0xfffd;
        }
        return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;
    }

    var CharCodes$1;
    (function (CharCodes) {
        CharCodes[CharCodes["NUM"] = 35] = "NUM";
        CharCodes[CharCodes["SEMI"] = 59] = "SEMI";
        CharCodes[CharCodes["ZERO"] = 48] = "ZERO";
        CharCodes[CharCodes["NINE"] = 57] = "NINE";
        CharCodes[CharCodes["LOWER_A"] = 97] = "LOWER_A";
        CharCodes[CharCodes["LOWER_F"] = 102] = "LOWER_F";
        CharCodes[CharCodes["LOWER_X"] = 120] = "LOWER_X";
        /** Bit that needs to be set to convert an upper case ASCII character to lower case */
        CharCodes[CharCodes["To_LOWER_BIT"] = 32] = "To_LOWER_BIT";
    })(CharCodes$1 || (CharCodes$1 = {}));
    var BinTrieFlags;
    (function (BinTrieFlags) {
        BinTrieFlags[BinTrieFlags["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
        BinTrieFlags[BinTrieFlags["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
        BinTrieFlags[BinTrieFlags["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags || (BinTrieFlags = {}));
    function determineBranch(decodeTree, current, nodeIdx, char) {
        const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
        const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
        // Case 1: Single branch encoded in jump offset
        if (branchCount === 0) {
            return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
        }
        // Case 2: Multiple branches encoded in jump table
        if (jumpOffset) {
            const value = char - jumpOffset;
            return value < 0 || value >= branchCount
                ? -1
                : decodeTree[nodeIdx + value] - 1;
        }
        // Case 3: Multiple branches encoded in dictionary
        // Binary search for the character.
        let lo = nodeIdx;
        let hi = lo + branchCount - 1;
        while (lo <= hi) {
            const mid = (lo + hi) >>> 1;
            const midVal = decodeTree[mid];
            if (midVal < char) {
                lo = mid + 1;
            }
            else if (midVal > char) {
                hi = mid - 1;
            }
            else {
                return decodeTree[mid + branchCount];
            }
        }
        return -1;
    }

    const xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    const xmlCodeMap = new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [39, "&apos;"],
        [60, "&lt;"],
        [62, "&gt;"],
    ]);
    // For compatibility with node < 4, we wrap `codePointAt`
    const getCodePoint = 
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null
        ? (str, index) => str.codePointAt(index)
        : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            (c, index) => (c.charCodeAt(index) & 0xfc00) === 0xd800
                ? (c.charCodeAt(index) - 0xd800) * 0x400 +
                    c.charCodeAt(index + 1) -
                    0xdc00 +
                    0x10000
                : c.charCodeAt(index);
    /**
     * Encodes all non-ASCII characters, as well as characters not valid in XML
     * documents using XML entities.
     *
     * If a character has no equivalent entity, a
     * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
     */
    function encodeXML(str) {
        let ret = "";
        let lastIdx = 0;
        let match;
        while ((match = xmlReplacer.exec(str)) !== null) {
            const i = match.index;
            const char = str.charCodeAt(i);
            const next = xmlCodeMap.get(char);
            if (next !== undefined) {
                ret += str.substring(lastIdx, i) + next;
                lastIdx = i + 1;
            }
            else {
                ret += `${str.substring(lastIdx, i)}&#x${getCodePoint(str, i).toString(16)};`;
                // Increase by 1 if we have a surrogate pair
                lastIdx = xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);
            }
        }
        return ret + str.substr(lastIdx);
    }
    function getEscaper(regex, map) {
        return function escape(data) {
            let match;
            let lastIdx = 0;
            let result = "";
            while ((match = regex.exec(data))) {
                if (lastIdx !== match.index) {
                    result += data.substring(lastIdx, match.index);
                }
                // We know that this chararcter will be in the map.
                result += map.get(match[0].charCodeAt(0));
                // Every match will be of length 1
                lastIdx = match.index + 1;
            }
            return result + data.substring(lastIdx);
        };
    }
    /**
     * Encodes all characters that have to be escaped in HTML attributes,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     *
     * @param data String to escape.
     */
    const escapeAttribute = getEscaper(/["&\u00A0]/g, new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [160, "&nbsp;"],
    ]));
    /**
     * Encodes all characters that have to be escaped in HTML text,
     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.
     *
     * @param data String to escape.
     */
    const escapeText = getEscaper(/[&<>\u00A0]/g, new Map([
        [38, "&amp;"],
        [60, "&lt;"],
        [62, "&gt;"],
        [160, "&nbsp;"],
    ]));

    const elementNames = new Map([
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "clipPath",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "foreignObject",
        "glyphRef",
        "linearGradient",
        "radialGradient",
        "textPath",
    ].map((val) => [val.toLowerCase(), val]));
    const attributeNames = new Map([
        "definitionURL",
        "attributeName",
        "attributeType",
        "baseFrequency",
        "baseProfile",
        "calcMode",
        "clipPathUnits",
        "diffuseConstant",
        "edgeMode",
        "filterUnits",
        "glyphRef",
        "gradientTransform",
        "gradientUnits",
        "kernelMatrix",
        "kernelUnitLength",
        "keyPoints",
        "keySplines",
        "keyTimes",
        "lengthAdjust",
        "limitingConeAngle",
        "markerHeight",
        "markerUnits",
        "markerWidth",
        "maskContentUnits",
        "maskUnits",
        "numOctaves",
        "pathLength",
        "patternContentUnits",
        "patternTransform",
        "patternUnits",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "preserveAlpha",
        "preserveAspectRatio",
        "primitiveUnits",
        "refX",
        "refY",
        "repeatCount",
        "repeatDur",
        "requiredExtensions",
        "requiredFeatures",
        "specularConstant",
        "specularExponent",
        "spreadMethod",
        "startOffset",
        "stdDeviation",
        "stitchTiles",
        "surfaceScale",
        "systemLanguage",
        "tableValues",
        "targetX",
        "targetY",
        "textLength",
        "viewBox",
        "viewTarget",
        "xChannelSelector",
        "yChannelSelector",
        "zoomAndPan",
    ].map((val) => [val.toLowerCase(), val]));

    /*
     * Module dependencies
     */
    const unencodedElements = new Set([
        "style",
        "script",
        "xmp",
        "iframe",
        "noembed",
        "noframes",
        "plaintext",
        "noscript",
    ]);
    function replaceQuotes(value) {
        return value.replace(/"/g, "&quot;");
    }
    /**
     * Format attributes
     */
    function formatAttributes(attributes, opts) {
        var _a;
        if (!attributes)
            return;
        const encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false
            ? replaceQuotes
            : opts.xmlMode || opts.encodeEntities !== "utf8"
                ? encodeXML
                : escapeAttribute;
        return Object.keys(attributes)
            .map((key) => {
            var _a, _b;
            const value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
            if (opts.xmlMode === "foreign") {
                /* Fix up mixed-case attribute names */
                key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
            }
            if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
                return key;
            }
            return `${key}="${encode(value)}"`;
        })
            .join(" ");
    }
    /**
     * Self-enclosing tags
     */
    const singleTag = new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr",
    ]);
    /**
     * Renders a DOM node or an array of DOM nodes to a string.
     *
     * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
     *
     * @param node Node to be rendered.
     * @param options Changes serialization behavior
     */
    function render$1(node, options = {}) {
        const nodes = "length" in node ? node : [node];
        let output = "";
        for (let i = 0; i < nodes.length; i++) {
            output += renderNode(nodes[i], options);
        }
        return output;
    }
    function renderNode(node, options) {
        switch (node.type) {
            case Root:
                return render$1(node.children, options);
            // @ts-expect-error We don't use `Doctype` yet
            case Doctype:
            case Directive:
                return renderDirective(node);
            case Comment$1:
                return renderComment(node);
            case CDATA$1:
                return renderCdata(node);
            case Script:
            case Style:
            case Tag:
                return renderTag(node, options);
            case Text$1:
                return renderText(node, options);
        }
    }
    const foreignModeIntegrationPoints = new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title",
    ]);
    const foreignElements = new Set(["svg", "math"]);
    function renderTag(elem, opts) {
        var _a;
        // Handle SVG / MathML in HTML
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case element names */
            elem.name = (_a = elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
            /* Exit foreign mode at integration points */
            if (elem.parent &&
                foreignModeIntegrationPoints.has(elem.parent.name)) {
                opts = { ...opts, xmlMode: false };
            }
        }
        if (!opts.xmlMode && foreignElements.has(elem.name)) {
            opts = { ...opts, xmlMode: "foreign" };
        }
        let tag = `<${elem.name}`;
        const attribs = formatAttributes(elem.attribs, opts);
        if (attribs) {
            tag += ` ${attribs}`;
        }
        if (elem.children.length === 0 &&
            (opts.xmlMode
                ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                    opts.selfClosingTags !== false
                : // User explicitly asked for self-closing tags, even in HTML mode
                    opts.selfClosingTags && singleTag.has(elem.name))) {
            if (!opts.xmlMode)
                tag += " ";
            tag += "/>";
        }
        else {
            tag += ">";
            if (elem.children.length > 0) {
                tag += render$1(elem.children, opts);
            }
            if (opts.xmlMode || !singleTag.has(elem.name)) {
                tag += `</${elem.name}>`;
            }
        }
        return tag;
    }
    function renderDirective(elem) {
        return `<${elem.data}>`;
    }
    function renderText(elem, opts) {
        var _a;
        let data = elem.data || "";
        // If entities weren't decoded, no need to encode them back
        if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false &&
            !(!opts.xmlMode &&
                elem.parent &&
                unencodedElements.has(elem.parent.name))) {
            data =
                opts.xmlMode || opts.encodeEntities !== "utf8"
                    ? encodeXML(data)
                    : escapeText(data);
        }
        return data;
    }
    function renderCdata(elem) {
        return `<![CDATA[${elem.children[0].data}]]>`;
    }
    function renderComment(elem) {
        return `<!--${elem.data}-->`;
    }

    /**
     * @category Stringify
     * @deprecated Use the `dom-serializer` module directly.
     * @param node Node to get the outer HTML of.
     * @param options Options for serialization.
     * @returns `node`'s outer HTML.
     */
    function getOuterHTML(node, options) {
        return render$1(node, options);
    }
    /**
     * @category Stringify
     * @deprecated Use the `dom-serializer` module directly.
     * @param node Node to get the inner HTML of.
     * @param options Options for serialization.
     * @returns `node`'s inner HTML.
     */
    function getInnerHTML(node, options) {
        return hasChildren(node)
            ? node.children.map((node) => getOuterHTML(node, options)).join("")
            : "";
    }
    /**
     * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
     *
     * @category Stringify
     * @deprecated Use `textContent` instead.
     * @param node Node to get the inner text of.
     * @returns `node`'s inner text.
     */
    function getText(node) {
        if (Array.isArray(node))
            return node.map(getText).join("");
        if (isTag(node))
            return node.name === "br" ? "\n" : getText(node.children);
        if (isCDATA(node))
            return getText(node.children);
        if (isText(node))
            return node.data;
        return "";
    }
    /**
     * Get a node's text content.
     *
     * @category Stringify
     * @param node Node to get the text content of.
     * @returns `node`'s text content.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
     */
    function textContent(node) {
        if (Array.isArray(node))
            return node.map(textContent).join("");
        if (hasChildren(node) && !isComment(node)) {
            return textContent(node.children);
        }
        if (isText(node))
            return node.data;
        return "";
    }
    /**
     * Get a node's inner text.
     *
     * @category Stringify
     * @param node Node to get the inner text of.
     * @returns `node`'s inner text.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
     */
    function innerText(node) {
        if (Array.isArray(node))
            return node.map(innerText).join("");
        if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
            return innerText(node.children);
        }
        if (isText(node))
            return node.data;
        return "";
    }

    /**
     * Get a node's children.
     *
     * @category Traversal
     * @param elem Node to get the children of.
     * @returns `elem`'s children, or an empty array.
     */
    function getChildren(elem) {
        return hasChildren(elem) ? elem.children : [];
    }
    /**
     * Get a node's parent.
     *
     * @category Traversal
     * @param elem Node to get the parent of.
     * @returns `elem`'s parent node.
     */
    function getParent(elem) {
        return elem.parent || null;
    }
    /**
     * Gets an elements siblings, including the element itself.
     *
     * Attempts to get the children through the element's parent first. If we don't
     * have a parent (the element is a root node), we walk the element's `prev` &
     * `next` to get all remaining nodes.
     *
     * @category Traversal
     * @param elem Element to get the siblings of.
     * @returns `elem`'s siblings.
     */
    function getSiblings(elem) {
        const parent = getParent(elem);
        if (parent != null)
            return getChildren(parent);
        const siblings = [elem];
        let { prev, next } = elem;
        while (prev != null) {
            siblings.unshift(prev);
            ({ prev } = prev);
        }
        while (next != null) {
            siblings.push(next);
            ({ next } = next);
        }
        return siblings;
    }
    /**
     * Gets an attribute from an element.
     *
     * @category Traversal
     * @param elem Element to check.
     * @param name Attribute name to retrieve.
     * @returns The element's attribute value, or `undefined`.
     */
    function getAttributeValue(elem, name) {
        var _a;
        return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    /**
     * Checks whether an element has an attribute.
     *
     * @category Traversal
     * @param elem Element to check.
     * @param name Attribute name to look for.
     * @returns Returns whether `elem` has the attribute `name`.
     */
    function hasAttrib(elem, name) {
        return (elem.attribs != null &&
            Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
            elem.attribs[name] != null);
    }
    /**
     * Get the tag name of an element.
     *
     * @category Traversal
     * @param elem The element to get the name for.
     * @returns The tag name of `elem`.
     */
    function getName(elem) {
        return elem.name;
    }
    /**
     * Returns the next element sibling of a node.
     *
     * @category Traversal
     * @param elem The element to get the next sibling of.
     * @returns `elem`'s next sibling that is a tag.
     */
    function nextElementSibling(elem) {
        let { next } = elem;
        while (next !== null && !isTag(next))
            ({ next } = next);
        return next;
    }
    /**
     * Returns the previous element sibling of a node.
     *
     * @category Traversal
     * @param elem The element to get the previous sibling of.
     * @returns `elem`'s previous sibling that is a tag.
     */
    function prevElementSibling(elem) {
        let { prev } = elem;
        while (prev !== null && !isTag(prev))
            ({ prev } = prev);
        return prev;
    }

    /**
     * Remove an element from the dom
     *
     * @category Manipulation
     * @param elem The element to be removed
     */
    function removeElement(elem) {
        if (elem.prev)
            elem.prev.next = elem.next;
        if (elem.next)
            elem.next.prev = elem.prev;
        if (elem.parent) {
            const childs = elem.parent.children;
            childs.splice(childs.lastIndexOf(elem), 1);
        }
    }
    /**
     * Replace an element in the dom
     *
     * @category Manipulation
     * @param elem The element to be replaced
     * @param replacement The element to be added
     */
    function replaceElement(elem, replacement) {
        const prev = (replacement.prev = elem.prev);
        if (prev) {
            prev.next = replacement;
        }
        const next = (replacement.next = elem.next);
        if (next) {
            next.prev = replacement;
        }
        const parent = (replacement.parent = elem.parent);
        if (parent) {
            const childs = parent.children;
            childs[childs.lastIndexOf(elem)] = replacement;
            elem.parent = null;
        }
    }
    /**
     * Append a child to an element.
     *
     * @category Manipulation
     * @param elem The element to append to.
     * @param child The element to be added as a child.
     */
    function appendChild(elem, child) {
        removeElement(child);
        child.next = null;
        child.parent = elem;
        if (elem.children.push(child) > 1) {
            const sibling = elem.children[elem.children.length - 2];
            sibling.next = child;
            child.prev = sibling;
        }
        else {
            child.prev = null;
        }
    }
    /**
     * Append an element after another.
     *
     * @category Manipulation
     * @param elem The element to append after.
     * @param next The element be added.
     */
    function append$1(elem, next) {
        removeElement(next);
        const { parent } = elem;
        const currNext = elem.next;
        next.next = currNext;
        next.prev = elem;
        elem.next = next;
        next.parent = parent;
        if (currNext) {
            currNext.prev = next;
            if (parent) {
                const childs = parent.children;
                childs.splice(childs.lastIndexOf(currNext), 0, next);
            }
        }
        else if (parent) {
            parent.children.push(next);
        }
    }
    /**
     * Prepend a child to an element.
     *
     * @category Manipulation
     * @param elem The element to prepend before.
     * @param child The element to be added as a child.
     */
    function prependChild(elem, child) {
        removeElement(child);
        child.parent = elem;
        child.prev = null;
        if (elem.children.unshift(child) !== 1) {
            const sibling = elem.children[1];
            sibling.prev = child;
            child.next = sibling;
        }
        else {
            child.next = null;
        }
    }
    /**
     * Prepend an element before another.
     *
     * @category Manipulation
     * @param elem The element to prepend before.
     * @param prev The element be added.
     */
    function prepend$1(elem, prev) {
        removeElement(prev);
        const { parent } = elem;
        if (parent) {
            const childs = parent.children;
            childs.splice(childs.indexOf(elem), 0, prev);
        }
        if (elem.prev) {
            elem.prev.next = prev;
        }
        prev.parent = parent;
        prev.prev = elem.prev;
        prev.next = elem;
        elem.prev = prev;
    }

    /**
     * Search a node and its children for nodes passing a test function.
     *
     * @category Querying
     * @param test Function to test nodes on.
     * @param node Node to search. Will be included in the result set if it matches.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes passing `test`.
     */
    function filter$2(test, node, recurse = true, limit = Infinity) {
        if (!Array.isArray(node))
            node = [node];
        return find$2(test, node, recurse, limit);
    }
    /**
     * Search an array of node and its children for nodes passing a test function.
     *
     * @category Querying
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes passing `test`.
     */
    function find$2(test, nodes, recurse, limit) {
        const result = [];
        for (const elem of nodes) {
            if (test(elem)) {
                result.push(elem);
                if (--limit <= 0)
                    break;
            }
            if (recurse && hasChildren(elem) && elem.children.length > 0) {
                const children = find$2(test, elem.children, recurse, limit);
                result.push(...children);
                limit -= children.length;
                if (limit <= 0)
                    break;
            }
        }
        return result;
    }
    /**
     * Finds the first element inside of an array that matches a test function.
     *
     * @category Querying
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @returns The first node in the array that passes `test`.
     * @deprecated Use `Array.prototype.find` directly.
     */
    function findOneChild(test, nodes) {
        return nodes.find(test);
    }
    /**
     * Finds one element in a tree that passes a test.
     *
     * @category Querying
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @param recurse Also consider child nodes.
     * @returns The first child node that passes `test`.
     */
    function findOne(test, nodes, recurse = true) {
        let elem = null;
        for (let i = 0; i < nodes.length && !elem; i++) {
            const checked = nodes[i];
            if (!isTag(checked)) {
                continue;
            }
            else if (test(checked)) {
                elem = checked;
            }
            else if (recurse && checked.children.length > 0) {
                elem = findOne(test, checked.children, true);
            }
        }
        return elem;
    }
    /**
     * @category Querying
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @returns Whether a tree of nodes contains at least one node passing the test.
     */
    function existsOne(test, nodes) {
        return nodes.some((checked) => isTag(checked) &&
            (test(checked) ||
                (checked.children.length > 0 &&
                    existsOne(test, checked.children))));
    }
    /**
     * Search and array of nodes and its children for elements passing a test function.
     *
     * Same as `find`, but limited to elements and with less options, leading to reduced complexity.
     *
     * @category Querying
     * @param test Function to test nodes on.
     * @param nodes Array of nodes to search.
     * @returns All nodes passing `test`.
     */
    function findAll(test, nodes) {
        var _a;
        const result = [];
        const stack = nodes.filter(isTag);
        let elem;
        while ((elem = stack.shift())) {
            const children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(isTag);
            if (children && children.length > 0) {
                stack.unshift(...children);
            }
            if (test(elem))
                result.push(elem);
        }
        return result;
    }

    const Checks = {
        tag_name(name) {
            if (typeof name === "function") {
                return (elem) => isTag(elem) && name(elem.name);
            }
            else if (name === "*") {
                return isTag;
            }
            return (elem) => isTag(elem) && elem.name === name;
        },
        tag_type(type) {
            if (typeof type === "function") {
                return (elem) => type(elem.type);
            }
            return (elem) => elem.type === type;
        },
        tag_contains(data) {
            if (typeof data === "function") {
                return (elem) => isText(elem) && data(elem.data);
            }
            return (elem) => isText(elem) && elem.data === data;
        },
    };
    /**
     * @param attrib Attribute to check.
     * @param value Attribute value to look for.
     * @returns A function to check whether the a node has an attribute with a
     *   particular value.
     */
    function getAttribCheck(attrib, value) {
        if (typeof value === "function") {
            return (elem) => isTag(elem) && value(elem.attribs[attrib]);
        }
        return (elem) => isTag(elem) && elem.attribs[attrib] === value;
    }
    /**
     * @param a First function to combine.
     * @param b Second function to combine.
     * @returns A function taking a node and returning `true` if either of the input
     *   functions returns `true` for the node.
     */
    function combineFuncs(a, b) {
        return (elem) => a(elem) || b(elem);
    }
    /**
     * @param options An object describing nodes to look for.
     * @returns A function executing all checks in `options` and returning `true` if
     *   any of them match a node.
     */
    function compileTest(options) {
        const funcs = Object.keys(options).map((key) => {
            const value = options[key];
            return Object.prototype.hasOwnProperty.call(Checks, key)
                ? Checks[key](value)
                : getAttribCheck(key, value);
        });
        return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    /**
     * @category Legacy Query Functions
     * @param options An object describing nodes to look for.
     * @param node The element to test.
     * @returns Whether the element matches the description in `options`.
     */
    function testElement(options, node) {
        const test = compileTest(options);
        return test ? test(node) : true;
    }
    /**
     * @category Legacy Query Functions
     * @param options An object describing nodes to look for.
     * @param nodes Nodes to search through.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes that match `options`.
     */
    function getElements(options, nodes, recurse, limit = Infinity) {
        const test = compileTest(options);
        return test ? filter$2(test, nodes, recurse, limit) : [];
    }
    /**
     * @category Legacy Query Functions
     * @param id The unique ID attribute value to look for.
     * @param nodes Nodes to search through.
     * @param recurse Also consider child nodes.
     * @returns The node with the supplied ID.
     */
    function getElementById(id, nodes, recurse = true) {
        if (!Array.isArray(nodes))
            nodes = [nodes];
        return findOne(getAttribCheck("id", id), nodes, recurse);
    }
    /**
     * @category Legacy Query Functions
     * @param tagName Tag name to search for.
     * @param nodes Nodes to search through.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes with the supplied `tagName`.
     */
    function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
        return filter$2(Checks["tag_name"](tagName), nodes, recurse, limit);
    }
    /**
     * @category Legacy Query Functions
     * @param type Element type to look for.
     * @param nodes Nodes to search through.
     * @param recurse Also consider child nodes.
     * @param limit Maximum number of nodes to return.
     * @returns All nodes with the supplied `type`.
     */
    function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
        return filter$2(Checks["tag_type"](type), nodes, recurse, limit);
    }

    /**
     * Given an array of nodes, remove any member that is contained by another.
     *
     * @category Helpers
     * @param nodes Nodes to filter.
     * @returns Remaining nodes that aren't subtrees of each other.
     */
    function removeSubsets(nodes) {
        let idx = nodes.length;
        /*
         * Check if each node (or one of its ancestors) is already contained in the
         * array.
         */
        while (--idx >= 0) {
            const node = nodes[idx];
            /*
             * Remove the node if it is not unique.
             * We are going through the array from the end, so we only
             * have to check nodes that preceed the node under consideration in the array.
             */
            if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
                nodes.splice(idx, 1);
                continue;
            }
            for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
                if (nodes.includes(ancestor)) {
                    nodes.splice(idx, 1);
                    break;
                }
            }
        }
        return nodes;
    }
    /**
     * @category Helpers
     * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}
     */
    var DocumentPosition;
    (function (DocumentPosition) {
        DocumentPosition[DocumentPosition["DISCONNECTED"] = 1] = "DISCONNECTED";
        DocumentPosition[DocumentPosition["PRECEDING"] = 2] = "PRECEDING";
        DocumentPosition[DocumentPosition["FOLLOWING"] = 4] = "FOLLOWING";
        DocumentPosition[DocumentPosition["CONTAINS"] = 8] = "CONTAINS";
        DocumentPosition[DocumentPosition["CONTAINED_BY"] = 16] = "CONTAINED_BY";
    })(DocumentPosition || (DocumentPosition = {}));
    /**
     * Compare the position of one node against another node in any other document.
     * The return value is a bitmask with the values from {@link DocumentPosition}.
     *
     * Document order:
     * > There is an ordering, document order, defined on all the nodes in the
     * > document corresponding to the order in which the first character of the
     * > XML representation of each node occurs in the XML representation of the
     * > document after expansion of general entities. Thus, the document element
     * > node will be the first node. Element nodes occur before their children.
     * > Thus, document order orders element nodes in order of the occurrence of
     * > their start-tag in the XML (after expansion of entities). The attribute
     * > nodes of an element occur after the element and before its children. The
     * > relative order of attribute nodes is implementation-dependent.
     *
     * Source:
     * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
     *
     * @category Helpers
     * @param nodeA The first node to use in the comparison
     * @param nodeB The second node to use in the comparison
     * @returns A bitmask describing the input nodes' relative position.
     *
     * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
     * a description of these values.
     */
    function compareDocumentPosition(nodeA, nodeB) {
        const aParents = [];
        const bParents = [];
        if (nodeA === nodeB) {
            return 0;
        }
        let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
        while (current) {
            aParents.unshift(current);
            current = current.parent;
        }
        current = hasChildren(nodeB) ? nodeB : nodeB.parent;
        while (current) {
            bParents.unshift(current);
            current = current.parent;
        }
        const maxIdx = Math.min(aParents.length, bParents.length);
        let idx = 0;
        while (idx < maxIdx && aParents[idx] === bParents[idx]) {
            idx++;
        }
        if (idx === 0) {
            return DocumentPosition.DISCONNECTED;
        }
        const sharedParent = aParents[idx - 1];
        const siblings = sharedParent.children;
        const aSibling = aParents[idx];
        const bSibling = bParents[idx];
        if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
            if (sharedParent === nodeB) {
                return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
            }
            return DocumentPosition.FOLLOWING;
        }
        if (sharedParent === nodeA) {
            return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
        }
        return DocumentPosition.PRECEDING;
    }
    /**
     * Sort an array of nodes based on their relative position in the document and
     * remove any duplicate nodes. If the array contains nodes that do not belong to
     * the same document, sort order is unspecified.
     *
     * @category Helpers
     * @param nodes Array of DOM nodes.
     * @returns Collection of unique nodes, sorted in document order.
     */
    function uniqueSort(nodes) {
        nodes = nodes.filter((node, i, arr) => !arr.includes(node, i + 1));
        nodes.sort((a, b) => {
            const relative = compareDocumentPosition(a, b);
            if (relative & DocumentPosition.PRECEDING) {
                return -1;
            }
            else if (relative & DocumentPosition.FOLLOWING) {
                return 1;
            }
            return 0;
        });
        return nodes;
    }

    /**
     * Get the feed object from the root of a DOM tree.
     *
     * @category Feeds
     * @param doc - The DOM to to extract the feed from.
     * @returns The feed.
     */
    function getFeed(doc) {
        const feedRoot = getOneElement(isValidFeed, doc);
        return !feedRoot
            ? null
            : feedRoot.name === "feed"
                ? getAtomFeed(feedRoot)
                : getRssFeed(feedRoot);
    }
    /**
     * Parse an Atom feed.
     *
     * @param feedRoot The root of the feed.
     * @returns The parsed feed.
     */
    function getAtomFeed(feedRoot) {
        var _a;
        const childs = feedRoot.children;
        const feed = {
            type: "atom",
            items: getElementsByTagName("entry", childs).map((item) => {
                var _a;
                const { children } = item;
                const entry = { media: getMediaElements(children) };
                addConditionally(entry, "id", "id", children);
                addConditionally(entry, "title", "title", children);
                const href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
                if (href) {
                    entry.link = href;
                }
                const description = fetch$1("summary", children) || fetch$1("content", children);
                if (description) {
                    entry.description = description;
                }
                const pubDate = fetch$1("updated", children);
                if (pubDate) {
                    entry.pubDate = new Date(pubDate);
                }
                return entry;
            }),
        };
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        const href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
        if (href) {
            feed.link = href;
        }
        addConditionally(feed, "description", "subtitle", childs);
        const updated = fetch$1("updated", childs);
        if (updated) {
            feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "email", childs, true);
        return feed;
    }
    /**
     * Parse a RSS feed.
     *
     * @param feedRoot The root of the feed.
     * @returns The parsed feed.
     */
    function getRssFeed(feedRoot) {
        var _a, _b;
        const childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
        const feed = {
            type: feedRoot.name.substr(0, 3),
            id: "",
            items: getElementsByTagName("item", feedRoot.children).map((item) => {
                const { children } = item;
                const entry = { media: getMediaElements(children) };
                addConditionally(entry, "id", "guid", children);
                addConditionally(entry, "title", "title", children);
                addConditionally(entry, "link", "link", children);
                addConditionally(entry, "description", "description", children);
                const pubDate = fetch$1("pubDate", children);
                if (pubDate)
                    entry.pubDate = new Date(pubDate);
                return entry;
            }),
        };
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        const updated = fetch$1("lastBuildDate", childs);
        if (updated) {
            feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "managingEditor", childs, true);
        return feed;
    }
    const MEDIA_KEYS_STRING = ["url", "type", "lang"];
    const MEDIA_KEYS_INT = [
        "fileSize",
        "bitrate",
        "framerate",
        "samplingrate",
        "channels",
        "duration",
        "height",
        "width",
    ];
    /**
     * Get all media elements of a feed item.
     *
     * @param where Nodes to search in.
     * @returns Media elements.
     */
    function getMediaElements(where) {
        return getElementsByTagName("media:content", where).map((elem) => {
            const { attribs } = elem;
            const media = {
                medium: attribs["medium"],
                isDefault: !!attribs["isDefault"],
            };
            for (const attrib of MEDIA_KEYS_STRING) {
                if (attribs[attrib]) {
                    media[attrib] = attribs[attrib];
                }
            }
            for (const attrib of MEDIA_KEYS_INT) {
                if (attribs[attrib]) {
                    media[attrib] = parseInt(attribs[attrib], 10);
                }
            }
            if (attribs["expression"]) {
                media.expression = attribs["expression"];
            }
            return media;
        });
    }
    /**
     * Get one element by tag name.
     *
     * @param tagName Tag name to look for
     * @param node Node to search in
     * @returns The element or null
     */
    function getOneElement(tagName, node) {
        return getElementsByTagName(tagName, node, true, 1)[0];
    }
    /**
     * Get the text content of an element with a certain tag name.
     *
     * @param tagName Tag name to look for.
     * @param where Node to search in.
     * @param recurse Whether to recurse into child nodes.
     * @returns The text content of the element.
     */
    function fetch$1(tagName, where, recurse = false) {
        return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
    }
    /**
     * Adds a property to an object if it has a value.
     *
     * @param obj Object to be extended
     * @param prop Property name
     * @param tagName Tag name that contains the conditionally added property
     * @param where Element to search for the property
     * @param recurse Whether to recurse into child nodes.
     */
    function addConditionally(obj, prop, tagName, where, recurse = false) {
        const val = fetch$1(tagName, where, recurse);
        if (val)
            obj[prop] = val;
    }
    /**
     * Checks if an element is a feed root node.
     *
     * @param value The name of the element to check.
     * @returns Whether an element is a feed root node.
     */
    function isValidFeed(value) {
        return value === "rss" || value === "feed" || value === "rdf:RDF";
    }

    var DomUtils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        isTag: isTag,
        isCDATA: isCDATA,
        isText: isText,
        isComment: isComment,
        isDocument: isDocument,
        hasChildren: hasChildren,
        getOuterHTML: getOuterHTML,
        getInnerHTML: getInnerHTML,
        getText: getText,
        textContent: textContent,
        innerText: innerText,
        getChildren: getChildren,
        getParent: getParent,
        getSiblings: getSiblings,
        getAttributeValue: getAttributeValue,
        hasAttrib: hasAttrib,
        getName: getName,
        nextElementSibling: nextElementSibling,
        prevElementSibling: prevElementSibling,
        removeElement: removeElement,
        replaceElement: replaceElement,
        appendChild: appendChild,
        append: append$1,
        prependChild: prependChild,
        prepend: prepend$1,
        filter: filter$2,
        find: find$2,
        findOneChild: findOneChild,
        findOne: findOne,
        existsOne: existsOne,
        findAll: findAll,
        testElement: testElement,
        getElements: getElements,
        getElementById: getElementById,
        getElementsByTagName: getElementsByTagName,
        getElementsByTagType: getElementsByTagType,
        removeSubsets: removeSubsets,
        get DocumentPosition () { return DocumentPosition; },
        compareDocumentPosition: compareDocumentPosition,
        uniqueSort: uniqueSort,
        getFeed: getFeed
    });

    /**
     * Helper function to render a DOM.
     *
     * @param that - Cheerio instance to render.
     * @param dom - The DOM to render. Defaults to `that`'s root.
     * @param options - Options for rendering.
     * @returns The rendered document.
     */
    function render(that, dom, options) {
        if (!that)
            return '';
        return that(dom !== null && dom !== void 0 ? dom : that._root.children, null, undefined, options).toString();
    }
    /**
     * Checks if a passed object is an options object.
     *
     * @param dom - Object to check if it is an options object.
     * @returns Whether the object is an options object.
     */
    function isOptions(dom, options) {
        return (!options &&
            typeof dom === 'object' &&
            dom != null &&
            !('length' in dom) &&
            !('type' in dom));
    }
    function html$1(dom, options) {
        /*
         * Be flexible about parameters, sometimes we call html(),
         * with options as only parameter
         * check dom argument for dom element specific properties
         * assume there is no 'length' or 'type' properties in the options object
         */
        const toRender = isOptions(dom) ? ((options = dom), undefined) : dom;
        /*
         * Sometimes `$.html()` is used without preloading html,
         * so fallback non-existing options to the default ones.
         */
        const opts = {
            ...defaultOpts$2,
            ...this === null || this === void 0 ? void 0 : this._options,
            ...flatten(options !== null && options !== void 0 ? options : {}),
        };
        return render(this, toRender, opts);
    }
    /**
     * Render the document as XML.
     *
     * @param dom - Element to render.
     * @returns THe rendered document.
     */
    function xml(dom) {
        const options = { ...this._options, xmlMode: true };
        return render(this, dom, options);
    }
    /**
     * Render the document as text.
     *
     * This returns the `textContent` of the passed elements. The result will
     * include the contents of `script` and `stype` elements. To avoid this, use
     * `.prop('innerText')` instead.
     *
     * @param elements - Elements to render.
     * @returns The rendered document.
     */
    function text$1(elements) {
        const elems = elements ? elements : this ? this.root() : [];
        let ret = '';
        for (let i = 0; i < elems.length; i++) {
            ret += textContent(elems[i]);
        }
        return ret;
    }
    function parseHTML(data, context, keepScripts = typeof context === 'boolean' ? context : false) {
        if (!data || typeof data !== 'string') {
            return null;
        }
        if (typeof context === 'boolean') {
            keepScripts = context;
        }
        const parsed = this.load(data, defaultOpts$2, false);
        if (!keepScripts) {
            parsed('script').remove();
        }
        /*
         * The `children` array is used by Cheerio internally to group elements that
         * share the same parents. When nodes created through `parseHTML` are
         * inserted into previously-existing DOM structures, they will be removed
         * from the `children` array. The results of `parseHTML` should remain
         * constant across these operations, so a shallow copy should be returned.
         */
        return parsed.root()[0].children.slice();
    }
    /**
     * Sometimes you need to work with the top-level root element. To query it, you
     * can use `$.root()`.
     *
     * @example
     *
     * ```js
     * $.root().append('<ul id="vegetables"></ul>').html();
     * //=> <ul id="fruits">...</ul><ul id="vegetables"></ul>
     * ```
     *
     * @returns Cheerio instance wrapping the root node.
     * @alias Cheerio.root
     */
    function root() {
        return this(this._root);
    }
    /**
     * Checks to see if the `contained` DOM element is a descendant of the
     * `container` DOM element.
     *
     * @param container - Potential parent node.
     * @param contained - Potential child node.
     * @returns Indicates if the nodes contain one another.
     * @alias Cheerio.contains
     * @see {@link https://api.jquery.com/jQuery.contains/}
     */
    function contains(container, contained) {
        // According to the jQuery API, an element does not "contain" itself
        if (contained === container) {
            return false;
        }
        /*
         * Step up the descendants, stopping when the root element is reached
         * (signaled by `.parent` returning a reference to the same object)
         */
        let next = contained;
        while (next && next !== next.parent) {
            next = next.parent;
            if (next === container) {
                return true;
            }
        }
        return false;
    }
    /**
     * $.merge().
     *
     * @param arr1 - First array.
     * @param arr2 - Second array.
     * @returns `arr1`, with elements of `arr2` inserted.
     * @alias Cheerio.merge
     * @see {@link https://api.jquery.com/jQuery.merge/}
     */
    function merge(arr1, arr2) {
        if (!isArrayLike(arr1) || !isArrayLike(arr2)) {
            return;
        }
        let newLength = arr1.length;
        const len = +arr2.length;
        for (let i = 0; i < len; i++) {
            arr1[newLength++] = arr2[i];
        }
        arr1.length = newLength;
        return arr1;
    }
    /**
     * Checks if an object is array-like.
     *
     * @param item - Item to check.
     * @returns Indicates if the item is array-like.
     */
    function isArrayLike(item) {
        if (Array.isArray(item)) {
            return true;
        }
        if (typeof item !== 'object' ||
            !Object.prototype.hasOwnProperty.call(item, 'length') ||
            typeof item.length !== 'number' ||
            item.length < 0) {
            return false;
        }
        for (let i = 0; i < item.length; i++) {
            if (!(i in item)) {
                return false;
            }
        }
        return true;
    }

    var staticMethods = /*#__PURE__*/Object.freeze({
        __proto__: null,
        html: html$1,
        xml: xml,
        text: text$1,
        parseHTML: parseHTML,
        root: root,
        contains: contains,
        merge: merge
    });

    /**
     * Checks if an object is a Cheerio instance.
     *
     * @category Utils
     * @param maybeCheerio - The object to check.
     * @returns Whether the object is a Cheerio instance.
     */
    function isCheerio(maybeCheerio) {
        return maybeCheerio.cheerio != null;
    }
    /**
     * Convert a string to camel case notation.
     *
     * @private
     * @category Utils
     * @param str - The string to be converted.
     * @returns String in camel case notation.
     */
    function camelCase(str) {
        return str.replace(/[_.-](\w|$)/g, (_, x) => x.toUpperCase());
    }
    /**
     * Convert a string from camel case to "CSS case", where word boundaries are
     * described by hyphens ("-") and all characters are lower-case.
     *
     * @private
     * @category Utils
     * @param str - The string to be converted.
     * @returns String in "CSS case".
     */
    function cssCase(str) {
        return str.replace(/[A-Z]/g, '-$&').toLowerCase();
    }
    /**
     * Iterate over each DOM element without creating intermediary Cheerio instances.
     *
     * This is indented for use internally to avoid otherwise unnecessary memory
     * pressure introduced by _make.
     *
     * @category Utils
     * @param array - The array to iterate over.
     * @param fn - Function to call.
     * @returns The original instance.
     */
    function domEach(array, fn) {
        const len = array.length;
        for (let i = 0; i < len; i++)
            fn(array[i], i);
        return array;
    }
    /**
     * Create a deep copy of the given DOM structure. Sets the parents of the copies
     * of the passed nodes to `null`.
     *
     * @private
     * @category Utils
     * @param dom - The domhandler-compliant DOM structure.
     * @returns - The cloned DOM.
     */
    function cloneDom(dom) {
        const clone = 'length' in dom
            ? Array.prototype.map.call(dom, (el) => cloneNode(el, true))
            : [cloneNode(dom, true)];
        // Add a root node around the cloned nodes
        const root = new Document(clone);
        clone.forEach((node) => {
            node.parent = root;
        });
        return clone;
    }
    var CharacterCodes;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["LowerA"] = 97] = "LowerA";
        CharacterCodes[CharacterCodes["LowerZ"] = 122] = "LowerZ";
        CharacterCodes[CharacterCodes["UpperA"] = 65] = "UpperA";
        CharacterCodes[CharacterCodes["UpperZ"] = 90] = "UpperZ";
        CharacterCodes[CharacterCodes["Exclamation"] = 33] = "Exclamation";
    })(CharacterCodes || (CharacterCodes = {}));
    /**
     * Check if string is HTML.
     *
     * Tests for a `<` within a string, immediate followed by a letter and
     * eventually followed by a `>`.
     *
     * @private
     * @category Utils
     * @param str - The string to check.
     * @returns Indicates if `str` is HTML.
     */
    function isHtml(str) {
        const tagStart = str.indexOf('<');
        if (tagStart < 0 || tagStart > str.length - 3)
            return false;
        const tagChar = str.charCodeAt(tagStart + 1);
        return (((tagChar >= CharacterCodes.LowerA && tagChar <= CharacterCodes.LowerZ) ||
            (tagChar >= CharacterCodes.UpperA && tagChar <= CharacterCodes.UpperZ) ||
            tagChar === CharacterCodes.Exclamation) &&
            str.includes('>', tagStart + 2));
    }

    /**
     * Methods for getting and modifying attributes.
     *
     * @module cheerio/attributes
     */
    const hasOwn = Object.prototype.hasOwnProperty;
    const rspace = /\s+/;
    const dataAttrPrefix = 'data-';
    /*
     * Lookup table for coercing string data-* attributes to their corresponding
     * JavaScript primitives
     */
    const primitives = {
        null: null,
        true: true,
        false: false,
    };
    // Attributes that are booleans
    const rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
    // Matches strings that look like JSON objects or arrays
    const rbrace = /^{[^]*}$|^\[[^]*]$/;
    function getAttr(elem, name, xmlMode) {
        var _a;
        if (!elem || !isTag(elem))
            return undefined;
        (_a = elem.attribs) !== null && _a !== void 0 ? _a : (elem.attribs = {});
        // Return the entire attribs object if no attribute specified
        if (!name) {
            return elem.attribs;
        }
        if (hasOwn.call(elem.attribs, name)) {
            // Get the (decoded) attribute
            return !xmlMode && rboolean.test(name) ? name : elem.attribs[name];
        }
        // Mimic the DOM and return text content as value for `option's`
        if (elem.name === 'option' && name === 'value') {
            return text$1(elem.children);
        }
        // Mimic DOM with default value for radios/checkboxes
        if (elem.name === 'input' &&
            (elem.attribs['type'] === 'radio' || elem.attribs['type'] === 'checkbox') &&
            name === 'value') {
            return 'on';
        }
        return undefined;
    }
    /**
     * Sets the value of an attribute. The attribute will be deleted if the value is `null`.
     *
     * @private
     * @param el - The element to set the attribute on.
     * @param name - The attribute's name.
     * @param value - The attribute's value.
     */
    function setAttr(el, name, value) {
        if (value === null) {
            removeAttribute(el, name);
        }
        else {
            el.attribs[name] = `${value}`;
        }
    }
    function attr(name, value) {
        // Set the value (with attr map support)
        if (typeof name === 'object' || value !== undefined) {
            if (typeof value === 'function') {
                if (typeof name !== 'string') {
                    {
                        throw new Error('Bad combination of arguments.');
                    }
                }
                return domEach(this, (el, i) => {
                    if (isTag(el))
                        setAttr(el, name, value.call(el, i, el.attribs[name]));
                });
            }
            return domEach(this, (el) => {
                if (!isTag(el))
                    return;
                if (typeof name === 'object') {
                    Object.keys(name).forEach((objName) => {
                        const objValue = name[objName];
                        setAttr(el, objName, objValue);
                    });
                }
                else {
                    setAttr(el, name, value);
                }
            });
        }
        return arguments.length > 1
            ? this
            : getAttr(this[0], name, this.options.xmlMode);
    }
    /**
     * Gets a node's prop.
     *
     * @private
     * @category Attributes
     * @param el - Element to get the prop of.
     * @param name - Name of the prop.
     * @returns The prop's value.
     */
    function getProp(el, name, xmlMode) {
        return name in el
            ? // @ts-expect-error TS doesn't like us accessing the value directly here.
                el[name]
            : !xmlMode && rboolean.test(name)
                ? getAttr(el, name, false) !== undefined
                : getAttr(el, name, xmlMode);
    }
    /**
     * Sets the value of a prop.
     *
     * @private
     * @param el - The element to set the prop on.
     * @param name - The prop's name.
     * @param value - The prop's value.
     */
    function setProp(el, name, value, xmlMode) {
        if (name in el) {
            // @ts-expect-error Overriding value
            el[name] = value;
        }
        else {
            setAttr(el, name, !xmlMode && rboolean.test(name) ? (value ? '' : null) : `${value}`);
        }
    }
    function prop(name, value) {
        var _a;
        if (typeof name === 'string' && value === undefined) {
            const el = this[0];
            if (!el || !isTag(el))
                return undefined;
            switch (name) {
                case 'style': {
                    const property = this.css();
                    const keys = Object.keys(property);
                    keys.forEach((p, i) => {
                        property[i] = p;
                    });
                    property.length = keys.length;
                    return property;
                }
                case 'tagName':
                case 'nodeName': {
                    return el.name.toUpperCase();
                }
                case 'href':
                case 'src': {
                    const prop = (_a = el.attribs) === null || _a === void 0 ? void 0 : _a[name];
                    /* eslint-disable node/no-unsupported-features/node-builtins */
                    if (typeof URL !== 'undefined' &&
                        ((name === 'href' && (el.tagName === 'a' || el.name === 'link')) ||
                            (name === 'src' &&
                                (el.tagName === 'img' ||
                                    el.tagName === 'iframe' ||
                                    el.tagName === 'audio' ||
                                    el.tagName === 'video' ||
                                    el.tagName === 'source'))) &&
                        prop !== undefined &&
                        this.options.baseURI) {
                        return new URL(prop, this.options.baseURI).href;
                    }
                    /* eslint-enable node/no-unsupported-features/node-builtins */
                    return prop;
                }
                case 'innerText': {
                    return innerText(el);
                }
                case 'textContent': {
                    return textContent(el);
                }
                case 'outerHTML':
                    return this.clone().wrap('<container />').parent().html();
                case 'innerHTML':
                    return this.html();
                default:
                    return getProp(el, name, this.options.xmlMode);
            }
        }
        if (typeof name === 'object' || value !== undefined) {
            if (typeof value === 'function') {
                if (typeof name === 'object') {
                    throw new Error('Bad combination of arguments.');
                }
                return domEach(this, (el, i) => {
                    if (isTag(el)) {
                        setProp(el, name, value.call(el, i, getProp(el, name, this.options.xmlMode)), this.options.xmlMode);
                    }
                });
            }
            return domEach(this, (el) => {
                if (!isTag(el))
                    return;
                if (typeof name === 'object') {
                    Object.keys(name).forEach((key) => {
                        const val = name[key];
                        setProp(el, key, val, this.options.xmlMode);
                    });
                }
                else {
                    setProp(el, name, value, this.options.xmlMode);
                }
            });
        }
        return undefined;
    }
    /**
     * Sets the value of a data attribute.
     *
     * @private
     * @param el - The element to set the data attribute on.
     * @param name - The data attribute's name.
     * @param value - The data attribute's value.
     */
    function setData(el, name, value) {
        var _a;
        const elem = el;
        (_a = elem.data) !== null && _a !== void 0 ? _a : (elem.data = {});
        if (typeof name === 'object')
            Object.assign(elem.data, name);
        else if (typeof name === 'string' && value !== undefined) {
            elem.data[name] = value;
        }
    }
    /**
     * Read the specified attribute from the equivalent HTML5 `data-*` attribute,
     * and (if present) cache the value in the node's internal data store. If no
     * attribute name is specified, read _all_ HTML5 `data-*` attributes in this manner.
     *
     * @private
     * @category Attributes
     * @param el - Element to get the data attribute of.
     * @param name - Name of the data attribute.
     * @returns The data attribute's value, or a map with all of the data attributes.
     */
    function readData(el, name) {
        let domNames;
        let jsNames;
        let value;
        if (name == null) {
            domNames = Object.keys(el.attribs).filter((attrName) => attrName.startsWith(dataAttrPrefix));
            jsNames = domNames.map((domName) => camelCase(domName.slice(dataAttrPrefix.length)));
        }
        else {
            domNames = [dataAttrPrefix + cssCase(name)];
            jsNames = [name];
        }
        for (let idx = 0; idx < domNames.length; ++idx) {
            const domName = domNames[idx];
            const jsName = jsNames[idx];
            if (hasOwn.call(el.attribs, domName) &&
                !hasOwn.call(el.data, jsName)) {
                value = el.attribs[domName];
                if (hasOwn.call(primitives, value)) {
                    value = primitives[value];
                }
                else if (value === String(Number(value))) {
                    value = Number(value);
                }
                else if (rbrace.test(value)) {
                    try {
                        value = JSON.parse(value);
                    }
                    catch (e) {
                        /* Ignore */
                    }
                }
                el.data[jsName] = value;
            }
        }
        return name == null ? el.data : value;
    }
    function data(name, value) {
        var _a;
        const elem = this[0];
        if (!elem || !isTag(elem))
            return;
        const dataEl = elem;
        (_a = dataEl.data) !== null && _a !== void 0 ? _a : (dataEl.data = {});
        // Return the entire data object if no data specified
        if (!name) {
            return readData(dataEl);
        }
        // Set the value (with attr map support)
        if (typeof name === 'object' || value !== undefined) {
            domEach(this, (el) => {
                if (isTag(el)) {
                    if (typeof name === 'object')
                        setData(el, name);
                    else
                        setData(el, name, value);
                }
            });
            return this;
        }
        if (hasOwn.call(dataEl.data, name)) {
            return dataEl.data[name];
        }
        return readData(dataEl, name);
    }
    function val(value) {
        const querying = arguments.length === 0;
        const element = this[0];
        if (!element || !isTag(element))
            return querying ? undefined : this;
        switch (element.name) {
            case 'textarea':
                return this.text(value);
            case 'select': {
                const option = this.find('option:selected');
                if (!querying) {
                    if (this.attr('multiple') == null && typeof value === 'object') {
                        return this;
                    }
                    this.find('option').removeAttr('selected');
                    const values = typeof value !== 'object' ? [value] : value;
                    for (let i = 0; i < values.length; i++) {
                        this.find(`option[value="${values[i]}"]`).attr('selected', '');
                    }
                    return this;
                }
                return this.attr('multiple')
                    ? option.toArray().map((el) => text$1(el.children))
                    : option.attr('value');
            }
            case 'input':
            case 'option':
                return querying
                    ? this.attr('value')
                    : this.attr('value', value);
        }
        return undefined;
    }
    /**
     * Remove an attribute.
     *
     * @private
     * @param elem - Node to remove attribute from.
     * @param name - Name of the attribute to remove.
     */
    function removeAttribute(elem, name) {
        if (!elem.attribs || !hasOwn.call(elem.attribs, name))
            return;
        delete elem.attribs[name];
    }
    /**
     * Splits a space-separated list of names to individual names.
     *
     * @category Attributes
     * @param names - Names to split.
     * @returns - Split names.
     */
    function splitNames(names) {
        return names ? names.trim().split(rspace) : [];
    }
    /**
     * Method for removing attributes by `name`.
     *
     * @category Attributes
     * @example
     *
     * ```js
     * $('.pear').removeAttr('class').html();
     * //=> <li>Pear</li>
     *
     * $('.apple').attr('id', 'favorite');
     * $('.apple').removeAttr('id class').html();
     * //=> <li>Apple</li>
     * ```
     *
     * @param name - Name of the attribute.
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/removeAttr/}
     */
    function removeAttr(name) {
        const attrNames = splitNames(name);
        for (let i = 0; i < attrNames.length; i++) {
            domEach(this, (elem) => {
                if (isTag(elem))
                    removeAttribute(elem, attrNames[i]);
            });
        }
        return this;
    }
    /**
     * Check to see if _any_ of the matched elements have the given `className`.
     *
     * @category Attributes
     * @example
     *
     * ```js
     * $('.pear').hasClass('pear');
     * //=> true
     *
     * $('apple').hasClass('fruit');
     * //=> false
     *
     * $('li').hasClass('pear');
     * //=> true
     * ```
     *
     * @param className - Name of the class.
     * @returns Indicates if an element has the given `className`.
     * @see {@link https://api.jquery.com/hasClass/}
     */
    function hasClass(className) {
        return this.toArray().some((elem) => {
            const clazz = isTag(elem) && elem.attribs['class'];
            let idx = -1;
            if (clazz && className.length) {
                while ((idx = clazz.indexOf(className, idx + 1)) > -1) {
                    const end = idx + className.length;
                    if ((idx === 0 || rspace.test(clazz[idx - 1])) &&
                        (end === clazz.length || rspace.test(clazz[end]))) {
                        return true;
                    }
                }
            }
            return false;
        });
    }
    /**
     * Adds class(es) to all of the matched elements. Also accepts a `function`.
     *
     * @category Attributes
     * @example
     *
     * ```js
     * $('.pear').addClass('fruit').html();
     * //=> <li class="pear fruit">Pear</li>
     *
     * $('.apple').addClass('fruit red').html();
     * //=> <li class="apple fruit red">Apple</li>
     * ```
     *
     * @param value - Name of new class.
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/addClass/}
     */
    function addClass(value) {
        // Support functions
        if (typeof value === 'function') {
            return domEach(this, (el, i) => {
                if (isTag(el)) {
                    const className = el.attribs['class'] || '';
                    addClass.call([el], value.call(el, i, className));
                }
            });
        }
        // Return if no value or not a string or function
        if (!value || typeof value !== 'string')
            return this;
        const classNames = value.split(rspace);
        const numElements = this.length;
        for (let i = 0; i < numElements; i++) {
            const el = this[i];
            // If selected element isn't a tag, move on
            if (!isTag(el))
                continue;
            // If we don't already have classes  always set xmlMode to false here, as it doesn't matter for classes
            const className = getAttr(el, 'class', false);
            if (!className) {
                setAttr(el, 'class', classNames.join(' ').trim());
            }
            else {
                let setClass = ` ${className} `;
                // Check if class already exists
                for (let j = 0; j < classNames.length; j++) {
                    const appendClass = `${classNames[j]} `;
                    if (!setClass.includes(` ${appendClass}`))
                        setClass += appendClass;
                }
                setAttr(el, 'class', setClass.trim());
            }
        }
        return this;
    }
    /**
     * Removes one or more space-separated classes from the selected elements. If no
     * `className` is defined, all classes will be removed. Also accepts a `function`.
     *
     * @category Attributes
     * @example
     *
     * ```js
     * $('.pear').removeClass('pear').html();
     * //=> <li class="">Pear</li>
     *
     * $('.apple').addClass('red').removeClass().html();
     * //=> <li class="">Apple</li>
     * ```
     *
     * @param name - Name of the class. If not specified, removes all elements.
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/removeClass/}
     */
    function removeClass(name) {
        // Handle if value is a function
        if (typeof name === 'function') {
            return domEach(this, (el, i) => {
                if (isTag(el)) {
                    removeClass.call([el], name.call(el, i, el.attribs['class'] || ''));
                }
            });
        }
        const classes = splitNames(name);
        const numClasses = classes.length;
        const removeAll = arguments.length === 0;
        return domEach(this, (el) => {
            if (!isTag(el))
                return;
            if (removeAll) {
                // Short circuit the remove all case as this is the nice one
                el.attribs['class'] = '';
            }
            else {
                const elClasses = splitNames(el.attribs['class']);
                let changed = false;
                for (let j = 0; j < numClasses; j++) {
                    const index = elClasses.indexOf(classes[j]);
                    if (index >= 0) {
                        elClasses.splice(index, 1);
                        changed = true;
                        /*
                         * We have to do another pass to ensure that there are not duplicate
                         * classes listed
                         */
                        j--;
                    }
                }
                if (changed) {
                    el.attribs['class'] = elClasses.join(' ');
                }
            }
        });
    }
    /**
     * Add or remove class(es) from the matched elements, depending on either the
     * class's presence or the value of the switch argument. Also accepts a `function`.
     *
     * @category Attributes
     * @example
     *
     * ```js
     * $('.apple.green').toggleClass('fruit green red').html();
     * //=> <li class="apple fruit red">Apple</li>
     *
     * $('.apple.green').toggleClass('fruit green red', true).html();
     * //=> <li class="apple green fruit red">Apple</li>
     * ```
     *
     * @param value - Name of the class. Can also be a function.
     * @param stateVal - If specified the state of the class.
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/toggleClass/}
     */
    function toggleClass(value, stateVal) {
        // Support functions
        if (typeof value === 'function') {
            return domEach(this, (el, i) => {
                if (isTag(el)) {
                    toggleClass.call([el], value.call(el, i, el.attribs['class'] || '', stateVal), stateVal);
                }
            });
        }
        // Return if no value or not a string or function
        if (!value || typeof value !== 'string')
            return this;
        const classNames = value.split(rspace);
        const numClasses = classNames.length;
        const state = typeof stateVal === 'boolean' ? (stateVal ? 1 : -1) : 0;
        const numElements = this.length;
        for (let i = 0; i < numElements; i++) {
            const el = this[i];
            // If selected element isn't a tag, move on
            if (!isTag(el))
                continue;
            const elementClasses = splitNames(el.attribs['class']);
            // Check if class already exists
            for (let j = 0; j < numClasses; j++) {
                // Check if the class name is currently defined
                const index = elementClasses.indexOf(classNames[j]);
                // Add if stateValue === true or we are toggling and there is no value
                if (state >= 0 && index < 0) {
                    elementClasses.push(classNames[j]);
                }
                else if (state <= 0 && index >= 0) {
                    // Otherwise remove but only if the item exists
                    elementClasses.splice(index, 1);
                }
            }
            el.attribs['class'] = elementClasses.join(' ');
        }
        return this;
    }

    var Attributes = /*#__PURE__*/Object.freeze({
        __proto__: null,
        attr: attr,
        prop: prop,
        data: data,
        val: val,
        removeAttr: removeAttr,
        hasClass: hasClass,
        addClass: addClass,
        removeClass: removeClass,
        toggleClass: toggleClass
    });

    var SelectorType;
    (function (SelectorType) {
        SelectorType["Attribute"] = "attribute";
        SelectorType["Pseudo"] = "pseudo";
        SelectorType["PseudoElement"] = "pseudo-element";
        SelectorType["Tag"] = "tag";
        SelectorType["Universal"] = "universal";
        // Traversals
        SelectorType["Adjacent"] = "adjacent";
        SelectorType["Child"] = "child";
        SelectorType["Descendant"] = "descendant";
        SelectorType["Parent"] = "parent";
        SelectorType["Sibling"] = "sibling";
        SelectorType["ColumnCombinator"] = "column-combinator";
    })(SelectorType || (SelectorType = {}));
    var AttributeAction;
    (function (AttributeAction) {
        AttributeAction["Any"] = "any";
        AttributeAction["Element"] = "element";
        AttributeAction["End"] = "end";
        AttributeAction["Equals"] = "equals";
        AttributeAction["Exists"] = "exists";
        AttributeAction["Hyphen"] = "hyphen";
        AttributeAction["Not"] = "not";
        AttributeAction["Start"] = "start";
    })(AttributeAction || (AttributeAction = {}));

    const reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
    const reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
    const actionTypes = new Map([
        [126 /* Tilde */, AttributeAction.Element],
        [94 /* Circumflex */, AttributeAction.Start],
        [36 /* Dollar */, AttributeAction.End],
        [42 /* Asterisk */, AttributeAction.Any],
        [33 /* ExclamationMark */, AttributeAction.Not],
        [124 /* Pipe */, AttributeAction.Hyphen],
    ]);
    // Pseudos, whose data property is parsed as well.
    const unpackPseudos = new Set([
        "has",
        "not",
        "matches",
        "is",
        "where",
        "host",
        "host-context",
    ]);
    /**
     * Checks whether a specific selector is a traversal.
     * This is useful eg. in swapping the order of elements that
     * are not traversals.
     *
     * @param selector Selector to check.
     */
    function isTraversal$1(selector) {
        switch (selector.type) {
            case SelectorType.Adjacent:
            case SelectorType.Child:
            case SelectorType.Descendant:
            case SelectorType.Parent:
            case SelectorType.Sibling:
            case SelectorType.ColumnCombinator:
                return true;
            default:
                return false;
        }
    }
    const stripQuotesFromPseudos = new Set(["contains", "icontains"]);
    // Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152
    function funescape(_, escaped, escapedWhitespace) {
        const high = parseInt(escaped, 16) - 0x10000;
        // NaN means non-codepoint
        return high !== high || escapedWhitespace
            ? escaped
            : high < 0
                ? // BMP codepoint
                    String.fromCharCode(high + 0x10000)
                : // Supplemental Plane codepoint (surrogate pair)
                    String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);
    }
    function unescapeCSS(str) {
        return str.replace(reEscape, funescape);
    }
    function isQuote(c) {
        return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;
    }
    function isWhitespace$2(c) {
        return (c === 32 /* Space */ ||
            c === 9 /* Tab */ ||
            c === 10 /* NewLine */ ||
            c === 12 /* FormFeed */ ||
            c === 13 /* CarriageReturn */);
    }
    /**
     * Parses `selector`, optionally with the passed `options`.
     *
     * @param selector Selector to parse.
     * @param options Options for parsing.
     * @returns Returns a two-dimensional array.
     * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),
     * the second contains the relevant tokens for that selector.
     */
    function parse$4(selector) {
        const subselects = [];
        const endIndex = parseSelector(subselects, `${selector}`, 0);
        if (endIndex < selector.length) {
            throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
        }
        return subselects;
    }
    function parseSelector(subselects, selector, selectorIndex) {
        let tokens = [];
        function getName(offset) {
            const match = selector.slice(selectorIndex + offset).match(reName);
            if (!match) {
                throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
            }
            const [name] = match;
            selectorIndex += offset + name.length;
            return unescapeCSS(name);
        }
        function stripWhitespace(offset) {
            selectorIndex += offset;
            while (selectorIndex < selector.length &&
                isWhitespace$2(selector.charCodeAt(selectorIndex))) {
                selectorIndex++;
            }
        }
        function readValueWithParenthesis() {
            selectorIndex += 1;
            const start = selectorIndex;
            let counter = 1;
            for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
                if (selector.charCodeAt(selectorIndex) ===
                    40 /* LeftParenthesis */ &&
                    !isEscaped(selectorIndex)) {
                    counter++;
                }
                else if (selector.charCodeAt(selectorIndex) ===
                    41 /* RightParenthesis */ &&
                    !isEscaped(selectorIndex)) {
                    counter--;
                }
            }
            if (counter) {
                throw new Error("Parenthesis not matched");
            }
            return unescapeCSS(selector.slice(start, selectorIndex - 1));
        }
        function isEscaped(pos) {
            let slashCount = 0;
            while (selector.charCodeAt(--pos) === 92 /* BackSlash */)
                slashCount++;
            return (slashCount & 1) === 1;
        }
        function ensureNotTraversal() {
            if (tokens.length > 0 && isTraversal$1(tokens[tokens.length - 1])) {
                throw new Error("Did not expect successive traversals.");
            }
        }
        function addTraversal(type) {
            if (tokens.length > 0 &&
                tokens[tokens.length - 1].type === SelectorType.Descendant) {
                tokens[tokens.length - 1].type = type;
                return;
            }
            ensureNotTraversal();
            tokens.push({ type });
        }
        function addSpecialAttribute(name, action) {
            tokens.push({
                type: SelectorType.Attribute,
                name,
                action,
                value: getName(1),
                namespace: null,
                ignoreCase: "quirks",
            });
        }
        /**
         * We have finished parsing the current part of the selector.
         *
         * Remove descendant tokens at the end if they exist,
         * and return the last index, so that parsing can be
         * picked up from here.
         */
        function finalizeSubselector() {
            if (tokens.length &&
                tokens[tokens.length - 1].type === SelectorType.Descendant) {
                tokens.pop();
            }
            if (tokens.length === 0) {
                throw new Error("Empty sub-selector");
            }
            subselects.push(tokens);
        }
        stripWhitespace(0);
        if (selector.length === selectorIndex) {
            return selectorIndex;
        }
        loop: while (selectorIndex < selector.length) {
            const firstChar = selector.charCodeAt(selectorIndex);
            switch (firstChar) {
                // Whitespace
                case 32 /* Space */:
                case 9 /* Tab */:
                case 10 /* NewLine */:
                case 12 /* FormFeed */:
                case 13 /* CarriageReturn */: {
                    if (tokens.length === 0 ||
                        tokens[0].type !== SelectorType.Descendant) {
                        ensureNotTraversal();
                        tokens.push({ type: SelectorType.Descendant });
                    }
                    stripWhitespace(1);
                    break;
                }
                // Traversals
                case 62 /* GreaterThan */: {
                    addTraversal(SelectorType.Child);
                    stripWhitespace(1);
                    break;
                }
                case 60 /* LessThan */: {
                    addTraversal(SelectorType.Parent);
                    stripWhitespace(1);
                    break;
                }
                case 126 /* Tilde */: {
                    addTraversal(SelectorType.Sibling);
                    stripWhitespace(1);
                    break;
                }
                case 43 /* Plus */: {
                    addTraversal(SelectorType.Adjacent);
                    stripWhitespace(1);
                    break;
                }
                // Special attribute selectors: .class, #id
                case 46 /* Period */: {
                    addSpecialAttribute("class", AttributeAction.Element);
                    break;
                }
                case 35 /* Hash */: {
                    addSpecialAttribute("id", AttributeAction.Equals);
                    break;
                }
                case 91 /* LeftSquareBracket */: {
                    stripWhitespace(1);
                    // Determine attribute name and namespace
                    let name;
                    let namespace = null;
                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {
                        // Equivalent to no namespace
                        name = getName(1);
                    }
                    else if (selector.startsWith("*|", selectorIndex)) {
                        namespace = "*";
                        name = getName(2);
                    }
                    else {
                        name = getName(0);
                        if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                            selector.charCodeAt(selectorIndex + 1) !==
                                61 /* Equal */) {
                            namespace = name;
                            name = getName(1);
                        }
                    }
                    stripWhitespace(0);
                    // Determine comparison operation
                    let action = AttributeAction.Exists;
                    const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
                    if (possibleAction) {
                        action = possibleAction;
                        if (selector.charCodeAt(selectorIndex + 1) !==
                            61 /* Equal */) {
                            throw new Error("Expected `=`");
                        }
                        stripWhitespace(2);
                    }
                    else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {
                        action = AttributeAction.Equals;
                        stripWhitespace(1);
                    }
                    // Determine value
                    let value = "";
                    let ignoreCase = null;
                    if (action !== "exists") {
                        if (isQuote(selector.charCodeAt(selectorIndex))) {
                            const quote = selector.charCodeAt(selectorIndex);
                            let sectionEnd = selectorIndex + 1;
                            while (sectionEnd < selector.length &&
                                (selector.charCodeAt(sectionEnd) !== quote ||
                                    isEscaped(sectionEnd))) {
                                sectionEnd += 1;
                            }
                            if (selector.charCodeAt(sectionEnd) !== quote) {
                                throw new Error("Attribute value didn't end");
                            }
                            value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                            selectorIndex = sectionEnd + 1;
                        }
                        else {
                            const valueStart = selectorIndex;
                            while (selectorIndex < selector.length &&
                                ((!isWhitespace$2(selector.charCodeAt(selectorIndex)) &&
                                    selector.charCodeAt(selectorIndex) !==
                                        93 /* RightSquareBracket */) ||
                                    isEscaped(selectorIndex))) {
                                selectorIndex += 1;
                            }
                            value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                        }
                        stripWhitespace(0);
                        // See if we have a force ignore flag
                        const forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;
                        // If the forceIgnore flag is set (either `i` or `s`), use that value
                        if (forceIgnore === 115 /* LowerS */) {
                            ignoreCase = false;
                            stripWhitespace(1);
                        }
                        else if (forceIgnore === 105 /* LowerI */) {
                            ignoreCase = true;
                            stripWhitespace(1);
                        }
                    }
                    if (selector.charCodeAt(selectorIndex) !==
                        93 /* RightSquareBracket */) {
                        throw new Error("Attribute selector didn't terminate");
                    }
                    selectorIndex += 1;
                    const attributeSelector = {
                        type: SelectorType.Attribute,
                        name,
                        action,
                        value,
                        namespace,
                        ignoreCase,
                    };
                    tokens.push(attributeSelector);
                    break;
                }
                case 58 /* Colon */: {
                    if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {
                        tokens.push({
                            type: SelectorType.PseudoElement,
                            name: getName(2).toLowerCase(),
                            data: selector.charCodeAt(selectorIndex) ===
                                40 /* LeftParenthesis */
                                ? readValueWithParenthesis()
                                : null,
                        });
                        continue;
                    }
                    const name = getName(1).toLowerCase();
                    let data = null;
                    if (selector.charCodeAt(selectorIndex) ===
                        40 /* LeftParenthesis */) {
                        if (unpackPseudos.has(name)) {
                            if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                                throw new Error(`Pseudo-selector ${name} cannot be quoted`);
                            }
                            data = [];
                            selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                            if (selector.charCodeAt(selectorIndex) !==
                                41 /* RightParenthesis */) {
                                throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
                            }
                            selectorIndex += 1;
                        }
                        else {
                            data = readValueWithParenthesis();
                            if (stripQuotesFromPseudos.has(name)) {
                                const quot = data.charCodeAt(0);
                                if (quot === data.charCodeAt(data.length - 1) &&
                                    isQuote(quot)) {
                                    data = data.slice(1, -1);
                                }
                            }
                            data = unescapeCSS(data);
                        }
                    }
                    tokens.push({ type: SelectorType.Pseudo, name, data });
                    break;
                }
                case 44 /* Comma */: {
                    finalizeSubselector();
                    tokens = [];
                    stripWhitespace(1);
                    break;
                }
                default: {
                    if (selector.startsWith("/*", selectorIndex)) {
                        const endIndex = selector.indexOf("*/", selectorIndex + 2);
                        if (endIndex < 0) {
                            throw new Error("Comment was not terminated");
                        }
                        selectorIndex = endIndex + 2;
                        // Remove leading whitespace
                        if (tokens.length === 0) {
                            stripWhitespace(0);
                        }
                        break;
                    }
                    let namespace = null;
                    let name;
                    if (firstChar === 42 /* Asterisk */) {
                        selectorIndex += 1;
                        name = "*";
                    }
                    else if (firstChar === 124 /* Pipe */) {
                        name = "";
                        if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {
                            addTraversal(SelectorType.ColumnCombinator);
                            stripWhitespace(2);
                            break;
                        }
                    }
                    else if (reName.test(selector.slice(selectorIndex))) {
                        name = getName(0);
                    }
                    else {
                        break loop;
                    }
                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&
                        selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {
                        namespace = name;
                        if (selector.charCodeAt(selectorIndex + 1) ===
                            42 /* Asterisk */) {
                            name = "*";
                            selectorIndex += 2;
                        }
                        else {
                            name = getName(1);
                        }
                    }
                    tokens.push(name === "*"
                        ? { type: SelectorType.Universal, namespace }
                        : { type: SelectorType.Tag, name, namespace });
                }
            }
        }
        finalizeSubselector();
        return selectorIndex;
    }

    var boolbase = {
    	trueFunc: function trueFunc(){
    		return true;
    	},
    	falseFunc: function falseFunc(){
    		return false;
    	}
    };

    const procedure = new Map([
        [SelectorType.Universal, 50],
        [SelectorType.Tag, 30],
        [SelectorType.Attribute, 1],
        [SelectorType.Pseudo, 0],
    ]);
    function isTraversal(token) {
        return !procedure.has(token.type);
    }
    const attributes = new Map([
        [AttributeAction.Exists, 10],
        [AttributeAction.Equals, 8],
        [AttributeAction.Not, 7],
        [AttributeAction.Start, 6],
        [AttributeAction.End, 6],
        [AttributeAction.Any, 5],
    ]);
    /**
     * Sort the parts of the passed selector,
     * as there is potential for optimization
     * (some types of selectors are faster than others)
     *
     * @param arr Selector to sort
     */
    function sortByProcedure(arr) {
        const procs = arr.map(getProcedure);
        for (let i = 1; i < arr.length; i++) {
            const procNew = procs[i];
            if (procNew < 0)
                continue;
            for (let j = i - 1; j >= 0 && procNew < procs[j]; j--) {
                const token = arr[j + 1];
                arr[j + 1] = arr[j];
                arr[j] = token;
                procs[j + 1] = procs[j];
                procs[j] = procNew;
            }
        }
    }
    function getProcedure(token) {
        var _a, _b;
        let proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;
        if (token.type === SelectorType.Attribute) {
            proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
            if (token.action === AttributeAction.Equals && token.name === "id") {
                // Prefer ID selectors (eg. #ID)
                proc = 9;
            }
            if (token.ignoreCase) {
                /*
                 * IgnoreCase adds some overhead, prefer "normal" token
                 * this is a binary operation, to ensure it's still an int
                 */
                proc >>= 1;
            }
        }
        else if (token.type === SelectorType.Pseudo) {
            if (!token.data) {
                proc = 3;
            }
            else if (token.name === "has" || token.name === "contains") {
                proc = 0; // Expensive in any case
            }
            else if (Array.isArray(token.data)) {
                // Eg. :matches, :not
                proc = Math.min(...token.data.map((d) => Math.min(...d.map(getProcedure))));
                // If we have traversals, try to avoid executing this selector
                if (proc < 0) {
                    proc = 0;
                }
            }
            else {
                proc = 2;
            }
        }
        return proc;
    }

    /**
     * All reserved characters in a regex, used for escaping.
     *
     * Taken from XRegExp, (c) 2007-2020 Steven Levithan under the MIT license
     * https://github.com/slevithan/xregexp/blob/95eeebeb8fac8754d54eafe2b4743661ac1cf028/src/xregexp.js#L794
     */
    const reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
    function escapeRegex(value) {
        return value.replace(reChars, "\\$&");
    }
    /**
     * Attributes that are case-insensitive in HTML.
     *
     * @private
     * @see https://html.spec.whatwg.org/multipage/semantics-other.html#case-sensitivity-of-selectors
     */
    const caseInsensitiveAttributes = new Set([
        "accept",
        "accept-charset",
        "align",
        "alink",
        "axis",
        "bgcolor",
        "charset",
        "checked",
        "clear",
        "codetype",
        "color",
        "compact",
        "declare",
        "defer",
        "dir",
        "direction",
        "disabled",
        "enctype",
        "face",
        "frame",
        "hreflang",
        "http-equiv",
        "lang",
        "language",
        "link",
        "media",
        "method",
        "multiple",
        "nohref",
        "noresize",
        "noshade",
        "nowrap",
        "readonly",
        "rel",
        "rev",
        "rules",
        "scope",
        "scrolling",
        "selected",
        "shape",
        "target",
        "text",
        "type",
        "valign",
        "valuetype",
        "vlink",
    ]);
    function shouldIgnoreCase(selector, options) {
        return typeof selector.ignoreCase === "boolean"
            ? selector.ignoreCase
            : selector.ignoreCase === "quirks"
                ? !!options.quirksMode
                : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
    }
    /**
     * Attribute selectors
     */
    const attributeRules = {
        equals(next, data, options) {
            const { adapter } = options;
            const { name } = data;
            let { value } = data;
            if (shouldIgnoreCase(data, options)) {
                value = value.toLowerCase();
                return (elem) => {
                    const attr = adapter.getAttributeValue(elem, name);
                    return (attr != null &&
                        attr.length === value.length &&
                        attr.toLowerCase() === value &&
                        next(elem));
                };
            }
            return (elem) => adapter.getAttributeValue(elem, name) === value && next(elem);
        },
        hyphen(next, data, options) {
            const { adapter } = options;
            const { name } = data;
            let { value } = data;
            const len = value.length;
            if (shouldIgnoreCase(data, options)) {
                value = value.toLowerCase();
                return function hyphenIC(elem) {
                    const attr = adapter.getAttributeValue(elem, name);
                    return (attr != null &&
                        (attr.length === len || attr.charAt(len) === "-") &&
                        attr.substr(0, len).toLowerCase() === value &&
                        next(elem));
                };
            }
            return function hyphen(elem) {
                const attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    (attr.length === len || attr.charAt(len) === "-") &&
                    attr.substr(0, len) === value &&
                    next(elem));
            };
        },
        element(next, data, options) {
            const { adapter } = options;
            const { name, value } = data;
            if (/\s/.test(value)) {
                return boolbase.falseFunc;
            }
            const regex = new RegExp(`(?:^|\\s)${escapeRegex(value)}(?:$|\\s)`, shouldIgnoreCase(data, options) ? "i" : "");
            return function element(elem) {
                const attr = adapter.getAttributeValue(elem, name);
                return (attr != null &&
                    attr.length >= value.length &&
                    regex.test(attr) &&
                    next(elem));
            };
        },
        exists(next, { name }, { adapter }) {
            return (elem) => adapter.hasAttrib(elem, name) && next(elem);
        },
        start(next, data, options) {
            const { adapter } = options;
            const { name } = data;
            let { value } = data;
            const len = value.length;
            if (len === 0) {
                return boolbase.falseFunc;
            }
            if (shouldIgnoreCase(data, options)) {
                value = value.toLowerCase();
                return (elem) => {
                    const attr = adapter.getAttributeValue(elem, name);
                    return (attr != null &&
                        attr.length >= len &&
                        attr.substr(0, len).toLowerCase() === value &&
                        next(elem));
                };
            }
            return (elem) => {
                var _a;
                return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) &&
                    next(elem);
            };
        },
        end(next, data, options) {
            const { adapter } = options;
            const { name } = data;
            let { value } = data;
            const len = -value.length;
            if (len === 0) {
                return boolbase.falseFunc;
            }
            if (shouldIgnoreCase(data, options)) {
                value = value.toLowerCase();
                return (elem) => {
                    var _a;
                    return ((_a = adapter
                        .getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
                };
            }
            return (elem) => {
                var _a;
                return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) &&
                    next(elem);
            };
        },
        any(next, data, options) {
            const { adapter } = options;
            const { name, value } = data;
            if (value === "") {
                return boolbase.falseFunc;
            }
            if (shouldIgnoreCase(data, options)) {
                const regex = new RegExp(escapeRegex(value), "i");
                return function anyIC(elem) {
                    const attr = adapter.getAttributeValue(elem, name);
                    return (attr != null &&
                        attr.length >= value.length &&
                        regex.test(attr) &&
                        next(elem));
                };
            }
            return (elem) => {
                var _a;
                return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) &&
                    next(elem);
            };
        },
        not(next, data, options) {
            const { adapter } = options;
            const { name } = data;
            let { value } = data;
            if (value === "") {
                return (elem) => !!adapter.getAttributeValue(elem, name) && next(elem);
            }
            else if (shouldIgnoreCase(data, options)) {
                value = value.toLowerCase();
                return (elem) => {
                    const attr = adapter.getAttributeValue(elem, name);
                    return ((attr == null ||
                        attr.length !== value.length ||
                        attr.toLowerCase() !== value) &&
                        next(elem));
                };
            }
            return (elem) => adapter.getAttributeValue(elem, name) !== value && next(elem);
        },
    };

    // Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo
    // Whitespace as per https://www.w3.org/TR/selectors-3/#lex is " \t\r\n\f"
    const whitespace = new Set([9, 10, 12, 13, 32]);
    const ZERO = "0".charCodeAt(0);
    const NINE = "9".charCodeAt(0);
    /**
     * Parses an expression.
     *
     * @throws An `Error` if parsing fails.
     * @returns An array containing the integer step size and the integer offset of the nth rule.
     * @example nthCheck.parse("2n+3"); // returns [2, 3]
     */
    function parse$3(formula) {
        formula = formula.trim().toLowerCase();
        if (formula === "even") {
            return [2, 0];
        }
        else if (formula === "odd") {
            return [2, 1];
        }
        // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?
        let idx = 0;
        let a = 0;
        let sign = readSign();
        let number = readNumber();
        if (idx < formula.length && formula.charAt(idx) === "n") {
            idx++;
            a = sign * (number !== null && number !== void 0 ? number : 1);
            skipWhitespace();
            if (idx < formula.length) {
                sign = readSign();
                skipWhitespace();
                number = readNumber();
            }
            else {
                sign = number = 0;
            }
        }
        // Throw if there is anything else
        if (number === null || idx < formula.length) {
            throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
        }
        return [a, sign * number];
        function readSign() {
            if (formula.charAt(idx) === "-") {
                idx++;
                return -1;
            }
            if (formula.charAt(idx) === "+") {
                idx++;
            }
            return 1;
        }
        function readNumber() {
            const start = idx;
            let value = 0;
            while (idx < formula.length &&
                formula.charCodeAt(idx) >= ZERO &&
                formula.charCodeAt(idx) <= NINE) {
                value = value * 10 + (formula.charCodeAt(idx) - ZERO);
                idx++;
            }
            // Return `null` if we didn't read anything.
            return idx === start ? null : value;
        }
        function skipWhitespace() {
            while (idx < formula.length &&
                whitespace.has(formula.charCodeAt(idx))) {
                idx++;
            }
        }
    }

    /**
     * Returns a function that checks if an elements index matches the given rule
     * highly optimized to return the fastest solution.
     *
     * @param parsed A tuple [a, b], as returned by `parse`.
     * @returns A highly optimized function that returns whether an index matches the nth-check.
     * @example
     *
     * ```js
     * const check = nthCheck.compile([2, 3]);
     *
     * check(0); // `false`
     * check(1); // `false`
     * check(2); // `true`
     * check(3); // `false`
     * check(4); // `true`
     * check(5); // `false`
     * check(6); // `true`
     * ```
     */
    function compile(parsed) {
        const a = parsed[0];
        // Subtract 1 from `b`, to convert from one- to zero-indexed.
        const b = parsed[1] - 1;
        /*
         * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.
         * Besides, the specification states that no elements are
         * matched when `a` and `b` are 0.
         *
         * `b < 0` here as we subtracted 1 from `b` above.
         */
        if (b < 0 && a <= 0)
            return boolbase.falseFunc;
        // When `a` is in the range -1..1, it matches any element (so only `b` is checked).
        if (a === -1)
            return (index) => index <= b;
        if (a === 0)
            return (index) => index === b;
        // When `b <= 0` and `a === 1`, they match any element.
        if (a === 1)
            return b < 0 ? boolbase.trueFunc : (index) => index >= b;
        /*
         * Otherwise, modulo can be used to check if there is a match.
         *
         * Modulo doesn't care about the sign, so let's use `a`s absolute value.
         */
        const absA = Math.abs(a);
        // Get `b mod a`, + a if this is negative.
        const bMod = ((b % absA) + absA) % absA;
        return a > 1
            ? (index) => index >= b && index % absA === bMod
            : (index) => index <= b && index % absA === bMod;
    }

    /**
     * Parses and compiles a formula to a highly optimized function.
     * Combination of {@link parse} and {@link compile}.
     *
     * If the formula doesn't match any elements,
     * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.
     * Otherwise, a function accepting an _index_ is returned, which returns
     * whether or not the passed _index_ matches the formula.
     *
     * Note: The nth-rule starts counting at `1`, the returned function at `0`.
     *
     * @param formula The formula to compile.
     * @example
     * const check = nthCheck("2n+3");
     *
     * check(0); // `false`
     * check(1); // `false`
     * check(2); // `true`
     * check(3); // `false`
     * check(4); // `true`
     * check(5); // `false`
     * check(6); // `true`
     */
    function nthCheck(formula) {
        return compile(parse$3(formula));
    }

    function getChildFunc(next, adapter) {
        return (elem) => {
            const parent = adapter.getParent(elem);
            return parent != null && adapter.isTag(parent) && next(elem);
        };
    }
    const filters = {
        contains(next, text, { adapter }) {
            return function contains(elem) {
                return next(elem) && adapter.getText(elem).includes(text);
            };
        },
        icontains(next, text, { adapter }) {
            const itext = text.toLowerCase();
            return function icontains(elem) {
                return (next(elem) &&
                    adapter.getText(elem).toLowerCase().includes(itext));
            };
        },
        // Location specific methods
        "nth-child"(next, rule, { adapter, equals }) {
            const func = nthCheck(rule);
            if (func === boolbase.falseFunc)
                return boolbase.falseFunc;
            if (func === boolbase.trueFunc)
                return getChildFunc(next, adapter);
            return function nthChild(elem) {
                const siblings = adapter.getSiblings(elem);
                let pos = 0;
                for (let i = 0; i < siblings.length; i++) {
                    if (equals(elem, siblings[i]))
                        break;
                    if (adapter.isTag(siblings[i])) {
                        pos++;
                    }
                }
                return func(pos) && next(elem);
            };
        },
        "nth-last-child"(next, rule, { adapter, equals }) {
            const func = nthCheck(rule);
            if (func === boolbase.falseFunc)
                return boolbase.falseFunc;
            if (func === boolbase.trueFunc)
                return getChildFunc(next, adapter);
            return function nthLastChild(elem) {
                const siblings = adapter.getSiblings(elem);
                let pos = 0;
                for (let i = siblings.length - 1; i >= 0; i--) {
                    if (equals(elem, siblings[i]))
                        break;
                    if (adapter.isTag(siblings[i])) {
                        pos++;
                    }
                }
                return func(pos) && next(elem);
            };
        },
        "nth-of-type"(next, rule, { adapter, equals }) {
            const func = nthCheck(rule);
            if (func === boolbase.falseFunc)
                return boolbase.falseFunc;
            if (func === boolbase.trueFunc)
                return getChildFunc(next, adapter);
            return function nthOfType(elem) {
                const siblings = adapter.getSiblings(elem);
                let pos = 0;
                for (let i = 0; i < siblings.length; i++) {
                    const currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling) &&
                        adapter.getName(currentSibling) === adapter.getName(elem)) {
                        pos++;
                    }
                }
                return func(pos) && next(elem);
            };
        },
        "nth-last-of-type"(next, rule, { adapter, equals }) {
            const func = nthCheck(rule);
            if (func === boolbase.falseFunc)
                return boolbase.falseFunc;
            if (func === boolbase.trueFunc)
                return getChildFunc(next, adapter);
            return function nthLastOfType(elem) {
                const siblings = adapter.getSiblings(elem);
                let pos = 0;
                for (let i = siblings.length - 1; i >= 0; i--) {
                    const currentSibling = siblings[i];
                    if (equals(elem, currentSibling))
                        break;
                    if (adapter.isTag(currentSibling) &&
                        adapter.getName(currentSibling) === adapter.getName(elem)) {
                        pos++;
                    }
                }
                return func(pos) && next(elem);
            };
        },
        // TODO determine the actual root element
        root(next, _rule, { adapter }) {
            return (elem) => {
                const parent = adapter.getParent(elem);
                return (parent == null || !adapter.isTag(parent)) && next(elem);
            };
        },
        scope(next, rule, options, context) {
            const { equals } = options;
            if (!context || context.length === 0) {
                // Equivalent to :root
                return filters["root"](next, rule, options);
            }
            if (context.length === 1) {
                // NOTE: can't be unpacked, as :has uses this for side-effects
                return (elem) => equals(context[0], elem) && next(elem);
            }
            return (elem) => context.includes(elem) && next(elem);
        },
        hover: dynamicStatePseudo("isHovered"),
        visited: dynamicStatePseudo("isVisited"),
        active: dynamicStatePseudo("isActive"),
    };
    /**
     * Dynamic state pseudos. These depend on optional Adapter methods.
     *
     * @param name The name of the adapter method to call.
     * @returns Pseudo for the `filters` object.
     */
    function dynamicStatePseudo(name) {
        return function dynamicPseudo(next, _rule, { adapter }) {
            const func = adapter[name];
            if (typeof func !== "function") {
                return boolbase.falseFunc;
            }
            return function active(elem) {
                return func(elem) && next(elem);
            };
        };
    }

    // While filters are precompiled, pseudos get called when they are needed
    const pseudos = {
        empty(elem, { adapter }) {
            return !adapter.getChildren(elem).some((elem) => 
            // FIXME: `getText` call is potentially expensive.
            adapter.isTag(elem) || adapter.getText(elem) !== "");
        },
        "first-child"(elem, { adapter, equals }) {
            if (adapter.prevElementSibling) {
                return adapter.prevElementSibling(elem) == null;
            }
            const firstChild = adapter
                .getSiblings(elem)
                .find((elem) => adapter.isTag(elem));
            return firstChild != null && equals(elem, firstChild);
        },
        "last-child"(elem, { adapter, equals }) {
            const siblings = adapter.getSiblings(elem);
            for (let i = siblings.length - 1; i >= 0; i--) {
                if (equals(elem, siblings[i]))
                    return true;
                if (adapter.isTag(siblings[i]))
                    break;
            }
            return false;
        },
        "first-of-type"(elem, { adapter, equals }) {
            const siblings = adapter.getSiblings(elem);
            const elemName = adapter.getName(elem);
            for (let i = 0; i < siblings.length; i++) {
                const currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                    return true;
                if (adapter.isTag(currentSibling) &&
                    adapter.getName(currentSibling) === elemName) {
                    break;
                }
            }
            return false;
        },
        "last-of-type"(elem, { adapter, equals }) {
            const siblings = adapter.getSiblings(elem);
            const elemName = adapter.getName(elem);
            for (let i = siblings.length - 1; i >= 0; i--) {
                const currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                    return true;
                if (adapter.isTag(currentSibling) &&
                    adapter.getName(currentSibling) === elemName) {
                    break;
                }
            }
            return false;
        },
        "only-of-type"(elem, { adapter, equals }) {
            const elemName = adapter.getName(elem);
            return adapter
                .getSiblings(elem)
                .every((sibling) => equals(elem, sibling) ||
                !adapter.isTag(sibling) ||
                adapter.getName(sibling) !== elemName);
        },
        "only-child"(elem, { adapter, equals }) {
            return adapter
                .getSiblings(elem)
                .every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling));
        },
    };
    function verifyPseudoArgs(func, name, subselect, argIndex) {
        if (subselect === null) {
            if (func.length > argIndex) {
                throw new Error(`Pseudo-class :${name} requires an argument`);
            }
        }
        else if (func.length === argIndex) {
            throw new Error(`Pseudo-class :${name} doesn't have any arguments`);
        }
    }

    /**
     * Aliases are pseudos that are expressed as selectors.
     */
    const aliases = {
        // Links
        "any-link": ":is(a, area, link)[href]",
        link: ":any-link:not(:visited)",
        // Forms
        // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
        disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
        enabled: ":not(:disabled)",
        checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
        required: ":is(input, select, textarea)[required]",
        optional: ":is(input, select, textarea):not([required])",
        // JQuery extensions
        // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
        selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
        checkbox: "[type=checkbox]",
        file: "[type=file]",
        password: "[type=password]",
        radio: "[type=radio]",
        reset: "[type=reset]",
        image: "[type=image]",
        submit: "[type=submit]",
        parent: ":not(:empty)",
        header: ":is(h1, h2, h3, h4, h5, h6)",
        button: ":is(button, input[type=button])",
        input: ":is(input, textarea, select, button)",
        text: "input:is(:not([type!='']), [type=text])",
    };

    /** Used as a placeholder for :has. Will be replaced with the actual element. */
    const PLACEHOLDER_ELEMENT = {};
    function ensureIsTag(next, adapter) {
        if (next === boolbase.falseFunc)
            return boolbase.falseFunc;
        return (elem) => adapter.isTag(elem) && next(elem);
    }
    function getNextSiblings(elem, adapter) {
        const siblings = adapter.getSiblings(elem);
        if (siblings.length <= 1)
            return [];
        const elemIndex = siblings.indexOf(elem);
        if (elemIndex < 0 || elemIndex === siblings.length - 1)
            return [];
        return siblings.slice(elemIndex + 1).filter(adapter.isTag);
    }
    function copyOptions(options) {
        // Not copied: context, rootFunc
        return {
            xmlMode: !!options.xmlMode,
            lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
            lowerCaseTags: !!options.lowerCaseTags,
            quirksMode: !!options.quirksMode,
            cacheResults: !!options.cacheResults,
            pseudos: options.pseudos,
            adapter: options.adapter,
            equals: options.equals,
        };
    }
    const is$2 = (next, token, options, context, compileToken) => {
        const func = compileToken(token, copyOptions(options), context);
        return func === boolbase.trueFunc
            ? next
            : func === boolbase.falseFunc
                ? boolbase.falseFunc
                : (elem) => func(elem) && next(elem);
    };
    /*
     * :not, :has, :is, :matches and :where have to compile selectors
     * doing this in src/pseudos.ts would lead to circular dependencies,
     * so we add them here
     */
    const subselects = {
        is: is$2,
        /**
         * `:matches` and `:where` are aliases for `:is`.
         */
        matches: is$2,
        where: is$2,
        not(next, token, options, context, compileToken) {
            const func = compileToken(token, copyOptions(options), context);
            return func === boolbase.falseFunc
                ? next
                : func === boolbase.trueFunc
                    ? boolbase.falseFunc
                    : (elem) => !func(elem) && next(elem);
        },
        has(next, subselect, options, _context, compileToken) {
            const { adapter } = options;
            const opts = copyOptions(options);
            opts.relativeSelector = true;
            const context = subselect.some((s) => s.some(isTraversal))
                ? // Used as a placeholder. Will be replaced with the actual element.
                    [PLACEHOLDER_ELEMENT]
                : undefined;
            const compiled = compileToken(subselect, opts, context);
            if (compiled === boolbase.falseFunc)
                return boolbase.falseFunc;
            const hasElement = ensureIsTag(compiled, adapter);
            // If `compiled` is `trueFunc`, we can skip this.
            if (context && compiled !== boolbase.trueFunc) {
                /*
                 * `shouldTestNextSiblings` will only be true if the query starts with
                 * a traversal (sibling or adjacent). That means we will always have a context.
                 */
                const { shouldTestNextSiblings = false } = compiled;
                return (elem) => {
                    if (!next(elem))
                        return false;
                    context[0] = elem;
                    const childs = adapter.getChildren(elem);
                    const nextElements = shouldTestNextSiblings
                        ? [...childs, ...getNextSiblings(elem, adapter)]
                        : childs;
                    return adapter.existsOne(hasElement, nextElements);
                };
            }
            return (elem) => next(elem) &&
                adapter.existsOne(hasElement, adapter.getChildren(elem));
        },
    };

    function compilePseudoSelector(next, selector, options, context, compileToken) {
        var _a;
        const { name, data } = selector;
        if (Array.isArray(data)) {
            if (!(name in subselects)) {
                throw new Error(`Unknown pseudo-class :${name}(${data})`);
            }
            return subselects[name](next, data, options, context, compileToken);
        }
        const userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];
        const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name];
        if (typeof stringPseudo === "string") {
            if (data != null) {
                throw new Error(`Pseudo ${name} doesn't have any arguments`);
            }
            // The alias has to be parsed here, to make sure options are respected.
            const alias = parse$4(stringPseudo);
            return subselects["is"](next, alias, options, context, compileToken);
        }
        if (typeof userPseudo === "function") {
            verifyPseudoArgs(userPseudo, name, data, 1);
            return (elem) => userPseudo(elem, data) && next(elem);
        }
        if (name in filters) {
            return filters[name](next, data, options, context);
        }
        if (name in pseudos) {
            const pseudo = pseudos[name];
            verifyPseudoArgs(pseudo, name, data, 2);
            return (elem) => pseudo(elem, options, data) && next(elem);
        }
        throw new Error(`Unknown pseudo-class :${name}`);
    }

    function getElementParent(node, adapter) {
        const parent = adapter.getParent(node);
        if (parent && adapter.isTag(parent)) {
            return parent;
        }
        return null;
    }
    /*
     * All available rules
     */
    function compileGeneralSelector(next, selector, options, context, compileToken) {
        const { adapter, equals } = options;
        switch (selector.type) {
            case SelectorType.PseudoElement: {
                throw new Error("Pseudo-elements are not supported by css-select");
            }
            case SelectorType.ColumnCombinator: {
                throw new Error("Column combinators are not yet supported by css-select");
            }
            case SelectorType.Attribute: {
                if (selector.namespace != null) {
                    throw new Error("Namespaced attributes are not yet supported by css-select");
                }
                if (!options.xmlMode || options.lowerCaseAttributeNames) {
                    selector.name = selector.name.toLowerCase();
                }
                return attributeRules[selector.action](next, selector, options);
            }
            case SelectorType.Pseudo: {
                return compilePseudoSelector(next, selector, options, context, compileToken);
            }
            // Tags
            case SelectorType.Tag: {
                if (selector.namespace != null) {
                    throw new Error("Namespaced tag names are not yet supported by css-select");
                }
                let { name } = selector;
                if (!options.xmlMode || options.lowerCaseTags) {
                    name = name.toLowerCase();
                }
                return function tag(elem) {
                    return adapter.getName(elem) === name && next(elem);
                };
            }
            // Traversal
            case SelectorType.Descendant: {
                if (options.cacheResults === false ||
                    typeof WeakSet === "undefined") {
                    return function descendant(elem) {
                        let current = elem;
                        while ((current = getElementParent(current, adapter))) {
                            if (next(current)) {
                                return true;
                            }
                        }
                        return false;
                    };
                }
                // @ts-expect-error `ElementNode` is not extending object
                const isFalseCache = new WeakSet();
                return function cachedDescendant(elem) {
                    let current = elem;
                    while ((current = getElementParent(current, adapter))) {
                        if (!isFalseCache.has(current)) {
                            if (adapter.isTag(current) && next(current)) {
                                return true;
                            }
                            isFalseCache.add(current);
                        }
                    }
                    return false;
                };
            }
            case "_flexibleDescendant": {
                // Include element itself, only used while querying an array
                return function flexibleDescendant(elem) {
                    let current = elem;
                    do {
                        if (next(current))
                            return true;
                    } while ((current = getElementParent(current, adapter)));
                    return false;
                };
            }
            case SelectorType.Parent: {
                return function parent(elem) {
                    return adapter
                        .getChildren(elem)
                        .some((elem) => adapter.isTag(elem) && next(elem));
                };
            }
            case SelectorType.Child: {
                return function child(elem) {
                    const parent = adapter.getParent(elem);
                    return parent != null && adapter.isTag(parent) && next(parent);
                };
            }
            case SelectorType.Sibling: {
                return function sibling(elem) {
                    const siblings = adapter.getSiblings(elem);
                    for (let i = 0; i < siblings.length; i++) {
                        const currentSibling = siblings[i];
                        if (equals(elem, currentSibling))
                            break;
                        if (adapter.isTag(currentSibling) && next(currentSibling)) {
                            return true;
                        }
                    }
                    return false;
                };
            }
            case SelectorType.Adjacent: {
                if (adapter.prevElementSibling) {
                    return function adjacent(elem) {
                        const previous = adapter.prevElementSibling(elem);
                        return previous != null && next(previous);
                    };
                }
                return function adjacent(elem) {
                    const siblings = adapter.getSiblings(elem);
                    let lastElement;
                    for (let i = 0; i < siblings.length; i++) {
                        const currentSibling = siblings[i];
                        if (equals(elem, currentSibling))
                            break;
                        if (adapter.isTag(currentSibling)) {
                            lastElement = currentSibling;
                        }
                    }
                    return !!lastElement && next(lastElement);
                };
            }
            case SelectorType.Universal: {
                if (selector.namespace != null && selector.namespace !== "*") {
                    throw new Error("Namespaced universal selectors are not yet supported by css-select");
                }
                return next;
            }
        }
    }

    function includesScopePseudo(t) {
        return (t.type === SelectorType.Pseudo &&
            (t.name === "scope" ||
                (Array.isArray(t.data) &&
                    t.data.some((data) => data.some(includesScopePseudo)))));
    }
    const DESCENDANT_TOKEN = { type: SelectorType.Descendant };
    const FLEXIBLE_DESCENDANT_TOKEN = {
        type: "_flexibleDescendant",
    };
    const SCOPE_TOKEN = {
        type: SelectorType.Pseudo,
        name: "scope",
        data: null,
    };
    /*
     * CSS 4 Spec (Draft): 3.4.1. Absolutizing a Relative Selector
     * http://www.w3.org/TR/selectors4/#absolutizing
     */
    function absolutize(token, { adapter }, context) {
        // TODO Use better check if the context is a document
        const hasContext = !!(context === null || context === void 0 ? void 0 : context.every((e) => {
            const parent = adapter.isTag(e) && adapter.getParent(e);
            return e === PLACEHOLDER_ELEMENT || (parent && adapter.isTag(parent));
        }));
        for (const t of token) {
            if (t.length > 0 &&
                isTraversal(t[0]) &&
                t[0].type !== SelectorType.Descendant) ;
            else if (hasContext && !t.some(includesScopePseudo)) {
                t.unshift(DESCENDANT_TOKEN);
            }
            else {
                continue;
            }
            t.unshift(SCOPE_TOKEN);
        }
    }
    function compileToken(token, options, context) {
        var _a;
        token.forEach(sortByProcedure);
        context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
        const isArrayContext = Array.isArray(context);
        const finalContext = context && (Array.isArray(context) ? context : [context]);
        // Check if the selector is relative
        if (options.relativeSelector !== false) {
            absolutize(token, options, finalContext);
        }
        else if (token.some((t) => t.length > 0 && isTraversal(t[0]))) {
            throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
        }
        let shouldTestNextSiblings = false;
        const query = token
            .map((rules) => {
            if (rules.length >= 2) {
                const [first, second] = rules;
                if (first.type !== SelectorType.Pseudo ||
                    first.name !== "scope") ;
                else if (isArrayContext &&
                    second.type === SelectorType.Descendant) {
                    rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
                }
                else if (second.type === SelectorType.Adjacent ||
                    second.type === SelectorType.Sibling) {
                    shouldTestNextSiblings = true;
                }
            }
            return compileRules(rules, options, finalContext);
        })
            .reduce(reduceRules, boolbase.falseFunc);
        query.shouldTestNextSiblings = shouldTestNextSiblings;
        return query;
    }
    function compileRules(rules, options, context) {
        var _a;
        return rules.reduce((previous, rule) => previous === boolbase.falseFunc
            ? boolbase.falseFunc
            : compileGeneralSelector(previous, rule, options, context, compileToken), (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase.trueFunc);
    }
    function reduceRules(a, b) {
        if (b === boolbase.falseFunc || a === boolbase.trueFunc) {
            return a;
        }
        if (a === boolbase.falseFunc || b === boolbase.trueFunc) {
            return b;
        }
        return function combine(elem) {
            return a(elem) || b(elem);
        };
    }

    const defaultEquals = (a, b) => a === b;
    const defaultOptions = {
        adapter: DomUtils,
        equals: defaultEquals,
    };
    function convertOptionFormats(options) {
        var _a, _b, _c, _d;
        /*
         * We force one format of options to the other one.
         */
        // @ts-expect-error Default options may have incompatible `Node` / `ElementNode`.
        const opts = options !== null && options !== void 0 ? options : defaultOptions;
        // @ts-expect-error Same as above.
        (_a = opts.adapter) !== null && _a !== void 0 ? _a : (opts.adapter = DomUtils);
        // @ts-expect-error `equals` does not exist on `Options`
        (_b = opts.equals) !== null && _b !== void 0 ? _b : (opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals);
        return opts;
    }
    function wrapCompile(func) {
        return function addAdapter(selector, options, context) {
            const opts = convertOptionFormats(options);
            return func(selector, opts, context);
        };
    }
    const _compileToken = wrapCompile(compileToken);
    function prepareContext(elems, adapter, shouldTestNextSiblings = false) {
        /*
         * Add siblings if the query requires them.
         * See https://github.com/fb55/css-select/pull/43#issuecomment-225414692
         */
        if (shouldTestNextSiblings) {
            elems = appendNextSiblings(elems, adapter);
        }
        return Array.isArray(elems)
            ? adapter.removeSubsets(elems)
            : adapter.getChildren(elems);
    }
    function appendNextSiblings(elem, adapter) {
        // Order matters because jQuery seems to check the children before the siblings
        const elems = Array.isArray(elem) ? elem.slice(0) : [elem];
        const elemsLength = elems.length;
        for (let i = 0; i < elemsLength; i++) {
            const nextSiblings = getNextSiblings(elems[i], adapter);
            elems.push(...nextSiblings);
        }
        return elems;
    }

    const filterNames = new Set([
        "first",
        "last",
        "eq",
        "gt",
        "nth",
        "lt",
        "even",
        "odd",
    ]);
    function isFilter(s) {
        if (s.type !== "pseudo")
            return false;
        if (filterNames.has(s.name))
            return true;
        if (s.name === "not" && Array.isArray(s.data)) {
            // Only consider `:not` with embedded filters
            return s.data.some((s) => s.some(isFilter));
        }
        return false;
    }
    function getLimit(filter, data, partLimit) {
        const num = data != null ? parseInt(data, 10) : NaN;
        switch (filter) {
            case "first":
                return 1;
            case "nth":
            case "eq":
                return isFinite(num) ? (num >= 0 ? num + 1 : Infinity) : 0;
            case "lt":
                return isFinite(num)
                    ? num >= 0
                        ? Math.min(num, partLimit)
                        : Infinity
                    : 0;
            case "gt":
                return isFinite(num) ? Infinity : 0;
            case "odd":
                return 2 * partLimit;
            case "even":
                return 2 * partLimit - 1;
            case "last":
            case "not":
                return Infinity;
        }
    }

    function getDocumentRoot(node) {
        while (node.parent)
            node = node.parent;
        return node;
    }
    function groupSelectors(selectors) {
        const filteredSelectors = [];
        const plainSelectors = [];
        for (const selector of selectors) {
            if (selector.some(isFilter)) {
                filteredSelectors.push(selector);
            }
            else {
                plainSelectors.push(selector);
            }
        }
        return [plainSelectors, filteredSelectors];
    }

    const UNIVERSAL_SELECTOR = {
        type: SelectorType.Universal,
        namespace: null,
    };
    const SCOPE_PSEUDO = {
        type: SelectorType.Pseudo,
        name: "scope",
        data: null,
    };
    function is$1(element, selector, options = {}) {
        return some([element], selector, options);
    }
    function some(elements, selector, options = {}) {
        if (typeof selector === "function")
            return elements.some(selector);
        const [plain, filtered] = groupSelectors(parse$4(selector));
        return ((plain.length > 0 && elements.some(_compileToken(plain, options))) ||
            filtered.some((sel) => filterBySelector(sel, elements, options).length > 0));
    }
    function filterByPosition(filter, elems, data, options) {
        const num = typeof data === "string" ? parseInt(data, 10) : NaN;
        switch (filter) {
            case "first":
            case "lt":
                // Already done in `getLimit`
                return elems;
            case "last":
                return elems.length > 0 ? [elems[elems.length - 1]] : elems;
            case "nth":
            case "eq":
                return isFinite(num) && Math.abs(num) < elems.length
                    ? [num < 0 ? elems[elems.length + num] : elems[num]]
                    : [];
            case "gt":
                return isFinite(num) ? elems.slice(num + 1) : [];
            case "even":
                return elems.filter((_, i) => i % 2 === 0);
            case "odd":
                return elems.filter((_, i) => i % 2 === 1);
            case "not": {
                const filtered = new Set(filterParsed(data, elems, options));
                return elems.filter((e) => !filtered.has(e));
            }
        }
    }
    function filter$1(selector, elements, options = {}) {
        return filterParsed(parse$4(selector), elements, options);
    }
    /**
     * Filter a set of elements by a selector.
     *
     * Will return elements in the original order.
     *
     * @param selector Selector to filter by.
     * @param elements Elements to filter.
     * @param options Options for selector.
     */
    function filterParsed(selector, elements, options) {
        if (elements.length === 0)
            return [];
        const [plainSelectors, filteredSelectors] = groupSelectors(selector);
        let found;
        if (plainSelectors.length) {
            const filtered = filterElements(elements, plainSelectors, options);
            // If there are no filters, just return
            if (filteredSelectors.length === 0) {
                return filtered;
            }
            // Otherwise, we have to do some filtering
            if (filtered.length) {
                found = new Set(filtered);
            }
        }
        for (let i = 0; i < filteredSelectors.length && (found === null || found === void 0 ? void 0 : found.size) !== elements.length; i++) {
            const filteredSelector = filteredSelectors[i];
            const missing = found
                ? elements.filter((e) => isTag(e) && !found.has(e))
                : elements;
            if (missing.length === 0)
                break;
            const filtered = filterBySelector(filteredSelector, elements, options);
            if (filtered.length) {
                if (!found) {
                    /*
                     * If we haven't found anything before the last selector,
                     * just return what we found now.
                     */
                    if (i === filteredSelectors.length - 1) {
                        return filtered;
                    }
                    found = new Set(filtered);
                }
                else {
                    filtered.forEach((el) => found.add(el));
                }
            }
        }
        return typeof found !== "undefined"
            ? (found.size === elements.length
                ? elements
                : // Filter elements to preserve order
                    elements.filter((el) => found.has(el)))
            : [];
    }
    function filterBySelector(selector, elements, options) {
        var _a;
        if (selector.some(isTraversal$1)) {
            /*
             * Get root node, run selector with the scope
             * set to all of our nodes.
             */
            const root = (_a = options.root) !== null && _a !== void 0 ? _a : getDocumentRoot(elements[0]);
            const opts = { ...options, context: elements, relativeSelector: false };
            selector.push(SCOPE_PSEUDO);
            return findFilterElements(root, selector, opts, true, elements.length);
        }
        // Performance optimization: If we don't have to traverse, just filter set.
        return findFilterElements(elements, selector, options, false, elements.length);
    }
    function select(selector, root, options = {}, limit = Infinity) {
        if (typeof selector === "function") {
            return find$1(root, selector);
        }
        const [plain, filtered] = groupSelectors(parse$4(selector));
        const results = filtered.map((sel) => findFilterElements(root, sel, options, true, limit));
        // Plain selectors can be queried in a single go
        if (plain.length) {
            results.push(findElements(root, plain, options, limit));
        }
        if (results.length === 0) {
            return [];
        }
        // If there was only a single selector, just return the result
        if (results.length === 1) {
            return results[0];
        }
        // Sort results, filtering for duplicates
        return uniqueSort(results.reduce((a, b) => [...a, ...b]));
    }
    /**
     *
     * @param root Element(s) to search from.
     * @param selector Selector to look for.
     * @param options Options for querying.
     * @param queryForSelector Query multiple levels deep for the initial selector, even if it doesn't contain a traversal.
     */
    function findFilterElements(root, selector, options, queryForSelector, totalLimit) {
        const filterIndex = selector.findIndex(isFilter);
        const sub = selector.slice(0, filterIndex);
        const filter = selector[filterIndex];
        // If we are at the end of the selector, we can limit the number of elements to retrieve.
        const partLimit = selector.length - 1 === filterIndex ? totalLimit : Infinity;
        /*
         * Set the number of elements to retrieve.
         * Eg. for :first, we only have to get a single element.
         */
        const limit = getLimit(filter.name, filter.data, partLimit);
        if (limit === 0)
            return [];
        /*
         * Skip `findElements` call if our selector starts with a positional
         * pseudo.
         */
        const elemsNoLimit = sub.length === 0 && !Array.isArray(root)
            ? getChildren(root).filter(isTag)
            : sub.length === 0
                ? (Array.isArray(root) ? root : [root]).filter(isTag)
                : queryForSelector || sub.some(isTraversal$1)
                    ? findElements(root, [sub], options, limit)
                    : filterElements(root, [sub], options);
        const elems = elemsNoLimit.slice(0, limit);
        let result = filterByPosition(filter.name, elems, filter.data, options);
        if (result.length === 0 || selector.length === filterIndex + 1) {
            return result;
        }
        const remainingSelector = selector.slice(filterIndex + 1);
        const remainingHasTraversal = remainingSelector.some(isTraversal$1);
        if (remainingHasTraversal) {
            if (isTraversal$1(remainingSelector[0])) {
                const { type } = remainingSelector[0];
                if (type === SelectorType.Sibling ||
                    type === SelectorType.Adjacent) {
                    // If we have a sibling traversal, we need to also look at the siblings.
                    result = prepareContext(result, DomUtils, true);
                }
                // Avoid a traversal-first selector error.
                remainingSelector.unshift(UNIVERSAL_SELECTOR);
            }
            options = {
                ...options,
                // Avoid absolutizing the selector
                relativeSelector: false,
                /*
                 * Add a custom root func, to make sure traversals don't match elements
                 * that aren't a part of the considered tree.
                 */
                rootFunc: (el) => result.includes(el),
            };
        }
        else if (options.rootFunc && options.rootFunc !== boolbase.trueFunc) {
            options = { ...options, rootFunc: boolbase.trueFunc };
        }
        /*
         * If we have another filter, recursively call `findFilterElements`,
         * with the `recursive` flag disabled. We only have to look for more
         * elements when we see a traversal.
         *
         * Otherwise,
         */
        return remainingSelector.some(isFilter)
            ? findFilterElements(result, remainingSelector, options, false, totalLimit)
            : remainingHasTraversal
                ? // Query existing elements to resolve traversal.
                    findElements(result, [remainingSelector], options, totalLimit)
                : // If we don't have any more traversals, simply filter elements.
                    filterElements(result, [remainingSelector], options);
    }
    function findElements(root, sel, options, limit) {
        const query = _compileToken(sel, options, root);
        return find$1(root, query, limit);
    }
    function find$1(root, query, limit = Infinity) {
        const elems = prepareContext(root, DomUtils, query.shouldTestNextSiblings);
        return find$2((node) => isTag(node) && query(node), elems, true, limit);
    }
    function filterElements(elements, sel, options) {
        const els = (Array.isArray(elements) ? elements : [elements]).filter(isTag);
        if (els.length === 0)
            return els;
        const query = _compileToken(sel, options);
        return query === boolbase.trueFunc ? els : els.filter(query);
    }

    /**
     * Methods for traversing the DOM structure.
     *
     * @module cheerio/traversing
     */
    const reSiblingSelector = /^\s*[~+]/;
    /**
     * Get the descendants of each element in the current set of matched elements,
     * filtered by a selector, jQuery object, or element.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('#fruits').find('li').length;
     * //=> 3
     * $('#fruits').find($('.apple')).length;
     * //=> 1
     * ```
     *
     * @param selectorOrHaystack - Element to look for.
     * @returns The found elements.
     * @see {@link https://api.jquery.com/find/}
     */
    function find(selectorOrHaystack) {
        var _a;
        if (!selectorOrHaystack) {
            return this._make([]);
        }
        const context = this.toArray();
        if (typeof selectorOrHaystack !== 'string') {
            const haystack = isCheerio(selectorOrHaystack)
                ? selectorOrHaystack.toArray()
                : [selectorOrHaystack];
            return this._make(haystack.filter((elem) => context.some((node) => contains(node, elem))));
        }
        const elems = reSiblingSelector.test(selectorOrHaystack)
            ? context
            : this.children().toArray();
        const options = {
            context,
            root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],
            // Pass options that are recognized by `cheerio-select`
            xmlMode: this.options.xmlMode,
            lowerCaseTags: this.options.lowerCaseTags,
            lowerCaseAttributeNames: this.options.lowerCaseAttributeNames,
            pseudos: this.options.pseudos,
            quirksMode: this.options.quirksMode,
        };
        return this._make(select(selectorOrHaystack, elems, options));
    }
    /**
     * Creates a matcher, using a particular mapping function. Matchers provide a
     * function that finds elements using a generating function, supporting filtering.
     *
     * @private
     * @param matchMap - Mapping function.
     * @returns - Function for wrapping generating functions.
     */
    function _getMatcher(matchMap) {
        return function (fn, ...postFns) {
            return function (selector) {
                var _a;
                let matched = matchMap(fn, this);
                if (selector) {
                    matched = filterArray(matched, selector, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]);
                }
                return this._make(
                // Post processing is only necessary if there is more than one element.
                this.length > 1 && matched.length > 1
                    ? postFns.reduce((elems, fn) => fn(elems), matched)
                    : matched);
            };
        };
    }
    /** Matcher that adds multiple elements for each entry in the input. */
    const _matcher = _getMatcher((fn, elems) => {
        const ret = [];
        for (let i = 0; i < elems.length; i++) {
            const value = fn(elems[i]);
            ret.push(value);
        }
        return new Array().concat(...ret);
    });
    /** Matcher that adds at most one element for each entry in the input. */
    const _singleMatcher = _getMatcher((fn, elems) => {
        const ret = [];
        for (let i = 0; i < elems.length; i++) {
            const value = fn(elems[i]);
            if (value !== null) {
                ret.push(value);
            }
        }
        return ret;
    });
    /**
     * Matcher that supports traversing until a condition is met.
     *
     * @returns A function usable for `*Until` methods.
     */
    function _matchUntil(nextElem, ...postFns) {
        // We use a variable here that is used from within the matcher.
        let matches = null;
        const innerMatcher = _getMatcher((nextElem, elems) => {
            const matched = [];
            domEach(elems, (elem) => {
                for (let next; (next = nextElem(elem)); elem = next) {
                    // FIXME: `matched` might contain duplicates here and the index is too large.
                    if (matches === null || matches === void 0 ? void 0 : matches(next, matched.length))
                        break;
                    matched.push(next);
                }
            });
            return matched;
        })(nextElem, ...postFns);
        return function (selector, filterSelector) {
            // Override `matches` variable with the new target.
            matches =
                typeof selector === 'string'
                    ? (elem) => is$1(elem, selector, this.options)
                    : selector
                        ? getFilterFn(selector)
                        : null;
            const ret = innerMatcher.call(this, filterSelector);
            // Set `matches` to `null`, so we don't waste memory.
            matches = null;
            return ret;
        };
    }
    function _removeDuplicates(elems) {
        return Array.from(new Set(elems));
    }
    /**
     * Get the parent of each element in the current set of matched elements,
     * optionally filtered by a selector.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.pear').parent().attr('id');
     * //=> fruits
     * ```
     *
     * @param selector - If specified filter for parent.
     * @returns The parents.
     * @see {@link https://api.jquery.com/parent/}
     */
    const parent = _singleMatcher(({ parent }) => (parent && !isDocument(parent) ? parent : null), _removeDuplicates);
    /**
     * Get a set of parents filtered by `selector` of each element in the current
     * set of match elements.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.orange').parents().length;
     * //=> 2
     * $('.orange').parents('#fruits').length;
     * //=> 1
     * ```
     *
     * @param selector - If specified filter for parents.
     * @returns The parents.
     * @see {@link https://api.jquery.com/parents/}
     */
    const parents = _matcher((elem) => {
        const matched = [];
        while (elem.parent && !isDocument(elem.parent)) {
            matched.push(elem.parent);
            elem = elem.parent;
        }
        return matched;
    }, uniqueSort, (elems) => elems.reverse());
    /**
     * Get the ancestors of each element in the current set of matched elements, up
     * to but not including the element matched by the selector, DOM node, or cheerio object.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.orange').parentsUntil('#food').length;
     * //=> 1
     * ```
     *
     * @param selector - Selector for element to stop at.
     * @param filterSelector - Optional filter for parents.
     * @returns The parents.
     * @see {@link https://api.jquery.com/parentsUntil/}
     */
    const parentsUntil = _matchUntil(({ parent }) => (parent && !isDocument(parent) ? parent : null), uniqueSort, (elems) => elems.reverse());
    /**
     * For each element in the set, get the first element that matches the selector
     * by testing the element itself and traversing up through its ancestors in the DOM tree.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.orange').closest();
     * //=> []
     *
     * $('.orange').closest('.apple');
     * // => []
     *
     * $('.orange').closest('li');
     * //=> [<li class="orange">Orange</li>]
     *
     * $('.orange').closest('#fruits');
     * //=> [<ul id="fruits"> ... </ul>]
     * ```
     *
     * @param selector - Selector for the element to find.
     * @returns The closest nodes.
     * @see {@link https://api.jquery.com/closest/}
     */
    function closest(selector) {
        var _a;
        const set = [];
        if (!selector) {
            return this._make(set);
        }
        const selectOpts = {
            xmlMode: this.options.xmlMode,
            root: (_a = this._root) === null || _a === void 0 ? void 0 : _a[0],
        };
        const selectFn = typeof selector === 'string'
            ? (elem) => is$1(elem, selector, selectOpts)
            : getFilterFn(selector);
        domEach(this, (elem) => {
            while (elem && isTag(elem)) {
                if (selectFn(elem, 0)) {
                    // Do not add duplicate elements to the set
                    if (!set.includes(elem)) {
                        set.push(elem);
                    }
                    break;
                }
                elem = elem.parent;
            }
        });
        return this._make(set);
    }
    /**
     * Gets the next sibling of the first selected element, optionally filtered by a selector.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.apple').next().hasClass('orange');
     * //=> true
     * ```
     *
     * @param selector - If specified filter for sibling.
     * @returns The next nodes.
     * @see {@link https://api.jquery.com/next/}
     */
    const next = _singleMatcher((elem) => nextElementSibling(elem));
    /**
     * Gets all the following siblings of the first selected element, optionally
     * filtered by a selector.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.apple').nextAll();
     * //=> [<li class="orange">Orange</li>, <li class="pear">Pear</li>]
     * $('.apple').nextAll('.orange');
     * //=> [<li class="orange">Orange</li>]
     * ```
     *
     * @param selector - If specified filter for siblings.
     * @returns The next nodes.
     * @see {@link https://api.jquery.com/nextAll/}
     */
    const nextAll = _matcher((elem) => {
        const matched = [];
        while (elem.next) {
            elem = elem.next;
            if (isTag(elem))
                matched.push(elem);
        }
        return matched;
    }, _removeDuplicates);
    /**
     * Gets all the following siblings up to but not including the element matched
     * by the selector, optionally filtered by another selector.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.apple').nextUntil('.pear');
     * //=> [<li class="orange">Orange</li>]
     * ```
     *
     * @param selector - Selector for element to stop at.
     * @param filterSelector - If specified filter for siblings.
     * @returns The next nodes.
     * @see {@link https://api.jquery.com/nextUntil/}
     */
    const nextUntil = _matchUntil((el) => nextElementSibling(el), _removeDuplicates);
    /**
     * Gets the previous sibling of the first selected element optionally filtered
     * by a selector.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.orange').prev().hasClass('apple');
     * //=> true
     * ```
     *
     * @param selector - If specified filter for siblings.
     * @returns The previous nodes.
     * @see {@link https://api.jquery.com/prev/}
     */
    const prev = _singleMatcher((elem) => prevElementSibling(elem));
    /**
     * Gets all the preceding siblings of the first selected element, optionally
     * filtered by a selector.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.pear').prevAll();
     * //=> [<li class="orange">Orange</li>, <li class="apple">Apple</li>]
     *
     * $('.pear').prevAll('.orange');
     * //=> [<li class="orange">Orange</li>]
     * ```
     *
     * @param selector - If specified filter for siblings.
     * @returns The previous nodes.
     * @see {@link https://api.jquery.com/prevAll/}
     */
    const prevAll = _matcher((elem) => {
        const matched = [];
        while (elem.prev) {
            elem = elem.prev;
            if (isTag(elem))
                matched.push(elem);
        }
        return matched;
    }, _removeDuplicates);
    /**
     * Gets all the preceding siblings up to but not including the element matched
     * by the selector, optionally filtered by another selector.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.pear').prevUntil('.apple');
     * //=> [<li class="orange">Orange</li>]
     * ```
     *
     * @param selector - Selector for element to stop at.
     * @param filterSelector - If specified filter for siblings.
     * @returns The previous nodes.
     * @see {@link https://api.jquery.com/prevUntil/}
     */
    const prevUntil = _matchUntil((el) => prevElementSibling(el), _removeDuplicates);
    /**
     * Get the siblings of each element (excluding the element) in the set of
     * matched elements, optionally filtered by a selector.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.pear').siblings().length;
     * //=> 2
     *
     * $('.pear').siblings('.orange').length;
     * //=> 1
     * ```
     *
     * @param selector - If specified filter for siblings.
     * @returns The siblings.
     * @see {@link https://api.jquery.com/siblings/}
     */
    const siblings = _matcher((elem) => getSiblings(elem).filter((el) => isTag(el) && el !== elem), uniqueSort);
    /**
     * Gets the element children of each element in the set of matched elements.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('#fruits').children().length;
     * //=> 3
     *
     * $('#fruits').children('.pear').text();
     * //=> Pear
     * ```
     *
     * @param selector - If specified filter for children.
     * @returns The children.
     * @see {@link https://api.jquery.com/children/}
     */
    const children = _matcher((elem) => getChildren(elem).filter(isTag), _removeDuplicates);
    /**
     * Gets the children of each element in the set of matched elements, including
     * text and comment nodes.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('#fruits').contents().length;
     * //=> 3
     * ```
     *
     * @returns The children.
     * @see {@link https://api.jquery.com/contents/}
     */
    function contents() {
        const elems = this.toArray().reduce((newElems, elem) => hasChildren(elem) ? newElems.concat(elem.children) : newElems, []);
        return this._make(elems);
    }
    /**
     * Iterates over a cheerio object, executing a function for each matched
     * element. When the callback is fired, the function is fired in the context of
     * the DOM element, so `this` refers to the current element, which is equivalent
     * to the function parameter `element`. To break out of the `each` loop early,
     * return with `false`.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * const fruits = [];
     *
     * $('li').each(function (i, elem) {
     *   fruits[i] = $(this).text();
     * });
     *
     * fruits.join(', ');
     * //=> Apple, Orange, Pear
     * ```
     *
     * @param fn - Function to execute.
     * @returns The instance itself, useful for chaining.
     * @see {@link https://api.jquery.com/each/}
     */
    function each(fn) {
        let i = 0;
        const len = this.length;
        while (i < len && fn.call(this[i], i, this[i]) !== false)
            ++i;
        return this;
    }
    /**
     * Pass each element in the current matched set through a function, producing a
     * new Cheerio object containing the return values. The function can return an
     * individual data item or an array of data items to be inserted into the
     * resulting set. If an array is returned, the elements inside the array are
     * inserted into the set. If the function returns null or undefined, no element
     * will be inserted.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('li')
     *   .map(function (i, el) {
     *     // this === el
     *     return $(this).text();
     *   })
     *   .toArray()
     *   .join(' ');
     * //=> "apple orange pear"
     * ```
     *
     * @param fn - Function to execute.
     * @returns The mapped elements, wrapped in a Cheerio collection.
     * @see {@link https://api.jquery.com/map/}
     */
    function map(fn) {
        let elems = [];
        for (let i = 0; i < this.length; i++) {
            const el = this[i];
            const val = fn.call(el, i, el);
            if (val != null) {
                elems = elems.concat(val);
            }
        }
        return this._make(elems);
    }
    /**
     * Creates a function to test if a filter is matched.
     *
     * @param match - A filter.
     * @returns A function that determines if a filter has been matched.
     */
    function getFilterFn(match) {
        if (typeof match === 'function') {
            return (el, i) => match.call(el, i, el);
        }
        if (isCheerio(match)) {
            return (el) => Array.prototype.includes.call(match, el);
        }
        return function (el) {
            return match === el;
        };
    }
    function filter(match) {
        var _a;
        return this._make(filterArray(this.toArray(), match, this.options.xmlMode, (_a = this._root) === null || _a === void 0 ? void 0 : _a[0]));
    }
    function filterArray(nodes, match, xmlMode, root) {
        return typeof match === 'string'
            ? filter$1(match, nodes, { xmlMode, root })
            : nodes.filter(getFilterFn(match));
    }
    /**
     * Checks the current list of elements and returns `true` if _any_ of the
     * elements match the selector. If using an element or Cheerio selection,
     * returns `true` if _any_ of the elements match. If using a predicate function,
     * the function is executed in the context of the selected element, so `this`
     * refers to the current element.
     *
     * @category Attributes
     * @param selector - Selector for the selection.
     * @returns Whether or not the selector matches an element of the instance.
     * @see {@link https://api.jquery.com/is/}
     */
    function is(selector) {
        const nodes = this.toArray();
        return typeof selector === 'string'
            ? some(nodes.filter(isTag), selector, this.options)
            : selector
                ? nodes.some(getFilterFn(selector))
                : false;
    }
    /**
     * Remove elements from the set of matched elements. Given a Cheerio object that
     * represents a set of DOM elements, the `.not()` method constructs a new
     * Cheerio object from a subset of the matching elements. The supplied selector
     * is tested against each element; the elements that don't match the selector
     * will be included in the result.
     *
     * The `.not()` method can take a function as its argument in the same way that
     * `.filter()` does. Elements for which the function returns `true` are excluded
     * from the filtered set; all other elements are included.
     *
     * @category Traversing
     * @example <caption>Selector</caption>
     *
     * ```js
     * $('li').not('.apple').length;
     * //=> 2
     * ```
     *
     * @example <caption>Function</caption>
     *
     * ```js
     * $('li').not(function (i, el) {
     *   // this === el
     *   return $(this).attr('class') === 'orange';
     * }).length; //=> 2
     * ```
     *
     * @param match - Value to look for, following the rules above.
     * @param container - Optional node to filter instead.
     * @returns The filtered collection.
     * @see {@link https://api.jquery.com/not/}
     */
    function not(match) {
        let nodes = this.toArray();
        if (typeof match === 'string') {
            const matches = new Set(filter$1(match, nodes, this.options));
            nodes = nodes.filter((el) => !matches.has(el));
        }
        else {
            const filterFn = getFilterFn(match);
            nodes = nodes.filter((el, i) => !filterFn(el, i));
        }
        return this._make(nodes);
    }
    /**
     * Filters the set of matched elements to only those which have the given DOM
     * element as a descendant or which have a descendant that matches the given
     * selector. Equivalent to `.filter(':has(selector)')`.
     *
     * @category Traversing
     * @example <caption>Selector</caption>
     *
     * ```js
     * $('ul').has('.pear').attr('id');
     * //=> fruits
     * ```
     *
     * @example <caption>Element</caption>
     *
     * ```js
     * $('ul').has($('.pear')[0]).attr('id');
     * //=> fruits
     * ```
     *
     * @param selectorOrHaystack - Element to look for.
     * @returns The filtered collection.
     * @see {@link https://api.jquery.com/has/}
     */
    function has(selectorOrHaystack) {
        return this.filter(typeof selectorOrHaystack === 'string'
            ? // Using the `:has` selector here short-circuits searches.
                `:has(${selectorOrHaystack})`
            : (_, el) => this._make(el).find(selectorOrHaystack).length > 0);
    }
    /**
     * Will select the first element of a cheerio object.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('#fruits').children().first().text();
     * //=> Apple
     * ```
     *
     * @returns The first element.
     * @see {@link https://api.jquery.com/first/}
     */
    function first() {
        return this.length > 1 ? this._make(this[0]) : this;
    }
    /**
     * Will select the last element of a cheerio object.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('#fruits').children().last().text();
     * //=> Pear
     * ```
     *
     * @returns The last element.
     * @see {@link https://api.jquery.com/last/}
     */
    function last() {
        return this.length > 0 ? this._make(this[this.length - 1]) : this;
    }
    /**
     * Reduce the set of matched elements to the one at the specified index. Use
     * `.eq(-i)` to count backwards from the last selected element.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('li').eq(0).text();
     * //=> Apple
     *
     * $('li').eq(-1).text();
     * //=> Pear
     * ```
     *
     * @param i - Index of the element to select.
     * @returns The element at the `i`th position.
     * @see {@link https://api.jquery.com/eq/}
     */
    function eq(i) {
        var _a;
        i = +i;
        // Use the first identity optimization if possible
        if (i === 0 && this.length <= 1)
            return this;
        if (i < 0)
            i = this.length + i;
        return this._make((_a = this[i]) !== null && _a !== void 0 ? _a : []);
    }
    function get(i) {
        if (i == null) {
            return this.toArray();
        }
        return this[i < 0 ? this.length + i : i];
    }
    /**
     * Retrieve all the DOM elements contained in the jQuery set as an array.
     *
     * @example
     *
     * ```js
     * $('li').toArray();
     * //=> [ {...}, {...}, {...} ]
     * ```
     *
     * @returns The contained items.
     */
    function toArray() {
        return Array.prototype.slice.call(this);
    }
    /**
     * Search for a given element from among the matched elements.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.pear').index();
     * //=> 2 $('.orange').index('li');
     * //=> 1
     * $('.apple').index($('#fruit, li'));
     * //=> 1
     * ```
     *
     * @param selectorOrNeedle - Element to look for.
     * @returns The index of the element.
     * @see {@link https://api.jquery.com/index/}
     */
    function index(selectorOrNeedle) {
        let $haystack;
        let needle;
        if (selectorOrNeedle == null) {
            $haystack = this.parent().children();
            needle = this[0];
        }
        else if (typeof selectorOrNeedle === 'string') {
            $haystack = this._make(selectorOrNeedle);
            needle = this[0];
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            $haystack = this;
            needle = isCheerio(selectorOrNeedle)
                ? selectorOrNeedle[0]
                : selectorOrNeedle;
        }
        return Array.prototype.indexOf.call($haystack, needle);
    }
    /**
     * Gets the elements matching the specified range (0-based position).
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('li').slice(1).eq(0).text();
     * //=> 'Orange'
     *
     * $('li').slice(1, 2).length;
     * //=> 1
     * ```
     *
     * @param start - A position at which the elements begin to be selected. If
     *   negative, it indicates an offset from the end of the set.
     * @param end - A position at which the elements stop being selected. If
     *   negative, it indicates an offset from the end of the set. If omitted, the
     *   range continues until the end of the set.
     * @returns The elements matching the specified range.
     * @see {@link https://api.jquery.com/slice/}
     */
    function slice(start, end) {
        return this._make(Array.prototype.slice.call(this, start, end));
    }
    /**
     * End the most recent filtering operation in the current chain and return the
     * set of matched elements to its previous state.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('li').eq(0).end().length;
     * //=> 3
     * ```
     *
     * @returns The previous state of the set of matched elements.
     * @see {@link https://api.jquery.com/end/}
     */
    function end() {
        var _a;
        return (_a = this.prevObject) !== null && _a !== void 0 ? _a : this._make([]);
    }
    /**
     * Add elements to the set of matched elements.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('.apple').add('.orange').length;
     * //=> 2
     * ```
     *
     * @param other - Elements to add.
     * @param context - Optionally the context of the new selection.
     * @returns The combined set.
     * @see {@link https://api.jquery.com/add/}
     */
    function add(other, context) {
        const selection = this._make(other, context);
        const contents = uniqueSort([...this.get(), ...selection.get()]);
        return this._make(contents);
    }
    /**
     * Add the previous set of elements on the stack to the current set, optionally
     * filtered by a selector.
     *
     * @category Traversing
     * @example
     *
     * ```js
     * $('li').eq(0).addBack('.orange').length;
     * //=> 2
     * ```
     *
     * @param selector - Selector for the elements to add.
     * @returns The combined set.
     * @see {@link https://api.jquery.com/addBack/}
     */
    function addBack(selector) {
        return this.prevObject
            ? this.add(selector ? this.prevObject.filter(selector) : this.prevObject)
            : this;
    }

    var Traversing = /*#__PURE__*/Object.freeze({
        __proto__: null,
        find: find,
        parent: parent,
        parents: parents,
        parentsUntil: parentsUntil,
        closest: closest,
        next: next,
        nextAll: nextAll,
        nextUntil: nextUntil,
        prev: prev,
        prevAll: prevAll,
        prevUntil: prevUntil,
        siblings: siblings,
        children: children,
        contents: contents,
        each: each,
        map: map,
        filter: filter,
        filterArray: filterArray,
        is: is,
        not: not,
        has: has,
        first: first,
        last: last,
        eq: eq,
        get: get,
        toArray: toArray,
        index: index,
        slice: slice,
        end: end,
        add: add,
        addBack: addBack
    });

    /**
     * Get the parse function with options.
     *
     * @param parser - The parser function.
     * @returns The parse function with options.
     */
    function getParse(parser) {
        /**
         * Parse a HTML string or a node.
         *
         * @param content - The HTML string or node.
         * @param options - The parser options.
         * @param isDocument - If `content` is a document.
         * @param context - The context node in the DOM tree.
         * @returns The parsed document node.
         */
        return function parse(content, options, isDocument$1, context) {
            if (typeof Buffer !== 'undefined' && Buffer.isBuffer(content)) {
                content = content.toString();
            }
            if (typeof content === 'string') {
                return parser(content, options, isDocument$1, context);
            }
            const doc = content;
            if (!Array.isArray(doc) && isDocument(doc)) {
                // If `doc` is already a root, just return it
                return doc;
            }
            // Add conent to new root element
            const root = new Document([]);
            // Update the DOM using the root
            update(doc, root);
            return root;
        };
    }
    /**
     * Update the dom structure, for one changed layer.
     *
     * @param newChilds - The new children.
     * @param parent - The new parent.
     * @returns The parent node.
     */
    function update(newChilds, parent) {
        // Normalize
        const arr = Array.isArray(newChilds) ? newChilds : [newChilds];
        // Update parent
        if (parent) {
            parent.children = arr;
        }
        else {
            parent = null;
        }
        // Update neighbors
        for (let i = 0; i < arr.length; i++) {
            const node = arr[i];
            // Cleanly remove existing nodes from their previous structures.
            if (node.parent && node.parent.children !== arr) {
                removeElement(node);
            }
            if (parent) {
                node.prev = arr[i - 1] || null;
                node.next = arr[i + 1] || null;
            }
            else {
                node.prev = node.next = null;
            }
            node.parent = parent;
        }
        return parent;
    }

    /**
     * Methods for modifying the DOM structure.
     *
     * @module cheerio/manipulation
     */
    /**
     * Create an array of nodes, recursing into arrays and parsing strings if necessary.
     *
     * @private
     * @category Manipulation
     * @param elem - Elements to make an array of.
     * @param clone - Optionally clone nodes.
     * @returns The array of nodes.
     */
    function _makeDomArray(elem, clone) {
        if (elem == null) {
            return [];
        }
        if (isCheerio(elem)) {
            return clone ? cloneDom(elem.get()) : elem.get();
        }
        if (Array.isArray(elem)) {
            return elem.reduce((newElems, el) => newElems.concat(this._makeDomArray(el, clone)), []);
        }
        if (typeof elem === 'string') {
            return this._parse(elem, this.options, false, null).children;
        }
        return clone ? cloneDom([elem]) : [elem];
    }
    function _insert(concatenator) {
        return function (...elems) {
            const lastIdx = this.length - 1;
            return domEach(this, (el, i) => {
                if (!hasChildren(el))
                    return;
                const domSrc = typeof elems[0] === 'function'
                    ? elems[0].call(el, i, this._render(el.children))
                    : elems;
                const dom = this._makeDomArray(domSrc, i < lastIdx);
                concatenator(dom, el.children, el);
            });
        };
    }
    /**
     * Modify an array in-place, removing some number of elements and adding new
     * elements directly following them.
     *
     * @private
     * @category Manipulation
     * @param array - Target array to splice.
     * @param spliceIdx - Index at which to begin changing the array.
     * @param spliceCount - Number of elements to remove from the array.
     * @param newElems - Elements to insert into the array.
     * @param parent - The parent of the node.
     * @returns The spliced array.
     */
    function uniqueSplice(array, spliceIdx, spliceCount, newElems, parent) {
        var _a, _b;
        const spliceArgs = [
            spliceIdx,
            spliceCount,
            ...newElems,
        ];
        const prev = spliceIdx === 0 ? null : array[spliceIdx - 1];
        const next = spliceIdx + spliceCount >= array.length
            ? null
            : array[spliceIdx + spliceCount];
        /*
         * Before splicing in new elements, ensure they do not already appear in the
         * current array.
         */
        for (let idx = 0; idx < newElems.length; ++idx) {
            const node = newElems[idx];
            const oldParent = node.parent;
            if (oldParent) {
                const oldSiblings = oldParent.children;
                const prevIdx = oldSiblings.indexOf(node);
                if (prevIdx > -1) {
                    oldParent.children.splice(prevIdx, 1);
                    if (parent === oldParent && spliceIdx > prevIdx) {
                        spliceArgs[0]--;
                    }
                }
            }
            node.parent = parent;
            if (node.prev) {
                node.prev.next = (_a = node.next) !== null && _a !== void 0 ? _a : null;
            }
            if (node.next) {
                node.next.prev = (_b = node.prev) !== null && _b !== void 0 ? _b : null;
            }
            node.prev = idx === 0 ? prev : newElems[idx - 1];
            node.next = idx === newElems.length - 1 ? next : newElems[idx + 1];
        }
        if (prev) {
            prev.next = newElems[0];
        }
        if (next) {
            next.prev = newElems[newElems.length - 1];
        }
        return array.splice(...spliceArgs);
    }
    /**
     * Insert every element in the set of matched elements to the end of the target.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * $('<li class="plum">Plum</li>').appendTo('#fruits');
     * $.html();
     * //=>  <ul id="fruits">
     * //      <li class="apple">Apple</li>
     * //      <li class="orange">Orange</li>
     * //      <li class="pear">Pear</li>
     * //      <li class="plum">Plum</li>
     * //    </ul>
     * ```
     *
     * @param target - Element to append elements to.
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/appendTo/}
     */
    function appendTo(target) {
        const appendTarget = isCheerio(target) ? target : this._make(target);
        appendTarget.append(this);
        return this;
    }
    /**
     * Insert every element in the set of matched elements to the beginning of the target.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * $('<li class="plum">Plum</li>').prependTo('#fruits');
     * $.html();
     * //=>  <ul id="fruits">
     * //      <li class="plum">Plum</li>
     * //      <li class="apple">Apple</li>
     * //      <li class="orange">Orange</li>
     * //      <li class="pear">Pear</li>
     * //    </ul>
     * ```
     *
     * @param target - Element to prepend elements to.
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/prependTo/}
     */
    function prependTo(target) {
        const prependTarget = isCheerio(target) ? target : this._make(target);
        prependTarget.prepend(this);
        return this;
    }
    /**
     * Inserts content as the _last_ child of each of the selected elements.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * $('ul').append('<li class="plum">Plum</li>');
     * $.html();
     * //=>  <ul id="fruits">
     * //      <li class="apple">Apple</li>
     * //      <li class="orange">Orange</li>
     * //      <li class="pear">Pear</li>
     * //      <li class="plum">Plum</li>
     * //    </ul>
     * ```
     *
     * @see {@link https://api.jquery.com/append/}
     */
    const append = _insert((dom, children, parent) => {
        uniqueSplice(children, children.length, 0, dom, parent);
    });
    /**
     * Inserts content as the _first_ child of each of the selected elements.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * $('ul').prepend('<li class="plum">Plum</li>');
     * $.html();
     * //=>  <ul id="fruits">
     * //      <li class="plum">Plum</li>
     * //      <li class="apple">Apple</li>
     * //      <li class="orange">Orange</li>
     * //      <li class="pear">Pear</li>
     * //    </ul>
     * ```
     *
     * @see {@link https://api.jquery.com/prepend/}
     */
    const prepend = _insert((dom, children, parent) => {
        uniqueSplice(children, 0, 0, dom, parent);
    });
    function _wrap(insert) {
        return function (wrapper) {
            const lastIdx = this.length - 1;
            const lastParent = this.parents().last();
            for (let i = 0; i < this.length; i++) {
                const el = this[i];
                const wrap = typeof wrapper === 'function'
                    ? wrapper.call(el, i, el)
                    : typeof wrapper === 'string' && !isHtml(wrapper)
                        ? lastParent.find(wrapper).clone()
                        : wrapper;
                const [wrapperDom] = this._makeDomArray(wrap, i < lastIdx);
                if (!wrapperDom || !hasChildren(wrapperDom))
                    continue;
                let elInsertLocation = wrapperDom;
                /*
                 * Find the deepest child. Only consider the first tag child of each node
                 * (ignore text); stop if no children are found.
                 */
                let j = 0;
                while (j < elInsertLocation.children.length) {
                    const child = elInsertLocation.children[j];
                    if (isTag(child)) {
                        elInsertLocation = child;
                        j = 0;
                    }
                    else {
                        j++;
                    }
                }
                insert(el, elInsertLocation, [wrapperDom]);
            }
            return this;
        };
    }
    /**
     * The .wrap() function can take any string or object that could be passed to
     * the $() factory function to specify a DOM structure. This structure may be
     * nested several levels deep, but should contain only one inmost element. A
     * copy of this structure will be wrapped around each of the elements in the set
     * of matched elements. This method returns the original set of elements for
     * chaining purposes.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * const redFruit = $('<div class="red-fruit"></div>');
     * $('.apple').wrap(redFruit);
     *
     * //=> <ul id="fruits">
     * //     <div class="red-fruit">
     * //      <li class="apple">Apple</li>
     * //     </div>
     * //     <li class="orange">Orange</li>
     * //     <li class="plum">Plum</li>
     * //   </ul>
     *
     * const healthy = $('<div class="healthy"></div>');
     * $('li').wrap(healthy);
     *
     * //=> <ul id="fruits">
     * //     <div class="healthy">
     * //       <li class="apple">Apple</li>
     * //     </div>
     * //     <div class="healthy">
     * //       <li class="orange">Orange</li>
     * //     </div>
     * //     <div class="healthy">
     * //        <li class="plum">Plum</li>
     * //     </div>
     * //   </ul>
     * ```
     *
     * @param wrapper - The DOM structure to wrap around each element in the selection.
     * @see {@link https://api.jquery.com/wrap/}
     */
    const wrap = _wrap((el, elInsertLocation, wrapperDom) => {
        const { parent } = el;
        if (!parent)
            return;
        const siblings = parent.children;
        const index = siblings.indexOf(el);
        update([el], elInsertLocation);
        /*
         * The previous operation removed the current element from the `siblings`
         * array, so the `dom` array can be inserted without removing any
         * additional elements.
         */
        uniqueSplice(siblings, index, 0, wrapperDom, parent);
    });
    /**
     * The .wrapInner() function can take any string or object that could be passed
     * to the $() factory function to specify a DOM structure. This structure may be
     * nested several levels deep, but should contain only one inmost element. The
     * structure will be wrapped around the content of each of the elements in the
     * set of matched elements.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * const redFruit = $('<div class="red-fruit"></div>');
     * $('.apple').wrapInner(redFruit);
     *
     * //=> <ul id="fruits">
     * //     <li class="apple">
     * //       <div class="red-fruit">Apple</div>
     * //     </li>
     * //     <li class="orange">Orange</li>
     * //     <li class="pear">Pear</li>
     * //   </ul>
     *
     * const healthy = $('<div class="healthy"></div>');
     * $('li').wrapInner(healthy);
     *
     * //=> <ul id="fruits">
     * //     <li class="apple">
     * //       <div class="healthy">Apple</div>
     * //     </li>
     * //     <li class="orange">
     * //       <div class="healthy">Orange</div>
     * //     </li>
     * //     <li class="pear">
     * //       <div class="healthy">Pear</div>
     * //     </li>
     * //   </ul>
     * ```
     *
     * @param wrapper - The DOM structure to wrap around the content of each element
     *   in the selection.
     * @returns The instance itself, for chaining.
     * @see {@link https://api.jquery.com/wrapInner/}
     */
    const wrapInner = _wrap((el, elInsertLocation, wrapperDom) => {
        if (!hasChildren(el))
            return;
        update(el.children, elInsertLocation);
        update(wrapperDom, el);
    });
    /**
     * The .unwrap() function, removes the parents of the set of matched elements
     * from the DOM, leaving the matched elements in their place.
     *
     * @category Manipulation
     * @example <caption>without selector</caption>
     *
     * ```js
     * const $ = cheerio.load(
     *   '<div id=test>\n  <div><p>Hello</p></div>\n  <div><p>World</p></div>\n</div>'
     * );
     * $('#test p').unwrap();
     *
     * //=> <div id=test>
     * //     <p>Hello</p>
     * //     <p>World</p>
     * //   </div>
     * ```
     *
     * @example <caption>with selector</caption>
     *
     * ```js
     * const $ = cheerio.load(
     *   '<div id=test>\n  <p>Hello</p>\n  <b><p>World</p></b>\n</div>'
     * );
     * $('#test p').unwrap('b');
     *
     * //=> <div id=test>
     * //     <p>Hello</p>
     * //     <p>World</p>
     * //   </div>
     * ```
     *
     * @param selector - A selector to check the parent element against. If an
     *   element's parent does not match the selector, the element won't be unwrapped.
     * @returns The instance itself, for chaining.
     * @see {@link https://api.jquery.com/unwrap/}
     */
    function unwrap(selector) {
        this.parent(selector)
            .not('body')
            .each((_, el) => {
            this._make(el).replaceWith(el.children);
        });
        return this;
    }
    /**
     * The .wrapAll() function can take any string or object that could be passed to
     * the $() function to specify a DOM structure. This structure may be nested
     * several levels deep, but should contain only one inmost element. The
     * structure will be wrapped around all of the elements in the set of matched
     * elements, as a single group.
     *
     * @category Manipulation
     * @example <caption>With markup passed to `wrapAll`</caption>
     *
     * ```js
     * const $ = cheerio.load(
     *   '<div class="container"><div class="inner">First</div><div class="inner">Second</div></div>'
     * );
     * $('.inner').wrapAll("<div class='new'></div>");
     *
     * //=> <div class="container">
     * //     <div class='new'>
     * //       <div class="inner">First</div>
     * //       <div class="inner">Second</div>
     * //     </div>
     * //   </div>
     * ```
     *
     * @example <caption>With an existing cheerio instance</caption>
     *
     * ```js
     * const $ = cheerio.load(
     *   '<span>Span 1</span><strong>Strong</strong><span>Span 2</span>'
     * );
     * const wrap = $('<div><p><em><b></b></em></p></div>');
     * $('span').wrapAll(wrap);
     *
     * //=> <div>
     * //     <p>
     * //       <em>
     * //         <b>
     * //           <span>Span 1</span>
     * //           <span>Span 2</span>
     * //         </b>
     * //       </em>
     * //     </p>
     * //   </div>
     * //   <strong>Strong</strong>
     * ```
     *
     * @param wrapper - The DOM structure to wrap around all matched elements in the
     *   selection.
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/wrapAll/}
     */
    function wrapAll(wrapper) {
        const el = this[0];
        if (el) {
            const wrap = this._make(typeof wrapper === 'function' ? wrapper.call(el, 0, el) : wrapper).insertBefore(el);
            // If html is given as wrapper, wrap may contain text elements
            let elInsertLocation;
            for (let i = 0; i < wrap.length; i++) {
                if (wrap[i].type === 'tag')
                    elInsertLocation = wrap[i];
            }
            let j = 0;
            /*
             * Find the deepest child. Only consider the first tag child of each node
             * (ignore text); stop if no children are found.
             */
            while (elInsertLocation && j < elInsertLocation.children.length) {
                const child = elInsertLocation.children[j];
                if (child.type === 'tag') {
                    elInsertLocation = child;
                    j = 0;
                }
                else {
                    j++;
                }
            }
            if (elInsertLocation)
                this._make(elInsertLocation).append(this);
        }
        return this;
    }
    /* eslint-disable jsdoc/check-param-names*/
    /**
     * Insert content next to each element in the set of matched elements.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * $('.apple').after('<li class="plum">Plum</li>');
     * $.html();
     * //=>  <ul id="fruits">
     * //      <li class="apple">Apple</li>
     * //      <li class="plum">Plum</li>
     * //      <li class="orange">Orange</li>
     * //      <li class="pear">Pear</li>
     * //    </ul>
     * ```
     *
     * @param content - HTML string, DOM element, array of DOM elements or Cheerio
     *   to insert after each element in the set of matched elements.
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/after/}
     */
    function after(...elems) {
        const lastIdx = this.length - 1;
        return domEach(this, (el, i) => {
            const { parent } = el;
            if (!hasChildren(el) || !parent) {
                return;
            }
            const siblings = parent.children;
            const index = siblings.indexOf(el);
            // If not found, move on
            /* istanbul ignore next */
            if (index < 0)
                return;
            const domSrc = typeof elems[0] === 'function'
                ? elems[0].call(el, i, this._render(el.children))
                : elems;
            const dom = this._makeDomArray(domSrc, i < lastIdx);
            // Add element after `this` element
            uniqueSplice(siblings, index + 1, 0, dom, parent);
        });
    }
    /* eslint-enable jsdoc/check-param-names*/
    /**
     * Insert every element in the set of matched elements after the target.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * $('<li class="plum">Plum</li>').insertAfter('.apple');
     * $.html();
     * //=>  <ul id="fruits">
     * //      <li class="apple">Apple</li>
     * //      <li class="plum">Plum</li>
     * //      <li class="orange">Orange</li>
     * //      <li class="pear">Pear</li>
     * //    </ul>
     * ```
     *
     * @param target - Element to insert elements after.
     * @returns The set of newly inserted elements.
     * @see {@link https://api.jquery.com/insertAfter/}
     */
    function insertAfter(target) {
        if (typeof target === 'string') {
            target = this._make(target);
        }
        this.remove();
        const clones = [];
        this._makeDomArray(target).forEach((el) => {
            const clonedSelf = this.clone().toArray();
            const { parent } = el;
            if (!parent) {
                return;
            }
            const siblings = parent.children;
            const index = siblings.indexOf(el);
            // If not found, move on
            /* istanbul ignore next */
            if (index < 0)
                return;
            // Add cloned `this` element(s) after target element
            uniqueSplice(siblings, index + 1, 0, clonedSelf, parent);
            clones.push(...clonedSelf);
        });
        return this._make(clones);
    }
    /* eslint-disable jsdoc/check-param-names*/
    /**
     * Insert content previous to each element in the set of matched elements.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * $('.apple').before('<li class="plum">Plum</li>');
     * $.html();
     * //=>  <ul id="fruits">
     * //      <li class="plum">Plum</li>
     * //      <li class="apple">Apple</li>
     * //      <li class="orange">Orange</li>
     * //      <li class="pear">Pear</li>
     * //    </ul>
     * ```
     *
     * @param content - HTML string, DOM element, array of DOM elements or Cheerio
     *   to insert before each element in the set of matched elements.
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/before/}
     */
    function before(...elems) {
        const lastIdx = this.length - 1;
        return domEach(this, (el, i) => {
            const { parent } = el;
            if (!hasChildren(el) || !parent) {
                return;
            }
            const siblings = parent.children;
            const index = siblings.indexOf(el);
            // If not found, move on
            /* istanbul ignore next */
            if (index < 0)
                return;
            const domSrc = typeof elems[0] === 'function'
                ? elems[0].call(el, i, this._render(el.children))
                : elems;
            const dom = this._makeDomArray(domSrc, i < lastIdx);
            // Add element before `el` element
            uniqueSplice(siblings, index, 0, dom, parent);
        });
    }
    /* eslint-enable jsdoc/check-param-names*/
    /**
     * Insert every element in the set of matched elements before the target.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * $('<li class="plum">Plum</li>').insertBefore('.apple');
     * $.html();
     * //=>  <ul id="fruits">
     * //      <li class="plum">Plum</li>
     * //      <li class="apple">Apple</li>
     * //      <li class="orange">Orange</li>
     * //      <li class="pear">Pear</li>
     * //    </ul>
     * ```
     *
     * @param target - Element to insert elements before.
     * @returns The set of newly inserted elements.
     * @see {@link https://api.jquery.com/insertBefore/}
     */
    function insertBefore(target) {
        const targetArr = this._make(target);
        this.remove();
        const clones = [];
        domEach(targetArr, (el) => {
            const clonedSelf = this.clone().toArray();
            const { parent } = el;
            if (!parent) {
                return;
            }
            const siblings = parent.children;
            const index = siblings.indexOf(el);
            // If not found, move on
            /* istanbul ignore next */
            if (index < 0)
                return;
            // Add cloned `this` element(s) after target element
            uniqueSplice(siblings, index, 0, clonedSelf, parent);
            clones.push(...clonedSelf);
        });
        return this._make(clones);
    }
    /**
     * Removes the set of matched elements from the DOM and all their children.
     * `selector` filters the set of matched elements to be removed.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * $('.pear').remove();
     * $.html();
     * //=>  <ul id="fruits">
     * //      <li class="apple">Apple</li>
     * //      <li class="orange">Orange</li>
     * //    </ul>
     * ```
     *
     * @param selector - Optional selector for elements to remove.
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/remove/}
     */
    function remove(selector) {
        // Filter if we have selector
        const elems = selector ? this.filter(selector) : this;
        domEach(elems, (el) => {
            removeElement(el);
            el.prev = el.next = el.parent = null;
        });
        return this;
    }
    /**
     * Replaces matched elements with `content`.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * const plum = $('<li class="plum">Plum</li>');
     * $('.pear').replaceWith(plum);
     * $.html();
     * //=> <ul id="fruits">
     * //     <li class="apple">Apple</li>
     * //     <li class="orange">Orange</li>
     * //     <li class="plum">Plum</li>
     * //   </ul>
     * ```
     *
     * @param content - Replacement for matched elements.
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/replaceWith/}
     */
    function replaceWith(content) {
        return domEach(this, (el, i) => {
            const { parent } = el;
            if (!parent) {
                return;
            }
            const siblings = parent.children;
            const cont = typeof content === 'function' ? content.call(el, i, el) : content;
            const dom = this._makeDomArray(cont);
            /*
             * In the case that `dom` contains nodes that already exist in other
             * structures, ensure those nodes are properly removed.
             */
            update(dom, null);
            const index = siblings.indexOf(el);
            // Completely remove old element
            uniqueSplice(siblings, index, 1, dom, parent);
            if (!dom.includes(el)) {
                el.parent = el.prev = el.next = null;
            }
        });
    }
    /**
     * Empties an element, removing all its children.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * $('ul').empty();
     * $.html();
     * //=>  <ul id="fruits"></ul>
     * ```
     *
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/empty/}
     */
    function empty() {
        return domEach(this, (el) => {
            if (!hasChildren(el))
                return;
            el.children.forEach((child) => {
                child.next = child.prev = child.parent = null;
            });
            el.children.length = 0;
        });
    }
    function html(str) {
        if (str === undefined) {
            const el = this[0];
            if (!el || !hasChildren(el))
                return null;
            return this._render(el.children);
        }
        return domEach(this, (el) => {
            if (!hasChildren(el))
                return;
            el.children.forEach((child) => {
                child.next = child.prev = child.parent = null;
            });
            const content = isCheerio(str)
                ? str.toArray()
                : this._parse(`${str}`, this.options, false, el).children;
            update(content, el);
        });
    }
    /**
     * Turns the collection to a string. Alias for `.html()`.
     *
     * @category Manipulation
     * @returns The rendered document.
     */
    function toString() {
        return this._render(this);
    }
    function text(str) {
        // If `str` is undefined, act as a "getter"
        if (str === undefined) {
            return text$1(this);
        }
        if (typeof str === 'function') {
            // Function support
            return domEach(this, (el, i) => this._make(el).text(str.call(el, i, text$1([el]))));
        }
        // Append text node to each selected elements
        return domEach(this, (el) => {
            if (!hasChildren(el))
                return;
            el.children.forEach((child) => {
                child.next = child.prev = child.parent = null;
            });
            const textNode = new Text(`${str}`);
            update(textNode, el);
        });
    }
    /**
     * Clone the cheerio object.
     *
     * @category Manipulation
     * @example
     *
     * ```js
     * const moreFruit = $('#fruits').clone();
     * ```
     *
     * @returns The cloned object.
     * @see {@link https://api.jquery.com/clone/}
     */
    function clone() {
        return this._make(cloneDom(this.get()));
    }

    var Manipulation = /*#__PURE__*/Object.freeze({
        __proto__: null,
        _makeDomArray: _makeDomArray,
        appendTo: appendTo,
        prependTo: prependTo,
        append: append,
        prepend: prepend,
        wrap: wrap,
        wrapInner: wrapInner,
        unwrap: unwrap,
        wrapAll: wrapAll,
        after: after,
        insertAfter: insertAfter,
        before: before,
        insertBefore: insertBefore,
        remove: remove,
        replaceWith: replaceWith,
        empty: empty,
        html: html,
        toString: toString,
        text: text,
        clone: clone
    });

    /**
     * Set multiple CSS properties for every matched element.
     *
     * @category CSS
     * @param prop - The names of the properties.
     * @param val - The new values.
     * @returns The instance itself.
     * @see {@link https://api.jquery.com/css/}
     */
    function css(prop, val) {
        if ((prop != null && val != null) ||
            // When `prop` is a "plain" object
            (typeof prop === 'object' && !Array.isArray(prop))) {
            return domEach(this, (el, i) => {
                if (isTag(el)) {
                    // `prop` can't be an array here anymore.
                    setCss(el, prop, val, i);
                }
            });
        }
        if (this.length === 0) {
            return undefined;
        }
        return getCss(this[0], prop);
    }
    /**
     * Set styles of all elements.
     *
     * @private
     * @param el - Element to set style of.
     * @param prop - Name of property.
     * @param value - Value to set property to.
     * @param idx - Optional index within the selection.
     */
    function setCss(el, prop, value, idx) {
        if (typeof prop === 'string') {
            const styles = getCss(el);
            const val = typeof value === 'function' ? value.call(el, idx, styles[prop]) : value;
            if (val === '') {
                delete styles[prop];
            }
            else if (val != null) {
                styles[prop] = val;
            }
            el.attribs['style'] = stringify(styles);
        }
        else if (typeof prop === 'object') {
            Object.keys(prop).forEach((k, i) => {
                setCss(el, k, prop[k], i);
            });
        }
    }
    function getCss(el, prop) {
        if (!el || !isTag(el))
            return;
        const styles = parse$2(el.attribs['style']);
        if (typeof prop === 'string') {
            return styles[prop];
        }
        if (Array.isArray(prop)) {
            const newStyles = {};
            prop.forEach((item) => {
                if (styles[item] != null) {
                    newStyles[item] = styles[item];
                }
            });
            return newStyles;
        }
        return styles;
    }
    /**
     * Stringify `obj` to styles.
     *
     * @private
     * @category CSS
     * @param obj - Object to stringify.
     * @returns The serialized styles.
     */
    function stringify(obj) {
        return Object.keys(obj).reduce((str, prop) => `${str}${str ? ' ' : ''}${prop}: ${obj[prop]};`, '');
    }
    /**
     * Parse `styles`.
     *
     * @private
     * @category CSS
     * @param styles - Styles to be parsed.
     * @returns The parsed styles.
     */
    function parse$2(styles) {
        styles = (styles || '').trim();
        if (!styles)
            return {};
        const obj = {};
        let key;
        for (const str of styles.split(';')) {
            const n = str.indexOf(':');
            // If there is no :, or if it is the first/last character, add to the previous item's value
            if (n < 1 || n === str.length - 1) {
                const trimmed = str.trimEnd();
                if (trimmed.length > 0 && key !== undefined) {
                    obj[key] += `;${trimmed}`;
                }
            }
            else {
                key = str.slice(0, n).trim();
                obj[key] = str.slice(n + 1).trim();
            }
        }
        return obj;
    }

    var Css = /*#__PURE__*/Object.freeze({
        __proto__: null,
        css: css
    });

    /*
     * https://github.com/jquery/jquery/blob/2.1.3/src/manipulation/var/rcheckableType.js
     * https://github.com/jquery/jquery/blob/2.1.3/src/serialize.js
     */
    const submittableSelector = 'input,select,textarea,keygen';
    const r20 = /%20/g;
    const rCRLF = /\r?\n/g;
    /**
     * Encode a set of form elements as a string for submission.
     *
     * @category Forms
     * @example
     *
     * ```js
     * $('<form><input name="foo" value="bar" /></form>').serialize();
     * //=> 'foo=bar'
     * ```
     *
     * @returns The serialized form.
     * @see {@link https://api.jquery.com/serialize/}
     */
    function serialize() {
        // Convert form elements into name/value objects
        const arr = this.serializeArray();
        // Serialize each element into a key/value string
        const retArr = arr.map((data) => `${encodeURIComponent(data.name)}=${encodeURIComponent(data.value)}`);
        // Return the resulting serialization
        return retArr.join('&').replace(r20, '+');
    }
    /**
     * Encode a set of form elements as an array of names and values.
     *
     * @category Forms
     * @example
     *
     * ```js
     * $('<form><input name="foo" value="bar" /></form>').serializeArray();
     * //=> [ { name: 'foo', value: 'bar' } ]
     * ```
     *
     * @returns The serialized form.
     * @see {@link https://api.jquery.com/serializeArray/}
     */
    function serializeArray() {
        // Resolve all form elements from either forms or collections of form elements
        return this.map((_, elem) => {
            const $elem = this._make(elem);
            if (isTag(elem) && elem.name === 'form') {
                return $elem.find(submittableSelector).toArray();
            }
            return $elem.filter(submittableSelector).toArray();
        })
            .filter(
        // Verify elements have a name (`attr.name`) and are not disabled (`:enabled`)
        '[name!=""]:enabled' +
            // And cannot be clicked (`[type=submit]`) or are used in `x-www-form-urlencoded` (`[type=file]`)
            ':not(:submit, :button, :image, :reset, :file)' +
            // And are either checked/don't have a checkable state
            ':matches([checked], :not(:checkbox, :radio))'
        // Convert each of the elements to its value(s)
        )
            .map((_, elem) => {
            var _a;
            const $elem = this._make(elem);
            const name = $elem.attr('name'); // We have filtered for elements with a name before.
            // If there is no value set (e.g. `undefined`, `null`), then default value to empty
            const value = (_a = $elem.val()) !== null && _a !== void 0 ? _a : '';
            // If we have an array of values (e.g. `<select multiple>`), return an array of key/value pairs
            if (Array.isArray(value)) {
                return value.map((val) => 
                /*
                 * We trim replace any line endings (e.g. `\r` or `\r\n` with `\r\n`) to guarantee consistency across platforms
                 * These can occur inside of `<textarea>'s`
                 */
                ({ name, value: val.replace(rCRLF, '\r\n') }));
            }
            // Otherwise (e.g. `<input type="text">`, return only one key/value pair
            return { name, value: value.replace(rCRLF, '\r\n') };
        })
            .toArray();
    }

    var Forms = /*#__PURE__*/Object.freeze({
        __proto__: null,
        serialize: serialize,
        serializeArray: serializeArray
    });

    class Cheerio {
        /**
         * Instance of cheerio. Methods are specified in the modules. Usage of this
         * constructor is not recommended. Please use `$.load` instead.
         *
         * @private
         * @param elements - The new selection.
         * @param root - Sets the root node.
         * @param options - Options for the instance.
         */
        constructor(elements, root, options) {
            this.length = 0;
            this.options = options;
            this._root = root;
            if (elements) {
                for (let idx = 0; idx < elements.length; idx++) {
                    this[idx] = elements[idx];
                }
                this.length = elements.length;
            }
        }
    }
    /** Set a signature of the object. */
    Cheerio.prototype.cheerio = '[cheerio object]';
    /*
     * Make cheerio an array-like object
     */
    Cheerio.prototype.splice = Array.prototype.splice;
    // Support for (const element of $(...)) iteration:
    Cheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];
    // Plug in the API
    Object.assign(Cheerio.prototype, Attributes, Traversing, Manipulation, Css, Forms);

    function getLoad(parse, render) {
        /**
         * Create a querying function, bound to a document created from the provided markup.
         *
         * Note that similar to web browser contexts, this operation may introduce
         * `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false` to
         * switch to fragment mode and disable this.
         *
         * @param content - Markup to be loaded.
         * @param options - Options for the created instance.
         * @param isDocument - Allows parser to be switched to fragment mode.
         * @returns The loaded document.
         * @see {@link https://cheerio.js.org#loading} for additional usage information.
         */
        return function load(content, options, isDocument = true) {
            if (content == null) {
                throw new Error('cheerio.load() expects a string');
            }
            const internalOpts = { ...defaultOpts$2, ...flatten(options) };
            const initialRoot = parse(content, internalOpts, isDocument, null);
            /** Create an extended class here, so that extensions only live on one instance. */
            class LoadedCheerio extends Cheerio {
                _make(selector, context) {
                    const cheerio = initialize(selector, context);
                    cheerio.prevObject = this;
                    return cheerio;
                }
                _parse(content, options, isDocument, context) {
                    return parse(content, options, isDocument, context);
                }
                _render(dom) {
                    return render(dom, this.options);
                }
            }
            function initialize(selector, context, root = initialRoot, opts) {
                // $($)
                if (selector && isCheerio(selector))
                    return selector;
                const options = {
                    ...internalOpts,
                    ...flatten(opts),
                };
                const r = typeof root === 'string'
                    ? [parse(root, options, false, null)]
                    : 'length' in root
                        ? root
                        : [root];
                const rootInstance = isCheerio(r)
                    ? r
                    : new LoadedCheerio(r, null, options);
                // Add a cyclic reference, so that calling methods on `_root` never fails.
                rootInstance._root = rootInstance;
                // $(), $(null), $(undefined), $(false)
                if (!selector) {
                    return new LoadedCheerio(undefined, rootInstance, options);
                }
                const elements = typeof selector === 'string' && isHtml(selector)
                    ? // $(<html>)
                        parse(selector, options, false, null).children
                    : isNode(selector)
                        ? // $(dom)
                            [selector]
                        : Array.isArray(selector)
                            ? // $([dom])
                                selector
                            : undefined;
                const instance = new LoadedCheerio(elements, rootInstance, options);
                if (elements) {
                    return instance;
                }
                if (typeof selector !== 'string') {
                    throw new Error('Unexpected type of selector');
                }
                // We know that our selector is a string now.
                let search = selector;
                const searchContext = !context
                    ? // If we don't have a context, maybe we have a root, from loading
                        rootInstance
                    : typeof context === 'string'
                        ? isHtml(context)
                            ? // $('li', '<ul>...</ul>')
                                new LoadedCheerio([parse(context, options, false, null)], rootInstance, options)
                            : // $('li', 'ul')
                                ((search = `${context} ${search}`), rootInstance)
                        : isCheerio(context)
                            ? // $('li', $)
                                context
                            : // $('li', node), $('li', [nodes])
                                new LoadedCheerio(Array.isArray(context) ? context : [context], rootInstance, options);
                // If we still don't have a context, return
                if (!searchContext)
                    return instance;
                /*
                 * #id, .class, tag
                 */
                return searchContext.find(search);
            }
            // Add in static methods & properties
            Object.assign(initialize, staticMethods, {
                load,
                // `_root` and `_options` are used in static methods.
                _root: initialRoot,
                _options: internalOpts,
                // Add `fn` for plugins
                fn: LoadedCheerio.prototype,
                // Add the prototype here to maintain `instanceof` behavior.
                prototype: LoadedCheerio.prototype,
            });
            return initialize;
        };
    }
    function isNode(obj) {
        return (!!obj.name ||
            obj.type === 'root' ||
            obj.type === 'text' ||
            obj.type === 'comment');
    }

    const UNDEFINED_CODE_POINTS = new Set([
        65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214,
        393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894,
        720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574,
        1048575, 1114110, 1114111,
    ]);
    const REPLACEMENT_CHARACTER = '\uFFFD';
    var CODE_POINTS;
    (function (CODE_POINTS) {
        CODE_POINTS[CODE_POINTS["EOF"] = -1] = "EOF";
        CODE_POINTS[CODE_POINTS["NULL"] = 0] = "NULL";
        CODE_POINTS[CODE_POINTS["TABULATION"] = 9] = "TABULATION";
        CODE_POINTS[CODE_POINTS["CARRIAGE_RETURN"] = 13] = "CARRIAGE_RETURN";
        CODE_POINTS[CODE_POINTS["LINE_FEED"] = 10] = "LINE_FEED";
        CODE_POINTS[CODE_POINTS["FORM_FEED"] = 12] = "FORM_FEED";
        CODE_POINTS[CODE_POINTS["SPACE"] = 32] = "SPACE";
        CODE_POINTS[CODE_POINTS["EXCLAMATION_MARK"] = 33] = "EXCLAMATION_MARK";
        CODE_POINTS[CODE_POINTS["QUOTATION_MARK"] = 34] = "QUOTATION_MARK";
        CODE_POINTS[CODE_POINTS["NUMBER_SIGN"] = 35] = "NUMBER_SIGN";
        CODE_POINTS[CODE_POINTS["AMPERSAND"] = 38] = "AMPERSAND";
        CODE_POINTS[CODE_POINTS["APOSTROPHE"] = 39] = "APOSTROPHE";
        CODE_POINTS[CODE_POINTS["HYPHEN_MINUS"] = 45] = "HYPHEN_MINUS";
        CODE_POINTS[CODE_POINTS["SOLIDUS"] = 47] = "SOLIDUS";
        CODE_POINTS[CODE_POINTS["DIGIT_0"] = 48] = "DIGIT_0";
        CODE_POINTS[CODE_POINTS["DIGIT_9"] = 57] = "DIGIT_9";
        CODE_POINTS[CODE_POINTS["SEMICOLON"] = 59] = "SEMICOLON";
        CODE_POINTS[CODE_POINTS["LESS_THAN_SIGN"] = 60] = "LESS_THAN_SIGN";
        CODE_POINTS[CODE_POINTS["EQUALS_SIGN"] = 61] = "EQUALS_SIGN";
        CODE_POINTS[CODE_POINTS["GREATER_THAN_SIGN"] = 62] = "GREATER_THAN_SIGN";
        CODE_POINTS[CODE_POINTS["QUESTION_MARK"] = 63] = "QUESTION_MARK";
        CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_A"] = 65] = "LATIN_CAPITAL_A";
        CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_F"] = 70] = "LATIN_CAPITAL_F";
        CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_X"] = 88] = "LATIN_CAPITAL_X";
        CODE_POINTS[CODE_POINTS["LATIN_CAPITAL_Z"] = 90] = "LATIN_CAPITAL_Z";
        CODE_POINTS[CODE_POINTS["RIGHT_SQUARE_BRACKET"] = 93] = "RIGHT_SQUARE_BRACKET";
        CODE_POINTS[CODE_POINTS["GRAVE_ACCENT"] = 96] = "GRAVE_ACCENT";
        CODE_POINTS[CODE_POINTS["LATIN_SMALL_A"] = 97] = "LATIN_SMALL_A";
        CODE_POINTS[CODE_POINTS["LATIN_SMALL_F"] = 102] = "LATIN_SMALL_F";
        CODE_POINTS[CODE_POINTS["LATIN_SMALL_X"] = 120] = "LATIN_SMALL_X";
        CODE_POINTS[CODE_POINTS["LATIN_SMALL_Z"] = 122] = "LATIN_SMALL_Z";
        CODE_POINTS[CODE_POINTS["REPLACEMENT_CHARACTER"] = 65533] = "REPLACEMENT_CHARACTER";
    })(CODE_POINTS = CODE_POINTS || (CODE_POINTS = {}));
    const SEQUENCES = {
        DASH_DASH: '--',
        CDATA_START: '[CDATA[',
        DOCTYPE: 'doctype',
        SCRIPT: 'script',
        PUBLIC: 'public',
        SYSTEM: 'system',
    };
    //Surrogates
    function isSurrogate(cp) {
        return cp >= 55296 && cp <= 57343;
    }
    function isSurrogatePair(cp) {
        return cp >= 56320 && cp <= 57343;
    }
    function getSurrogatePairCodePoint(cp1, cp2) {
        return (cp1 - 55296) * 1024 + 9216 + cp2;
    }
    //NOTE: excluding NULL and ASCII whitespace
    function isControlCodePoint(cp) {
        return ((cp !== 0x20 && cp !== 0x0a && cp !== 0x0d && cp !== 0x09 && cp !== 0x0c && cp >= 0x01 && cp <= 0x1f) ||
            (cp >= 0x7f && cp <= 0x9f));
    }
    function isUndefinedCodePoint(cp) {
        return (cp >= 64976 && cp <= 65007) || UNDEFINED_CODE_POINTS.has(cp);
    }

    var ERR;
    (function (ERR) {
        ERR["controlCharacterInInputStream"] = "control-character-in-input-stream";
        ERR["noncharacterInInputStream"] = "noncharacter-in-input-stream";
        ERR["surrogateInInputStream"] = "surrogate-in-input-stream";
        ERR["nonVoidHtmlElementStartTagWithTrailingSolidus"] = "non-void-html-element-start-tag-with-trailing-solidus";
        ERR["endTagWithAttributes"] = "end-tag-with-attributes";
        ERR["endTagWithTrailingSolidus"] = "end-tag-with-trailing-solidus";
        ERR["unexpectedSolidusInTag"] = "unexpected-solidus-in-tag";
        ERR["unexpectedNullCharacter"] = "unexpected-null-character";
        ERR["unexpectedQuestionMarkInsteadOfTagName"] = "unexpected-question-mark-instead-of-tag-name";
        ERR["invalidFirstCharacterOfTagName"] = "invalid-first-character-of-tag-name";
        ERR["unexpectedEqualsSignBeforeAttributeName"] = "unexpected-equals-sign-before-attribute-name";
        ERR["missingEndTagName"] = "missing-end-tag-name";
        ERR["unexpectedCharacterInAttributeName"] = "unexpected-character-in-attribute-name";
        ERR["unknownNamedCharacterReference"] = "unknown-named-character-reference";
        ERR["missingSemicolonAfterCharacterReference"] = "missing-semicolon-after-character-reference";
        ERR["unexpectedCharacterAfterDoctypeSystemIdentifier"] = "unexpected-character-after-doctype-system-identifier";
        ERR["unexpectedCharacterInUnquotedAttributeValue"] = "unexpected-character-in-unquoted-attribute-value";
        ERR["eofBeforeTagName"] = "eof-before-tag-name";
        ERR["eofInTag"] = "eof-in-tag";
        ERR["missingAttributeValue"] = "missing-attribute-value";
        ERR["missingWhitespaceBetweenAttributes"] = "missing-whitespace-between-attributes";
        ERR["missingWhitespaceAfterDoctypePublicKeyword"] = "missing-whitespace-after-doctype-public-keyword";
        ERR["missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers"] = "missing-whitespace-between-doctype-public-and-system-identifiers";
        ERR["missingWhitespaceAfterDoctypeSystemKeyword"] = "missing-whitespace-after-doctype-system-keyword";
        ERR["missingQuoteBeforeDoctypePublicIdentifier"] = "missing-quote-before-doctype-public-identifier";
        ERR["missingQuoteBeforeDoctypeSystemIdentifier"] = "missing-quote-before-doctype-system-identifier";
        ERR["missingDoctypePublicIdentifier"] = "missing-doctype-public-identifier";
        ERR["missingDoctypeSystemIdentifier"] = "missing-doctype-system-identifier";
        ERR["abruptDoctypePublicIdentifier"] = "abrupt-doctype-public-identifier";
        ERR["abruptDoctypeSystemIdentifier"] = "abrupt-doctype-system-identifier";
        ERR["cdataInHtmlContent"] = "cdata-in-html-content";
        ERR["incorrectlyOpenedComment"] = "incorrectly-opened-comment";
        ERR["eofInScriptHtmlCommentLikeText"] = "eof-in-script-html-comment-like-text";
        ERR["eofInDoctype"] = "eof-in-doctype";
        ERR["nestedComment"] = "nested-comment";
        ERR["abruptClosingOfEmptyComment"] = "abrupt-closing-of-empty-comment";
        ERR["eofInComment"] = "eof-in-comment";
        ERR["incorrectlyClosedComment"] = "incorrectly-closed-comment";
        ERR["eofInCdata"] = "eof-in-cdata";
        ERR["absenceOfDigitsInNumericCharacterReference"] = "absence-of-digits-in-numeric-character-reference";
        ERR["nullCharacterReference"] = "null-character-reference";
        ERR["surrogateCharacterReference"] = "surrogate-character-reference";
        ERR["characterReferenceOutsideUnicodeRange"] = "character-reference-outside-unicode-range";
        ERR["controlCharacterReference"] = "control-character-reference";
        ERR["noncharacterCharacterReference"] = "noncharacter-character-reference";
        ERR["missingWhitespaceBeforeDoctypeName"] = "missing-whitespace-before-doctype-name";
        ERR["missingDoctypeName"] = "missing-doctype-name";
        ERR["invalidCharacterSequenceAfterDoctypeName"] = "invalid-character-sequence-after-doctype-name";
        ERR["duplicateAttribute"] = "duplicate-attribute";
        ERR["nonConformingDoctype"] = "non-conforming-doctype";
        ERR["missingDoctype"] = "missing-doctype";
        ERR["misplacedDoctype"] = "misplaced-doctype";
        ERR["endTagWithoutMatchingOpenElement"] = "end-tag-without-matching-open-element";
        ERR["closingOfElementWithOpenChildElements"] = "closing-of-element-with-open-child-elements";
        ERR["disallowedContentInNoscriptInHead"] = "disallowed-content-in-noscript-in-head";
        ERR["openElementsLeftAfterEof"] = "open-elements-left-after-eof";
        ERR["abandonedHeadElementChild"] = "abandoned-head-element-child";
        ERR["misplacedStartTagForHeadElement"] = "misplaced-start-tag-for-head-element";
        ERR["nestedNoscriptInHead"] = "nested-noscript-in-head";
        ERR["eofInElementThatCanContainOnlyText"] = "eof-in-element-that-can-contain-only-text";
    })(ERR = ERR || (ERR = {}));

    //Const
    const DEFAULT_BUFFER_WATERLINE = 1 << 16;
    //Preprocessor
    //NOTE: HTML input preprocessing
    //(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)
    class Preprocessor {
        constructor(handler) {
            this.handler = handler;
            this.html = '';
            this.pos = -1;
            // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0
            this.lastGapPos = -2;
            this.gapStack = [];
            this.skipNextNewLine = false;
            this.lastChunkWritten = false;
            this.endOfChunkHit = false;
            this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
            this.isEol = false;
            this.lineStartPos = 0;
            this.droppedBufferSize = 0;
            this.line = 1;
            //NOTE: avoid reporting errors twice on advance/retreat
            this.lastErrOffset = -1;
        }
        /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
        get col() {
            return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);
        }
        get offset() {
            return this.droppedBufferSize + this.pos;
        }
        getError(code) {
            const { line, col, offset } = this;
            return {
                code,
                startLine: line,
                endLine: line,
                startCol: col,
                endCol: col,
                startOffset: offset,
                endOffset: offset,
            };
        }
        _err(code) {
            if (this.handler.onParseError && this.lastErrOffset !== this.offset) {
                this.lastErrOffset = this.offset;
                this.handler.onParseError(this.getError(code));
            }
        }
        _addGap() {
            this.gapStack.push(this.lastGapPos);
            this.lastGapPos = this.pos;
        }
        _processSurrogate(cp) {
            //NOTE: try to peek a surrogate pair
            if (this.pos !== this.html.length - 1) {
                const nextCp = this.html.charCodeAt(this.pos + 1);
                if (isSurrogatePair(nextCp)) {
                    //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.
                    this.pos++;
                    //NOTE: add a gap that should be avoided during retreat
                    this._addGap();
                    return getSurrogatePairCodePoint(cp, nextCp);
                }
            }
            //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.
            else if (!this.lastChunkWritten) {
                this.endOfChunkHit = true;
                return CODE_POINTS.EOF;
            }
            //NOTE: isolated surrogate
            this._err(ERR.surrogateInInputStream);
            return cp;
        }
        willDropParsedChunk() {
            return this.pos > this.bufferWaterline;
        }
        dropParsedChunk() {
            if (this.willDropParsedChunk()) {
                this.html = this.html.substring(this.pos);
                this.lineStartPos -= this.pos;
                this.droppedBufferSize += this.pos;
                this.pos = 0;
                this.lastGapPos = -2;
                this.gapStack.length = 0;
            }
        }
        write(chunk, isLastChunk) {
            if (this.html.length > 0) {
                this.html += chunk;
            }
            else {
                this.html = chunk;
            }
            this.endOfChunkHit = false;
            this.lastChunkWritten = isLastChunk;
        }
        insertHtmlAtCurrentPos(chunk) {
            this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);
            this.endOfChunkHit = false;
        }
        startsWith(pattern, caseSensitive) {
            // Check if our buffer has enough characters
            if (this.pos + pattern.length > this.html.length) {
                this.endOfChunkHit = !this.lastChunkWritten;
                return false;
            }
            if (caseSensitive) {
                return this.html.startsWith(pattern, this.pos);
            }
            for (let i = 0; i < pattern.length; i++) {
                const cp = this.html.charCodeAt(this.pos + i) | 0x20;
                if (cp !== pattern.charCodeAt(i)) {
                    return false;
                }
            }
            return true;
        }
        peek(offset) {
            const pos = this.pos + offset;
            if (pos >= this.html.length) {
                this.endOfChunkHit = !this.lastChunkWritten;
                return CODE_POINTS.EOF;
            }
            const code = this.html.charCodeAt(pos);
            return code === CODE_POINTS.CARRIAGE_RETURN ? CODE_POINTS.LINE_FEED : code;
        }
        advance() {
            this.pos++;
            //NOTE: LF should be in the last column of the line
            if (this.isEol) {
                this.isEol = false;
                this.line++;
                this.lineStartPos = this.pos;
            }
            if (this.pos >= this.html.length) {
                this.endOfChunkHit = !this.lastChunkWritten;
                return CODE_POINTS.EOF;
            }
            let cp = this.html.charCodeAt(this.pos);
            //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters
            if (cp === CODE_POINTS.CARRIAGE_RETURN) {
                this.isEol = true;
                this.skipNextNewLine = true;
                return CODE_POINTS.LINE_FEED;
            }
            //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character
            //must be ignored.
            if (cp === CODE_POINTS.LINE_FEED) {
                this.isEol = true;
                if (this.skipNextNewLine) {
                    // `line` will be bumped again in the recursive call.
                    this.line--;
                    this.skipNextNewLine = false;
                    this._addGap();
                    return this.advance();
                }
            }
            this.skipNextNewLine = false;
            if (isSurrogate(cp)) {
                cp = this._processSurrogate(cp);
            }
            //OPTIMIZATION: first check if code point is in the common allowed
            //range (ASCII alphanumeric, whitespaces, big chunk of BMP)
            //before going into detailed performance cost validation.
            const isCommonValidRange = this.handler.onParseError === null ||
                (cp > 0x1f && cp < 0x7f) ||
                cp === CODE_POINTS.LINE_FEED ||
                cp === CODE_POINTS.CARRIAGE_RETURN ||
                (cp > 0x9f && cp < 64976);
            if (!isCommonValidRange) {
                this._checkForProblematicCharacters(cp);
            }
            return cp;
        }
        _checkForProblematicCharacters(cp) {
            if (isControlCodePoint(cp)) {
                this._err(ERR.controlCharacterInInputStream);
            }
            else if (isUndefinedCodePoint(cp)) {
                this._err(ERR.noncharacterInInputStream);
            }
        }
        retreat(count) {
            this.pos -= count;
            while (this.pos < this.lastGapPos) {
                this.lastGapPos = this.gapStack.pop();
                this.pos--;
            }
            this.isEol = false;
        }
    }

    var TokenType;
    (function (TokenType) {
        TokenType[TokenType["CHARACTER"] = 0] = "CHARACTER";
        TokenType[TokenType["NULL_CHARACTER"] = 1] = "NULL_CHARACTER";
        TokenType[TokenType["WHITESPACE_CHARACTER"] = 2] = "WHITESPACE_CHARACTER";
        TokenType[TokenType["START_TAG"] = 3] = "START_TAG";
        TokenType[TokenType["END_TAG"] = 4] = "END_TAG";
        TokenType[TokenType["COMMENT"] = 5] = "COMMENT";
        TokenType[TokenType["DOCTYPE"] = 6] = "DOCTYPE";
        TokenType[TokenType["EOF"] = 7] = "EOF";
        TokenType[TokenType["HIBERNATION"] = 8] = "HIBERNATION";
    })(TokenType = TokenType || (TokenType = {}));
    function getTokenAttr(token, attrName) {
        for (let i = token.attrs.length - 1; i >= 0; i--) {
            if (token.attrs[i].name === attrName) {
                return token.attrs[i].value;
            }
        }
        return null;
    }

    /** All valid namespaces in HTML. */
    var NS;
    (function (NS) {
        NS["HTML"] = "http://www.w3.org/1999/xhtml";
        NS["MATHML"] = "http://www.w3.org/1998/Math/MathML";
        NS["SVG"] = "http://www.w3.org/2000/svg";
        NS["XLINK"] = "http://www.w3.org/1999/xlink";
        NS["XML"] = "http://www.w3.org/XML/1998/namespace";
        NS["XMLNS"] = "http://www.w3.org/2000/xmlns/";
    })(NS = NS || (NS = {}));
    var ATTRS;
    (function (ATTRS) {
        ATTRS["TYPE"] = "type";
        ATTRS["ACTION"] = "action";
        ATTRS["ENCODING"] = "encoding";
        ATTRS["PROMPT"] = "prompt";
        ATTRS["NAME"] = "name";
        ATTRS["COLOR"] = "color";
        ATTRS["FACE"] = "face";
        ATTRS["SIZE"] = "size";
    })(ATTRS = ATTRS || (ATTRS = {}));
    /**
     * The mode of the document.
     *
     * @see {@link https://dom.spec.whatwg.org/#concept-document-limited-quirks}
     */
    var DOCUMENT_MODE;
    (function (DOCUMENT_MODE) {
        DOCUMENT_MODE["NO_QUIRKS"] = "no-quirks";
        DOCUMENT_MODE["QUIRKS"] = "quirks";
        DOCUMENT_MODE["LIMITED_QUIRKS"] = "limited-quirks";
    })(DOCUMENT_MODE = DOCUMENT_MODE || (DOCUMENT_MODE = {}));
    var TAG_NAMES;
    (function (TAG_NAMES) {
        TAG_NAMES["A"] = "a";
        TAG_NAMES["ADDRESS"] = "address";
        TAG_NAMES["ANNOTATION_XML"] = "annotation-xml";
        TAG_NAMES["APPLET"] = "applet";
        TAG_NAMES["AREA"] = "area";
        TAG_NAMES["ARTICLE"] = "article";
        TAG_NAMES["ASIDE"] = "aside";
        TAG_NAMES["B"] = "b";
        TAG_NAMES["BASE"] = "base";
        TAG_NAMES["BASEFONT"] = "basefont";
        TAG_NAMES["BGSOUND"] = "bgsound";
        TAG_NAMES["BIG"] = "big";
        TAG_NAMES["BLOCKQUOTE"] = "blockquote";
        TAG_NAMES["BODY"] = "body";
        TAG_NAMES["BR"] = "br";
        TAG_NAMES["BUTTON"] = "button";
        TAG_NAMES["CAPTION"] = "caption";
        TAG_NAMES["CENTER"] = "center";
        TAG_NAMES["CODE"] = "code";
        TAG_NAMES["COL"] = "col";
        TAG_NAMES["COLGROUP"] = "colgroup";
        TAG_NAMES["DD"] = "dd";
        TAG_NAMES["DESC"] = "desc";
        TAG_NAMES["DETAILS"] = "details";
        TAG_NAMES["DIALOG"] = "dialog";
        TAG_NAMES["DIR"] = "dir";
        TAG_NAMES["DIV"] = "div";
        TAG_NAMES["DL"] = "dl";
        TAG_NAMES["DT"] = "dt";
        TAG_NAMES["EM"] = "em";
        TAG_NAMES["EMBED"] = "embed";
        TAG_NAMES["FIELDSET"] = "fieldset";
        TAG_NAMES["FIGCAPTION"] = "figcaption";
        TAG_NAMES["FIGURE"] = "figure";
        TAG_NAMES["FONT"] = "font";
        TAG_NAMES["FOOTER"] = "footer";
        TAG_NAMES["FOREIGN_OBJECT"] = "foreignObject";
        TAG_NAMES["FORM"] = "form";
        TAG_NAMES["FRAME"] = "frame";
        TAG_NAMES["FRAMESET"] = "frameset";
        TAG_NAMES["H1"] = "h1";
        TAG_NAMES["H2"] = "h2";
        TAG_NAMES["H3"] = "h3";
        TAG_NAMES["H4"] = "h4";
        TAG_NAMES["H5"] = "h5";
        TAG_NAMES["H6"] = "h6";
        TAG_NAMES["HEAD"] = "head";
        TAG_NAMES["HEADER"] = "header";
        TAG_NAMES["HGROUP"] = "hgroup";
        TAG_NAMES["HR"] = "hr";
        TAG_NAMES["HTML"] = "html";
        TAG_NAMES["I"] = "i";
        TAG_NAMES["IMG"] = "img";
        TAG_NAMES["IMAGE"] = "image";
        TAG_NAMES["INPUT"] = "input";
        TAG_NAMES["IFRAME"] = "iframe";
        TAG_NAMES["KEYGEN"] = "keygen";
        TAG_NAMES["LABEL"] = "label";
        TAG_NAMES["LI"] = "li";
        TAG_NAMES["LINK"] = "link";
        TAG_NAMES["LISTING"] = "listing";
        TAG_NAMES["MAIN"] = "main";
        TAG_NAMES["MALIGNMARK"] = "malignmark";
        TAG_NAMES["MARQUEE"] = "marquee";
        TAG_NAMES["MATH"] = "math";
        TAG_NAMES["MENU"] = "menu";
        TAG_NAMES["META"] = "meta";
        TAG_NAMES["MGLYPH"] = "mglyph";
        TAG_NAMES["MI"] = "mi";
        TAG_NAMES["MO"] = "mo";
        TAG_NAMES["MN"] = "mn";
        TAG_NAMES["MS"] = "ms";
        TAG_NAMES["MTEXT"] = "mtext";
        TAG_NAMES["NAV"] = "nav";
        TAG_NAMES["NOBR"] = "nobr";
        TAG_NAMES["NOFRAMES"] = "noframes";
        TAG_NAMES["NOEMBED"] = "noembed";
        TAG_NAMES["NOSCRIPT"] = "noscript";
        TAG_NAMES["OBJECT"] = "object";
        TAG_NAMES["OL"] = "ol";
        TAG_NAMES["OPTGROUP"] = "optgroup";
        TAG_NAMES["OPTION"] = "option";
        TAG_NAMES["P"] = "p";
        TAG_NAMES["PARAM"] = "param";
        TAG_NAMES["PLAINTEXT"] = "plaintext";
        TAG_NAMES["PRE"] = "pre";
        TAG_NAMES["RB"] = "rb";
        TAG_NAMES["RP"] = "rp";
        TAG_NAMES["RT"] = "rt";
        TAG_NAMES["RTC"] = "rtc";
        TAG_NAMES["RUBY"] = "ruby";
        TAG_NAMES["S"] = "s";
        TAG_NAMES["SCRIPT"] = "script";
        TAG_NAMES["SECTION"] = "section";
        TAG_NAMES["SELECT"] = "select";
        TAG_NAMES["SOURCE"] = "source";
        TAG_NAMES["SMALL"] = "small";
        TAG_NAMES["SPAN"] = "span";
        TAG_NAMES["STRIKE"] = "strike";
        TAG_NAMES["STRONG"] = "strong";
        TAG_NAMES["STYLE"] = "style";
        TAG_NAMES["SUB"] = "sub";
        TAG_NAMES["SUMMARY"] = "summary";
        TAG_NAMES["SUP"] = "sup";
        TAG_NAMES["TABLE"] = "table";
        TAG_NAMES["TBODY"] = "tbody";
        TAG_NAMES["TEMPLATE"] = "template";
        TAG_NAMES["TEXTAREA"] = "textarea";
        TAG_NAMES["TFOOT"] = "tfoot";
        TAG_NAMES["TD"] = "td";
        TAG_NAMES["TH"] = "th";
        TAG_NAMES["THEAD"] = "thead";
        TAG_NAMES["TITLE"] = "title";
        TAG_NAMES["TR"] = "tr";
        TAG_NAMES["TRACK"] = "track";
        TAG_NAMES["TT"] = "tt";
        TAG_NAMES["U"] = "u";
        TAG_NAMES["UL"] = "ul";
        TAG_NAMES["SVG"] = "svg";
        TAG_NAMES["VAR"] = "var";
        TAG_NAMES["WBR"] = "wbr";
        TAG_NAMES["XMP"] = "xmp";
    })(TAG_NAMES = TAG_NAMES || (TAG_NAMES = {}));
    /**
     * Tag IDs are numeric IDs for known tag names.
     *
     * We use tag IDs to improve the performance of tag name comparisons.
     */
    var TAG_ID;
    (function (TAG_ID) {
        TAG_ID[TAG_ID["UNKNOWN"] = 0] = "UNKNOWN";
        TAG_ID[TAG_ID["A"] = 1] = "A";
        TAG_ID[TAG_ID["ADDRESS"] = 2] = "ADDRESS";
        TAG_ID[TAG_ID["ANNOTATION_XML"] = 3] = "ANNOTATION_XML";
        TAG_ID[TAG_ID["APPLET"] = 4] = "APPLET";
        TAG_ID[TAG_ID["AREA"] = 5] = "AREA";
        TAG_ID[TAG_ID["ARTICLE"] = 6] = "ARTICLE";
        TAG_ID[TAG_ID["ASIDE"] = 7] = "ASIDE";
        TAG_ID[TAG_ID["B"] = 8] = "B";
        TAG_ID[TAG_ID["BASE"] = 9] = "BASE";
        TAG_ID[TAG_ID["BASEFONT"] = 10] = "BASEFONT";
        TAG_ID[TAG_ID["BGSOUND"] = 11] = "BGSOUND";
        TAG_ID[TAG_ID["BIG"] = 12] = "BIG";
        TAG_ID[TAG_ID["BLOCKQUOTE"] = 13] = "BLOCKQUOTE";
        TAG_ID[TAG_ID["BODY"] = 14] = "BODY";
        TAG_ID[TAG_ID["BR"] = 15] = "BR";
        TAG_ID[TAG_ID["BUTTON"] = 16] = "BUTTON";
        TAG_ID[TAG_ID["CAPTION"] = 17] = "CAPTION";
        TAG_ID[TAG_ID["CENTER"] = 18] = "CENTER";
        TAG_ID[TAG_ID["CODE"] = 19] = "CODE";
        TAG_ID[TAG_ID["COL"] = 20] = "COL";
        TAG_ID[TAG_ID["COLGROUP"] = 21] = "COLGROUP";
        TAG_ID[TAG_ID["DD"] = 22] = "DD";
        TAG_ID[TAG_ID["DESC"] = 23] = "DESC";
        TAG_ID[TAG_ID["DETAILS"] = 24] = "DETAILS";
        TAG_ID[TAG_ID["DIALOG"] = 25] = "DIALOG";
        TAG_ID[TAG_ID["DIR"] = 26] = "DIR";
        TAG_ID[TAG_ID["DIV"] = 27] = "DIV";
        TAG_ID[TAG_ID["DL"] = 28] = "DL";
        TAG_ID[TAG_ID["DT"] = 29] = "DT";
        TAG_ID[TAG_ID["EM"] = 30] = "EM";
        TAG_ID[TAG_ID["EMBED"] = 31] = "EMBED";
        TAG_ID[TAG_ID["FIELDSET"] = 32] = "FIELDSET";
        TAG_ID[TAG_ID["FIGCAPTION"] = 33] = "FIGCAPTION";
        TAG_ID[TAG_ID["FIGURE"] = 34] = "FIGURE";
        TAG_ID[TAG_ID["FONT"] = 35] = "FONT";
        TAG_ID[TAG_ID["FOOTER"] = 36] = "FOOTER";
        TAG_ID[TAG_ID["FOREIGN_OBJECT"] = 37] = "FOREIGN_OBJECT";
        TAG_ID[TAG_ID["FORM"] = 38] = "FORM";
        TAG_ID[TAG_ID["FRAME"] = 39] = "FRAME";
        TAG_ID[TAG_ID["FRAMESET"] = 40] = "FRAMESET";
        TAG_ID[TAG_ID["H1"] = 41] = "H1";
        TAG_ID[TAG_ID["H2"] = 42] = "H2";
        TAG_ID[TAG_ID["H3"] = 43] = "H3";
        TAG_ID[TAG_ID["H4"] = 44] = "H4";
        TAG_ID[TAG_ID["H5"] = 45] = "H5";
        TAG_ID[TAG_ID["H6"] = 46] = "H6";
        TAG_ID[TAG_ID["HEAD"] = 47] = "HEAD";
        TAG_ID[TAG_ID["HEADER"] = 48] = "HEADER";
        TAG_ID[TAG_ID["HGROUP"] = 49] = "HGROUP";
        TAG_ID[TAG_ID["HR"] = 50] = "HR";
        TAG_ID[TAG_ID["HTML"] = 51] = "HTML";
        TAG_ID[TAG_ID["I"] = 52] = "I";
        TAG_ID[TAG_ID["IMG"] = 53] = "IMG";
        TAG_ID[TAG_ID["IMAGE"] = 54] = "IMAGE";
        TAG_ID[TAG_ID["INPUT"] = 55] = "INPUT";
        TAG_ID[TAG_ID["IFRAME"] = 56] = "IFRAME";
        TAG_ID[TAG_ID["KEYGEN"] = 57] = "KEYGEN";
        TAG_ID[TAG_ID["LABEL"] = 58] = "LABEL";
        TAG_ID[TAG_ID["LI"] = 59] = "LI";
        TAG_ID[TAG_ID["LINK"] = 60] = "LINK";
        TAG_ID[TAG_ID["LISTING"] = 61] = "LISTING";
        TAG_ID[TAG_ID["MAIN"] = 62] = "MAIN";
        TAG_ID[TAG_ID["MALIGNMARK"] = 63] = "MALIGNMARK";
        TAG_ID[TAG_ID["MARQUEE"] = 64] = "MARQUEE";
        TAG_ID[TAG_ID["MATH"] = 65] = "MATH";
        TAG_ID[TAG_ID["MENU"] = 66] = "MENU";
        TAG_ID[TAG_ID["META"] = 67] = "META";
        TAG_ID[TAG_ID["MGLYPH"] = 68] = "MGLYPH";
        TAG_ID[TAG_ID["MI"] = 69] = "MI";
        TAG_ID[TAG_ID["MO"] = 70] = "MO";
        TAG_ID[TAG_ID["MN"] = 71] = "MN";
        TAG_ID[TAG_ID["MS"] = 72] = "MS";
        TAG_ID[TAG_ID["MTEXT"] = 73] = "MTEXT";
        TAG_ID[TAG_ID["NAV"] = 74] = "NAV";
        TAG_ID[TAG_ID["NOBR"] = 75] = "NOBR";
        TAG_ID[TAG_ID["NOFRAMES"] = 76] = "NOFRAMES";
        TAG_ID[TAG_ID["NOEMBED"] = 77] = "NOEMBED";
        TAG_ID[TAG_ID["NOSCRIPT"] = 78] = "NOSCRIPT";
        TAG_ID[TAG_ID["OBJECT"] = 79] = "OBJECT";
        TAG_ID[TAG_ID["OL"] = 80] = "OL";
        TAG_ID[TAG_ID["OPTGROUP"] = 81] = "OPTGROUP";
        TAG_ID[TAG_ID["OPTION"] = 82] = "OPTION";
        TAG_ID[TAG_ID["P"] = 83] = "P";
        TAG_ID[TAG_ID["PARAM"] = 84] = "PARAM";
        TAG_ID[TAG_ID["PLAINTEXT"] = 85] = "PLAINTEXT";
        TAG_ID[TAG_ID["PRE"] = 86] = "PRE";
        TAG_ID[TAG_ID["RB"] = 87] = "RB";
        TAG_ID[TAG_ID["RP"] = 88] = "RP";
        TAG_ID[TAG_ID["RT"] = 89] = "RT";
        TAG_ID[TAG_ID["RTC"] = 90] = "RTC";
        TAG_ID[TAG_ID["RUBY"] = 91] = "RUBY";
        TAG_ID[TAG_ID["S"] = 92] = "S";
        TAG_ID[TAG_ID["SCRIPT"] = 93] = "SCRIPT";
        TAG_ID[TAG_ID["SECTION"] = 94] = "SECTION";
        TAG_ID[TAG_ID["SELECT"] = 95] = "SELECT";
        TAG_ID[TAG_ID["SOURCE"] = 96] = "SOURCE";
        TAG_ID[TAG_ID["SMALL"] = 97] = "SMALL";
        TAG_ID[TAG_ID["SPAN"] = 98] = "SPAN";
        TAG_ID[TAG_ID["STRIKE"] = 99] = "STRIKE";
        TAG_ID[TAG_ID["STRONG"] = 100] = "STRONG";
        TAG_ID[TAG_ID["STYLE"] = 101] = "STYLE";
        TAG_ID[TAG_ID["SUB"] = 102] = "SUB";
        TAG_ID[TAG_ID["SUMMARY"] = 103] = "SUMMARY";
        TAG_ID[TAG_ID["SUP"] = 104] = "SUP";
        TAG_ID[TAG_ID["TABLE"] = 105] = "TABLE";
        TAG_ID[TAG_ID["TBODY"] = 106] = "TBODY";
        TAG_ID[TAG_ID["TEMPLATE"] = 107] = "TEMPLATE";
        TAG_ID[TAG_ID["TEXTAREA"] = 108] = "TEXTAREA";
        TAG_ID[TAG_ID["TFOOT"] = 109] = "TFOOT";
        TAG_ID[TAG_ID["TD"] = 110] = "TD";
        TAG_ID[TAG_ID["TH"] = 111] = "TH";
        TAG_ID[TAG_ID["THEAD"] = 112] = "THEAD";
        TAG_ID[TAG_ID["TITLE"] = 113] = "TITLE";
        TAG_ID[TAG_ID["TR"] = 114] = "TR";
        TAG_ID[TAG_ID["TRACK"] = 115] = "TRACK";
        TAG_ID[TAG_ID["TT"] = 116] = "TT";
        TAG_ID[TAG_ID["U"] = 117] = "U";
        TAG_ID[TAG_ID["UL"] = 118] = "UL";
        TAG_ID[TAG_ID["SVG"] = 119] = "SVG";
        TAG_ID[TAG_ID["VAR"] = 120] = "VAR";
        TAG_ID[TAG_ID["WBR"] = 121] = "WBR";
        TAG_ID[TAG_ID["XMP"] = 122] = "XMP";
    })(TAG_ID = TAG_ID || (TAG_ID = {}));
    const TAG_NAME_TO_ID = new Map([
        [TAG_NAMES.A, TAG_ID.A],
        [TAG_NAMES.ADDRESS, TAG_ID.ADDRESS],
        [TAG_NAMES.ANNOTATION_XML, TAG_ID.ANNOTATION_XML],
        [TAG_NAMES.APPLET, TAG_ID.APPLET],
        [TAG_NAMES.AREA, TAG_ID.AREA],
        [TAG_NAMES.ARTICLE, TAG_ID.ARTICLE],
        [TAG_NAMES.ASIDE, TAG_ID.ASIDE],
        [TAG_NAMES.B, TAG_ID.B],
        [TAG_NAMES.BASE, TAG_ID.BASE],
        [TAG_NAMES.BASEFONT, TAG_ID.BASEFONT],
        [TAG_NAMES.BGSOUND, TAG_ID.BGSOUND],
        [TAG_NAMES.BIG, TAG_ID.BIG],
        [TAG_NAMES.BLOCKQUOTE, TAG_ID.BLOCKQUOTE],
        [TAG_NAMES.BODY, TAG_ID.BODY],
        [TAG_NAMES.BR, TAG_ID.BR],
        [TAG_NAMES.BUTTON, TAG_ID.BUTTON],
        [TAG_NAMES.CAPTION, TAG_ID.CAPTION],
        [TAG_NAMES.CENTER, TAG_ID.CENTER],
        [TAG_NAMES.CODE, TAG_ID.CODE],
        [TAG_NAMES.COL, TAG_ID.COL],
        [TAG_NAMES.COLGROUP, TAG_ID.COLGROUP],
        [TAG_NAMES.DD, TAG_ID.DD],
        [TAG_NAMES.DESC, TAG_ID.DESC],
        [TAG_NAMES.DETAILS, TAG_ID.DETAILS],
        [TAG_NAMES.DIALOG, TAG_ID.DIALOG],
        [TAG_NAMES.DIR, TAG_ID.DIR],
        [TAG_NAMES.DIV, TAG_ID.DIV],
        [TAG_NAMES.DL, TAG_ID.DL],
        [TAG_NAMES.DT, TAG_ID.DT],
        [TAG_NAMES.EM, TAG_ID.EM],
        [TAG_NAMES.EMBED, TAG_ID.EMBED],
        [TAG_NAMES.FIELDSET, TAG_ID.FIELDSET],
        [TAG_NAMES.FIGCAPTION, TAG_ID.FIGCAPTION],
        [TAG_NAMES.FIGURE, TAG_ID.FIGURE],
        [TAG_NAMES.FONT, TAG_ID.FONT],
        [TAG_NAMES.FOOTER, TAG_ID.FOOTER],
        [TAG_NAMES.FOREIGN_OBJECT, TAG_ID.FOREIGN_OBJECT],
        [TAG_NAMES.FORM, TAG_ID.FORM],
        [TAG_NAMES.FRAME, TAG_ID.FRAME],
        [TAG_NAMES.FRAMESET, TAG_ID.FRAMESET],
        [TAG_NAMES.H1, TAG_ID.H1],
        [TAG_NAMES.H2, TAG_ID.H2],
        [TAG_NAMES.H3, TAG_ID.H3],
        [TAG_NAMES.H4, TAG_ID.H4],
        [TAG_NAMES.H5, TAG_ID.H5],
        [TAG_NAMES.H6, TAG_ID.H6],
        [TAG_NAMES.HEAD, TAG_ID.HEAD],
        [TAG_NAMES.HEADER, TAG_ID.HEADER],
        [TAG_NAMES.HGROUP, TAG_ID.HGROUP],
        [TAG_NAMES.HR, TAG_ID.HR],
        [TAG_NAMES.HTML, TAG_ID.HTML],
        [TAG_NAMES.I, TAG_ID.I],
        [TAG_NAMES.IMG, TAG_ID.IMG],
        [TAG_NAMES.IMAGE, TAG_ID.IMAGE],
        [TAG_NAMES.INPUT, TAG_ID.INPUT],
        [TAG_NAMES.IFRAME, TAG_ID.IFRAME],
        [TAG_NAMES.KEYGEN, TAG_ID.KEYGEN],
        [TAG_NAMES.LABEL, TAG_ID.LABEL],
        [TAG_NAMES.LI, TAG_ID.LI],
        [TAG_NAMES.LINK, TAG_ID.LINK],
        [TAG_NAMES.LISTING, TAG_ID.LISTING],
        [TAG_NAMES.MAIN, TAG_ID.MAIN],
        [TAG_NAMES.MALIGNMARK, TAG_ID.MALIGNMARK],
        [TAG_NAMES.MARQUEE, TAG_ID.MARQUEE],
        [TAG_NAMES.MATH, TAG_ID.MATH],
        [TAG_NAMES.MENU, TAG_ID.MENU],
        [TAG_NAMES.META, TAG_ID.META],
        [TAG_NAMES.MGLYPH, TAG_ID.MGLYPH],
        [TAG_NAMES.MI, TAG_ID.MI],
        [TAG_NAMES.MO, TAG_ID.MO],
        [TAG_NAMES.MN, TAG_ID.MN],
        [TAG_NAMES.MS, TAG_ID.MS],
        [TAG_NAMES.MTEXT, TAG_ID.MTEXT],
        [TAG_NAMES.NAV, TAG_ID.NAV],
        [TAG_NAMES.NOBR, TAG_ID.NOBR],
        [TAG_NAMES.NOFRAMES, TAG_ID.NOFRAMES],
        [TAG_NAMES.NOEMBED, TAG_ID.NOEMBED],
        [TAG_NAMES.NOSCRIPT, TAG_ID.NOSCRIPT],
        [TAG_NAMES.OBJECT, TAG_ID.OBJECT],
        [TAG_NAMES.OL, TAG_ID.OL],
        [TAG_NAMES.OPTGROUP, TAG_ID.OPTGROUP],
        [TAG_NAMES.OPTION, TAG_ID.OPTION],
        [TAG_NAMES.P, TAG_ID.P],
        [TAG_NAMES.PARAM, TAG_ID.PARAM],
        [TAG_NAMES.PLAINTEXT, TAG_ID.PLAINTEXT],
        [TAG_NAMES.PRE, TAG_ID.PRE],
        [TAG_NAMES.RB, TAG_ID.RB],
        [TAG_NAMES.RP, TAG_ID.RP],
        [TAG_NAMES.RT, TAG_ID.RT],
        [TAG_NAMES.RTC, TAG_ID.RTC],
        [TAG_NAMES.RUBY, TAG_ID.RUBY],
        [TAG_NAMES.S, TAG_ID.S],
        [TAG_NAMES.SCRIPT, TAG_ID.SCRIPT],
        [TAG_NAMES.SECTION, TAG_ID.SECTION],
        [TAG_NAMES.SELECT, TAG_ID.SELECT],
        [TAG_NAMES.SOURCE, TAG_ID.SOURCE],
        [TAG_NAMES.SMALL, TAG_ID.SMALL],
        [TAG_NAMES.SPAN, TAG_ID.SPAN],
        [TAG_NAMES.STRIKE, TAG_ID.STRIKE],
        [TAG_NAMES.STRONG, TAG_ID.STRONG],
        [TAG_NAMES.STYLE, TAG_ID.STYLE],
        [TAG_NAMES.SUB, TAG_ID.SUB],
        [TAG_NAMES.SUMMARY, TAG_ID.SUMMARY],
        [TAG_NAMES.SUP, TAG_ID.SUP],
        [TAG_NAMES.TABLE, TAG_ID.TABLE],
        [TAG_NAMES.TBODY, TAG_ID.TBODY],
        [TAG_NAMES.TEMPLATE, TAG_ID.TEMPLATE],
        [TAG_NAMES.TEXTAREA, TAG_ID.TEXTAREA],
        [TAG_NAMES.TFOOT, TAG_ID.TFOOT],
        [TAG_NAMES.TD, TAG_ID.TD],
        [TAG_NAMES.TH, TAG_ID.TH],
        [TAG_NAMES.THEAD, TAG_ID.THEAD],
        [TAG_NAMES.TITLE, TAG_ID.TITLE],
        [TAG_NAMES.TR, TAG_ID.TR],
        [TAG_NAMES.TRACK, TAG_ID.TRACK],
        [TAG_NAMES.TT, TAG_ID.TT],
        [TAG_NAMES.U, TAG_ID.U],
        [TAG_NAMES.UL, TAG_ID.UL],
        [TAG_NAMES.SVG, TAG_ID.SVG],
        [TAG_NAMES.VAR, TAG_ID.VAR],
        [TAG_NAMES.WBR, TAG_ID.WBR],
        [TAG_NAMES.XMP, TAG_ID.XMP],
    ]);
    function getTagID(tagName) {
        var _a;
        return (_a = TAG_NAME_TO_ID.get(tagName)) !== null && _a !== void 0 ? _a : TAG_ID.UNKNOWN;
    }
    const $ = TAG_ID;
    const SPECIAL_ELEMENTS = {
        [NS.HTML]: new Set([
            $.ADDRESS,
            $.APPLET,
            $.AREA,
            $.ARTICLE,
            $.ASIDE,
            $.BASE,
            $.BASEFONT,
            $.BGSOUND,
            $.BLOCKQUOTE,
            $.BODY,
            $.BR,
            $.BUTTON,
            $.CAPTION,
            $.CENTER,
            $.COL,
            $.COLGROUP,
            $.DD,
            $.DETAILS,
            $.DIR,
            $.DIV,
            $.DL,
            $.DT,
            $.EMBED,
            $.FIELDSET,
            $.FIGCAPTION,
            $.FIGURE,
            $.FOOTER,
            $.FORM,
            $.FRAME,
            $.FRAMESET,
            $.H1,
            $.H2,
            $.H3,
            $.H4,
            $.H5,
            $.H6,
            $.HEAD,
            $.HEADER,
            $.HGROUP,
            $.HR,
            $.HTML,
            $.IFRAME,
            $.IMG,
            $.INPUT,
            $.LI,
            $.LINK,
            $.LISTING,
            $.MAIN,
            $.MARQUEE,
            $.MENU,
            $.META,
            $.NAV,
            $.NOEMBED,
            $.NOFRAMES,
            $.NOSCRIPT,
            $.OBJECT,
            $.OL,
            $.P,
            $.PARAM,
            $.PLAINTEXT,
            $.PRE,
            $.SCRIPT,
            $.SECTION,
            $.SELECT,
            $.SOURCE,
            $.STYLE,
            $.SUMMARY,
            $.TABLE,
            $.TBODY,
            $.TD,
            $.TEMPLATE,
            $.TEXTAREA,
            $.TFOOT,
            $.TH,
            $.THEAD,
            $.TITLE,
            $.TR,
            $.TRACK,
            $.UL,
            $.WBR,
            $.XMP,
        ]),
        [NS.MATHML]: new Set([$.MI, $.MO, $.MN, $.MS, $.MTEXT, $.ANNOTATION_XML]),
        [NS.SVG]: new Set([$.TITLE, $.FOREIGN_OBJECT, $.DESC]),
        [NS.XLINK]: new Set(),
        [NS.XML]: new Set(),
        [NS.XMLNS]: new Set(),
    };
    function isNumberedHeader(tn) {
        return tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6;
    }
    const UNESCAPED_TEXT = new Set([
        TAG_NAMES.STYLE,
        TAG_NAMES.SCRIPT,
        TAG_NAMES.XMP,
        TAG_NAMES.IFRAME,
        TAG_NAMES.NOEMBED,
        TAG_NAMES.NOFRAMES,
        TAG_NAMES.PLAINTEXT,
    ]);
    function hasUnescapedText(tn, scriptingEnabled) {
        return UNESCAPED_TEXT.has(tn) || (scriptingEnabled && tn === TAG_NAMES.NOSCRIPT);
    }

    //C1 Unicode control character reference replacements
    const C1_CONTROLS_REFERENCE_REPLACEMENTS = new Map([
        [0x80, 8364],
        [0x82, 8218],
        [0x83, 402],
        [0x84, 8222],
        [0x85, 8230],
        [0x86, 8224],
        [0x87, 8225],
        [0x88, 710],
        [0x89, 8240],
        [0x8a, 352],
        [0x8b, 8249],
        [0x8c, 338],
        [0x8e, 381],
        [0x91, 8216],
        [0x92, 8217],
        [0x93, 8220],
        [0x94, 8221],
        [0x95, 8226],
        [0x96, 8211],
        [0x97, 8212],
        [0x98, 732],
        [0x99, 8482],
        [0x9a, 353],
        [0x9b, 8250],
        [0x9c, 339],
        [0x9e, 382],
        [0x9f, 376],
    ]);
    //States
    var State$1;
    (function (State) {
        State[State["DATA"] = 0] = "DATA";
        State[State["RCDATA"] = 1] = "RCDATA";
        State[State["RAWTEXT"] = 2] = "RAWTEXT";
        State[State["SCRIPT_DATA"] = 3] = "SCRIPT_DATA";
        State[State["PLAINTEXT"] = 4] = "PLAINTEXT";
        State[State["TAG_OPEN"] = 5] = "TAG_OPEN";
        State[State["END_TAG_OPEN"] = 6] = "END_TAG_OPEN";
        State[State["TAG_NAME"] = 7] = "TAG_NAME";
        State[State["RCDATA_LESS_THAN_SIGN"] = 8] = "RCDATA_LESS_THAN_SIGN";
        State[State["RCDATA_END_TAG_OPEN"] = 9] = "RCDATA_END_TAG_OPEN";
        State[State["RCDATA_END_TAG_NAME"] = 10] = "RCDATA_END_TAG_NAME";
        State[State["RAWTEXT_LESS_THAN_SIGN"] = 11] = "RAWTEXT_LESS_THAN_SIGN";
        State[State["RAWTEXT_END_TAG_OPEN"] = 12] = "RAWTEXT_END_TAG_OPEN";
        State[State["RAWTEXT_END_TAG_NAME"] = 13] = "RAWTEXT_END_TAG_NAME";
        State[State["SCRIPT_DATA_LESS_THAN_SIGN"] = 14] = "SCRIPT_DATA_LESS_THAN_SIGN";
        State[State["SCRIPT_DATA_END_TAG_OPEN"] = 15] = "SCRIPT_DATA_END_TAG_OPEN";
        State[State["SCRIPT_DATA_END_TAG_NAME"] = 16] = "SCRIPT_DATA_END_TAG_NAME";
        State[State["SCRIPT_DATA_ESCAPE_START"] = 17] = "SCRIPT_DATA_ESCAPE_START";
        State[State["SCRIPT_DATA_ESCAPE_START_DASH"] = 18] = "SCRIPT_DATA_ESCAPE_START_DASH";
        State[State["SCRIPT_DATA_ESCAPED"] = 19] = "SCRIPT_DATA_ESCAPED";
        State[State["SCRIPT_DATA_ESCAPED_DASH"] = 20] = "SCRIPT_DATA_ESCAPED_DASH";
        State[State["SCRIPT_DATA_ESCAPED_DASH_DASH"] = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH";
        State[State["SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN"] = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN";
        State[State["SCRIPT_DATA_ESCAPED_END_TAG_OPEN"] = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN";
        State[State["SCRIPT_DATA_ESCAPED_END_TAG_NAME"] = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME";
        State[State["SCRIPT_DATA_DOUBLE_ESCAPE_START"] = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START";
        State[State["SCRIPT_DATA_DOUBLE_ESCAPED"] = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED";
        State[State["SCRIPT_DATA_DOUBLE_ESCAPED_DASH"] = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH";
        State[State["SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH"] = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH";
        State[State["SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN"] = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN";
        State[State["SCRIPT_DATA_DOUBLE_ESCAPE_END"] = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END";
        State[State["BEFORE_ATTRIBUTE_NAME"] = 31] = "BEFORE_ATTRIBUTE_NAME";
        State[State["ATTRIBUTE_NAME"] = 32] = "ATTRIBUTE_NAME";
        State[State["AFTER_ATTRIBUTE_NAME"] = 33] = "AFTER_ATTRIBUTE_NAME";
        State[State["BEFORE_ATTRIBUTE_VALUE"] = 34] = "BEFORE_ATTRIBUTE_VALUE";
        State[State["ATTRIBUTE_VALUE_DOUBLE_QUOTED"] = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED";
        State[State["ATTRIBUTE_VALUE_SINGLE_QUOTED"] = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED";
        State[State["ATTRIBUTE_VALUE_UNQUOTED"] = 37] = "ATTRIBUTE_VALUE_UNQUOTED";
        State[State["AFTER_ATTRIBUTE_VALUE_QUOTED"] = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED";
        State[State["SELF_CLOSING_START_TAG"] = 39] = "SELF_CLOSING_START_TAG";
        State[State["BOGUS_COMMENT"] = 40] = "BOGUS_COMMENT";
        State[State["MARKUP_DECLARATION_OPEN"] = 41] = "MARKUP_DECLARATION_OPEN";
        State[State["COMMENT_START"] = 42] = "COMMENT_START";
        State[State["COMMENT_START_DASH"] = 43] = "COMMENT_START_DASH";
        State[State["COMMENT"] = 44] = "COMMENT";
        State[State["COMMENT_LESS_THAN_SIGN"] = 45] = "COMMENT_LESS_THAN_SIGN";
        State[State["COMMENT_LESS_THAN_SIGN_BANG"] = 46] = "COMMENT_LESS_THAN_SIGN_BANG";
        State[State["COMMENT_LESS_THAN_SIGN_BANG_DASH"] = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH";
        State[State["COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH"] = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH";
        State[State["COMMENT_END_DASH"] = 49] = "COMMENT_END_DASH";
        State[State["COMMENT_END"] = 50] = "COMMENT_END";
        State[State["COMMENT_END_BANG"] = 51] = "COMMENT_END_BANG";
        State[State["DOCTYPE"] = 52] = "DOCTYPE";
        State[State["BEFORE_DOCTYPE_NAME"] = 53] = "BEFORE_DOCTYPE_NAME";
        State[State["DOCTYPE_NAME"] = 54] = "DOCTYPE_NAME";
        State[State["AFTER_DOCTYPE_NAME"] = 55] = "AFTER_DOCTYPE_NAME";
        State[State["AFTER_DOCTYPE_PUBLIC_KEYWORD"] = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD";
        State[State["BEFORE_DOCTYPE_PUBLIC_IDENTIFIER"] = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER";
        State[State["DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED"] = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED";
        State[State["DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED"] = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED";
        State[State["AFTER_DOCTYPE_PUBLIC_IDENTIFIER"] = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER";
        State[State["BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS"] = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS";
        State[State["AFTER_DOCTYPE_SYSTEM_KEYWORD"] = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD";
        State[State["BEFORE_DOCTYPE_SYSTEM_IDENTIFIER"] = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER";
        State[State["DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED"] = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED";
        State[State["DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED"] = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED";
        State[State["AFTER_DOCTYPE_SYSTEM_IDENTIFIER"] = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER";
        State[State["BOGUS_DOCTYPE"] = 67] = "BOGUS_DOCTYPE";
        State[State["CDATA_SECTION"] = 68] = "CDATA_SECTION";
        State[State["CDATA_SECTION_BRACKET"] = 69] = "CDATA_SECTION_BRACKET";
        State[State["CDATA_SECTION_END"] = 70] = "CDATA_SECTION_END";
        State[State["CHARACTER_REFERENCE"] = 71] = "CHARACTER_REFERENCE";
        State[State["NAMED_CHARACTER_REFERENCE"] = 72] = "NAMED_CHARACTER_REFERENCE";
        State[State["AMBIGUOUS_AMPERSAND"] = 73] = "AMBIGUOUS_AMPERSAND";
        State[State["NUMERIC_CHARACTER_REFERENCE"] = 74] = "NUMERIC_CHARACTER_REFERENCE";
        State[State["HEXADEMICAL_CHARACTER_REFERENCE_START"] = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START";
        State[State["HEXADEMICAL_CHARACTER_REFERENCE"] = 76] = "HEXADEMICAL_CHARACTER_REFERENCE";
        State[State["DECIMAL_CHARACTER_REFERENCE"] = 77] = "DECIMAL_CHARACTER_REFERENCE";
        State[State["NUMERIC_CHARACTER_REFERENCE_END"] = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
    })(State$1 || (State$1 = {}));
    //Tokenizer initial states for different modes
    const TokenizerMode = {
        DATA: State$1.DATA,
        RCDATA: State$1.RCDATA,
        RAWTEXT: State$1.RAWTEXT,
        SCRIPT_DATA: State$1.SCRIPT_DATA,
        PLAINTEXT: State$1.PLAINTEXT,
        CDATA_SECTION: State$1.CDATA_SECTION,
    };
    //Utils
    //OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline
    //this functions if they will be situated in another module due to context switch.
    //Always perform inlining check before modifying this functions ('node --trace-inlining').
    function isAsciiDigit(cp) {
        return cp >= CODE_POINTS.DIGIT_0 && cp <= CODE_POINTS.DIGIT_9;
    }
    function isAsciiUpper(cp) {
        return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_Z;
    }
    function isAsciiLower(cp) {
        return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_Z;
    }
    function isAsciiLetter(cp) {
        return isAsciiLower(cp) || isAsciiUpper(cp);
    }
    function isAsciiAlphaNumeric(cp) {
        return isAsciiLetter(cp) || isAsciiDigit(cp);
    }
    function isAsciiUpperHexDigit(cp) {
        return cp >= CODE_POINTS.LATIN_CAPITAL_A && cp <= CODE_POINTS.LATIN_CAPITAL_F;
    }
    function isAsciiLowerHexDigit(cp) {
        return cp >= CODE_POINTS.LATIN_SMALL_A && cp <= CODE_POINTS.LATIN_SMALL_F;
    }
    function isAsciiHexDigit(cp) {
        return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
    }
    function toAsciiLower(cp) {
        return cp + 32;
    }
    function isWhitespace$1(cp) {
        return cp === CODE_POINTS.SPACE || cp === CODE_POINTS.LINE_FEED || cp === CODE_POINTS.TABULATION || cp === CODE_POINTS.FORM_FEED;
    }
    function isEntityInAttributeInvalidEnd(nextCp) {
        return nextCp === CODE_POINTS.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
    }
    function isScriptDataDoubleEscapeSequenceEnd(cp) {
        return isWhitespace$1(cp) || cp === CODE_POINTS.SOLIDUS || cp === CODE_POINTS.GREATER_THAN_SIGN;
    }
    //Tokenizer
    class Tokenizer$1 {
        constructor(options, handler) {
            this.options = options;
            this.handler = handler;
            this.paused = false;
            /** Ensures that the parsing loop isn't run multiple times at once. */
            this.inLoop = false;
            /**
             * Indicates that the current adjusted node exists, is not an element in the HTML namespace,
             * and that it is not an integration point for either MathML or HTML.
             *
             * @see {@link https://html.spec.whatwg.org/multipage/parsing.html#tree-construction}
             */
            this.inForeignNode = false;
            this.lastStartTagName = '';
            this.active = false;
            this.state = State$1.DATA;
            this.returnState = State$1.DATA;
            this.charRefCode = -1;
            this.consumedAfterSnapshot = -1;
            this.currentCharacterToken = null;
            this.currentToken = null;
            this.currentAttr = { name: '', value: '' };
            this.preprocessor = new Preprocessor(handler);
            this.currentLocation = this.getCurrentLocation(-1);
        }
        //Errors
        _err(code) {
            var _a, _b;
            (_b = (_a = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a, this.preprocessor.getError(code));
        }
        // NOTE: `offset` may never run across line boundaries.
        getCurrentLocation(offset) {
            if (!this.options.sourceCodeLocationInfo) {
                return null;
            }
            return {
                startLine: this.preprocessor.line,
                startCol: this.preprocessor.col - offset,
                startOffset: this.preprocessor.offset - offset,
                endLine: -1,
                endCol: -1,
                endOffset: -1,
            };
        }
        _runParsingLoop() {
            if (this.inLoop)
                return;
            this.inLoop = true;
            while (this.active && !this.paused) {
                this.consumedAfterSnapshot = 0;
                const cp = this._consume();
                if (!this._ensureHibernation()) {
                    this._callState(cp);
                }
            }
            this.inLoop = false;
        }
        //API
        pause() {
            this.paused = true;
        }
        resume(writeCallback) {
            if (!this.paused) {
                throw new Error('Parser was already resumed');
            }
            this.paused = false;
            // Necessary for synchronous resume.
            if (this.inLoop)
                return;
            this._runParsingLoop();
            if (!this.paused) {
                writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
            }
        }
        write(chunk, isLastChunk, writeCallback) {
            this.active = true;
            this.preprocessor.write(chunk, isLastChunk);
            this._runParsingLoop();
            if (!this.paused) {
                writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();
            }
        }
        insertHtmlAtCurrentPos(chunk) {
            this.active = true;
            this.preprocessor.insertHtmlAtCurrentPos(chunk);
            this._runParsingLoop();
        }
        //Hibernation
        _ensureHibernation() {
            if (this.preprocessor.endOfChunkHit) {
                this._unconsume(this.consumedAfterSnapshot);
                this.active = false;
                return true;
            }
            return false;
        }
        //Consumption
        _consume() {
            this.consumedAfterSnapshot++;
            return this.preprocessor.advance();
        }
        _unconsume(count) {
            this.consumedAfterSnapshot -= count;
            this.preprocessor.retreat(count);
        }
        _reconsumeInState(state, cp) {
            this.state = state;
            this._callState(cp);
        }
        _advanceBy(count) {
            this.consumedAfterSnapshot += count;
            for (let i = 0; i < count; i++) {
                this.preprocessor.advance();
            }
        }
        _consumeSequenceIfMatch(pattern, caseSensitive) {
            if (this.preprocessor.startsWith(pattern, caseSensitive)) {
                // We will already have consumed one character before calling this method.
                this._advanceBy(pattern.length - 1);
                return true;
            }
            return false;
        }
        //Token creation
        _createStartTagToken() {
            this.currentToken = {
                type: TokenType.START_TAG,
                tagName: '',
                tagID: TAG_ID.UNKNOWN,
                selfClosing: false,
                ackSelfClosing: false,
                attrs: [],
                location: this.getCurrentLocation(1),
            };
        }
        _createEndTagToken() {
            this.currentToken = {
                type: TokenType.END_TAG,
                tagName: '',
                tagID: TAG_ID.UNKNOWN,
                selfClosing: false,
                ackSelfClosing: false,
                attrs: [],
                location: this.getCurrentLocation(2),
            };
        }
        _createCommentToken(offset) {
            this.currentToken = {
                type: TokenType.COMMENT,
                data: '',
                location: this.getCurrentLocation(offset),
            };
        }
        _createDoctypeToken(initialName) {
            this.currentToken = {
                type: TokenType.DOCTYPE,
                name: initialName,
                forceQuirks: false,
                publicId: null,
                systemId: null,
                location: this.currentLocation,
            };
        }
        _createCharacterToken(type, chars) {
            this.currentCharacterToken = {
                type,
                chars,
                location: this.currentLocation,
            };
        }
        //Tag attributes
        _createAttr(attrNameFirstCh) {
            this.currentAttr = {
                name: attrNameFirstCh,
                value: '',
            };
            this.currentLocation = this.getCurrentLocation(0);
        }
        _leaveAttrName() {
            var _a;
            var _b;
            const token = this.currentToken;
            if (getTokenAttr(token, this.currentAttr.name) === null) {
                token.attrs.push(this.currentAttr);
                if (token.location && this.currentLocation) {
                    const attrLocations = ((_a = (_b = token.location).attrs) !== null && _a !== void 0 ? _a : (_b.attrs = Object.create(null)));
                    attrLocations[this.currentAttr.name] = this.currentLocation;
                    // Set end location
                    this._leaveAttrValue();
                }
            }
            else {
                this._err(ERR.duplicateAttribute);
            }
        }
        _leaveAttrValue() {
            if (this.currentLocation) {
                this.currentLocation.endLine = this.preprocessor.line;
                this.currentLocation.endCol = this.preprocessor.col;
                this.currentLocation.endOffset = this.preprocessor.offset;
            }
        }
        //Token emission
        prepareToken(ct) {
            this._emitCurrentCharacterToken(ct.location);
            this.currentToken = null;
            if (ct.location) {
                ct.location.endLine = this.preprocessor.line;
                ct.location.endCol = this.preprocessor.col + 1;
                ct.location.endOffset = this.preprocessor.offset + 1;
            }
            this.currentLocation = this.getCurrentLocation(-1);
        }
        emitCurrentTagToken() {
            const ct = this.currentToken;
            this.prepareToken(ct);
            ct.tagID = getTagID(ct.tagName);
            if (ct.type === TokenType.START_TAG) {
                this.lastStartTagName = ct.tagName;
                this.handler.onStartTag(ct);
            }
            else {
                if (ct.attrs.length > 0) {
                    this._err(ERR.endTagWithAttributes);
                }
                if (ct.selfClosing) {
                    this._err(ERR.endTagWithTrailingSolidus);
                }
                this.handler.onEndTag(ct);
            }
            this.preprocessor.dropParsedChunk();
        }
        emitCurrentComment(ct) {
            this.prepareToken(ct);
            this.handler.onComment(ct);
            this.preprocessor.dropParsedChunk();
        }
        emitCurrentDoctype(ct) {
            this.prepareToken(ct);
            this.handler.onDoctype(ct);
            this.preprocessor.dropParsedChunk();
        }
        _emitCurrentCharacterToken(nextLocation) {
            if (this.currentCharacterToken) {
                //NOTE: if we have a pending character token, make it's end location equal to the
                //current token's start location.
                if (nextLocation && this.currentCharacterToken.location) {
                    this.currentCharacterToken.location.endLine = nextLocation.startLine;
                    this.currentCharacterToken.location.endCol = nextLocation.startCol;
                    this.currentCharacterToken.location.endOffset = nextLocation.startOffset;
                }
                switch (this.currentCharacterToken.type) {
                    case TokenType.CHARACTER: {
                        this.handler.onCharacter(this.currentCharacterToken);
                        break;
                    }
                    case TokenType.NULL_CHARACTER: {
                        this.handler.onNullCharacter(this.currentCharacterToken);
                        break;
                    }
                    case TokenType.WHITESPACE_CHARACTER: {
                        this.handler.onWhitespaceCharacter(this.currentCharacterToken);
                        break;
                    }
                }
                this.currentCharacterToken = null;
            }
        }
        _emitEOFToken() {
            const location = this.getCurrentLocation(0);
            if (location) {
                location.endLine = location.startLine;
                location.endCol = location.startCol;
                location.endOffset = location.startOffset;
            }
            this._emitCurrentCharacterToken(location);
            this.handler.onEof({ type: TokenType.EOF, location });
            this.active = false;
        }
        //Characters emission
        //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
        //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
        //If we have a sequence of characters that belong to the same group, the parser can process it
        //as a single solid character token.
        //So, there are 3 types of character tokens in parse5:
        //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
        //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
        //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
        _appendCharToCurrentCharacterToken(type, ch) {
            if (this.currentCharacterToken) {
                if (this.currentCharacterToken.type !== type) {
                    this.currentLocation = this.getCurrentLocation(0);
                    this._emitCurrentCharacterToken(this.currentLocation);
                    this.preprocessor.dropParsedChunk();
                }
                else {
                    this.currentCharacterToken.chars += ch;
                    return;
                }
            }
            this._createCharacterToken(type, ch);
        }
        _emitCodePoint(cp) {
            const type = isWhitespace$1(cp)
                ? TokenType.WHITESPACE_CHARACTER
                : cp === CODE_POINTS.NULL
                    ? TokenType.NULL_CHARACTER
                    : TokenType.CHARACTER;
            this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));
        }
        //NOTE: used when we emit characters explicitly.
        //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
        _emitChars(ch) {
            this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);
        }
        // Character reference helpers
        _matchNamedCharacterReference(cp) {
            let result = null;
            let excess = 0;
            let withoutSemicolon = false;
            for (let i = 0, current = htmlDecodeTree[0]; i >= 0; cp = this._consume()) {
                i = determineBranch(htmlDecodeTree, current, i + 1, cp);
                if (i < 0)
                    break;
                excess += 1;
                current = htmlDecodeTree[i];
                const masked = current & BinTrieFlags.VALUE_LENGTH;
                // If the branch is a value, store it and continue
                if (masked) {
                    // The mask is the number of bytes of the value, including the current byte.
                    const valueLength = (masked >> 14) - 1;
                    // Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.
                    // See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state
                    if (cp !== CODE_POINTS.SEMICOLON &&
                        this._isCharacterReferenceInAttribute() &&
                        isEntityInAttributeInvalidEnd(this.preprocessor.peek(1))) {
                        //NOTE: we don't flush all consumed code points here, and instead switch back to the original state after
                        //emitting an ampersand. This is fine, as alphanumeric characters won't be parsed differently in attributes.
                        result = [CODE_POINTS.AMPERSAND];
                        // Skip over the value.
                        i += valueLength;
                    }
                    else {
                        // If this is a surrogate pair, consume the next two bytes.
                        result =
                            valueLength === 0
                                ? [htmlDecodeTree[i] & ~BinTrieFlags.VALUE_LENGTH]
                                : valueLength === 1
                                    ? [htmlDecodeTree[++i]]
                                    : [htmlDecodeTree[++i], htmlDecodeTree[++i]];
                        excess = 0;
                        withoutSemicolon = cp !== CODE_POINTS.SEMICOLON;
                    }
                    if (valueLength === 0) {
                        // If the value is zero-length, we're done.
                        this._consume();
                        break;
                    }
                }
            }
            this._unconsume(excess);
            if (withoutSemicolon && !this.preprocessor.endOfChunkHit) {
                this._err(ERR.missingSemicolonAfterCharacterReference);
            }
            // We want to emit the error above on the code point after the entity.
            // We always consume one code point too many in the loop, and we wait to
            // unconsume it until after the error is emitted.
            this._unconsume(1);
            return result;
        }
        _isCharacterReferenceInAttribute() {
            return (this.returnState === State$1.ATTRIBUTE_VALUE_DOUBLE_QUOTED ||
                this.returnState === State$1.ATTRIBUTE_VALUE_SINGLE_QUOTED ||
                this.returnState === State$1.ATTRIBUTE_VALUE_UNQUOTED);
        }
        _flushCodePointConsumedAsCharacterReference(cp) {
            if (this._isCharacterReferenceInAttribute()) {
                this.currentAttr.value += String.fromCodePoint(cp);
            }
            else {
                this._emitCodePoint(cp);
            }
        }
        // Calling states this way turns out to be much faster than any other approach.
        _callState(cp) {
            switch (this.state) {
                case State$1.DATA: {
                    this._stateData(cp);
                    break;
                }
                case State$1.RCDATA: {
                    this._stateRcdata(cp);
                    break;
                }
                case State$1.RAWTEXT: {
                    this._stateRawtext(cp);
                    break;
                }
                case State$1.SCRIPT_DATA: {
                    this._stateScriptData(cp);
                    break;
                }
                case State$1.PLAINTEXT: {
                    this._statePlaintext(cp);
                    break;
                }
                case State$1.TAG_OPEN: {
                    this._stateTagOpen(cp);
                    break;
                }
                case State$1.END_TAG_OPEN: {
                    this._stateEndTagOpen(cp);
                    break;
                }
                case State$1.TAG_NAME: {
                    this._stateTagName(cp);
                    break;
                }
                case State$1.RCDATA_LESS_THAN_SIGN: {
                    this._stateRcdataLessThanSign(cp);
                    break;
                }
                case State$1.RCDATA_END_TAG_OPEN: {
                    this._stateRcdataEndTagOpen(cp);
                    break;
                }
                case State$1.RCDATA_END_TAG_NAME: {
                    this._stateRcdataEndTagName(cp);
                    break;
                }
                case State$1.RAWTEXT_LESS_THAN_SIGN: {
                    this._stateRawtextLessThanSign(cp);
                    break;
                }
                case State$1.RAWTEXT_END_TAG_OPEN: {
                    this._stateRawtextEndTagOpen(cp);
                    break;
                }
                case State$1.RAWTEXT_END_TAG_NAME: {
                    this._stateRawtextEndTagName(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_LESS_THAN_SIGN: {
                    this._stateScriptDataLessThanSign(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_END_TAG_OPEN: {
                    this._stateScriptDataEndTagOpen(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_END_TAG_NAME: {
                    this._stateScriptDataEndTagName(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_ESCAPE_START: {
                    this._stateScriptDataEscapeStart(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_ESCAPE_START_DASH: {
                    this._stateScriptDataEscapeStartDash(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_ESCAPED: {
                    this._stateScriptDataEscaped(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_ESCAPED_DASH: {
                    this._stateScriptDataEscapedDash(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_ESCAPED_DASH_DASH: {
                    this._stateScriptDataEscapedDashDash(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
                    this._stateScriptDataEscapedLessThanSign(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
                    this._stateScriptDataEscapedEndTagOpen(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
                    this._stateScriptDataEscapedEndTagName(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
                    this._stateScriptDataDoubleEscapeStart(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_DOUBLE_ESCAPED: {
                    this._stateScriptDataDoubleEscaped(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
                    this._stateScriptDataDoubleEscapedDash(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
                    this._stateScriptDataDoubleEscapedDashDash(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
                    this._stateScriptDataDoubleEscapedLessThanSign(cp);
                    break;
                }
                case State$1.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
                    this._stateScriptDataDoubleEscapeEnd(cp);
                    break;
                }
                case State$1.BEFORE_ATTRIBUTE_NAME: {
                    this._stateBeforeAttributeName(cp);
                    break;
                }
                case State$1.ATTRIBUTE_NAME: {
                    this._stateAttributeName(cp);
                    break;
                }
                case State$1.AFTER_ATTRIBUTE_NAME: {
                    this._stateAfterAttributeName(cp);
                    break;
                }
                case State$1.BEFORE_ATTRIBUTE_VALUE: {
                    this._stateBeforeAttributeValue(cp);
                    break;
                }
                case State$1.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
                    this._stateAttributeValueDoubleQuoted(cp);
                    break;
                }
                case State$1.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
                    this._stateAttributeValueSingleQuoted(cp);
                    break;
                }
                case State$1.ATTRIBUTE_VALUE_UNQUOTED: {
                    this._stateAttributeValueUnquoted(cp);
                    break;
                }
                case State$1.AFTER_ATTRIBUTE_VALUE_QUOTED: {
                    this._stateAfterAttributeValueQuoted(cp);
                    break;
                }
                case State$1.SELF_CLOSING_START_TAG: {
                    this._stateSelfClosingStartTag(cp);
                    break;
                }
                case State$1.BOGUS_COMMENT: {
                    this._stateBogusComment(cp);
                    break;
                }
                case State$1.MARKUP_DECLARATION_OPEN: {
                    this._stateMarkupDeclarationOpen(cp);
                    break;
                }
                case State$1.COMMENT_START: {
                    this._stateCommentStart(cp);
                    break;
                }
                case State$1.COMMENT_START_DASH: {
                    this._stateCommentStartDash(cp);
                    break;
                }
                case State$1.COMMENT: {
                    this._stateComment(cp);
                    break;
                }
                case State$1.COMMENT_LESS_THAN_SIGN: {
                    this._stateCommentLessThanSign(cp);
                    break;
                }
                case State$1.COMMENT_LESS_THAN_SIGN_BANG: {
                    this._stateCommentLessThanSignBang(cp);
                    break;
                }
                case State$1.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
                    this._stateCommentLessThanSignBangDash(cp);
                    break;
                }
                case State$1.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
                    this._stateCommentLessThanSignBangDashDash(cp);
                    break;
                }
                case State$1.COMMENT_END_DASH: {
                    this._stateCommentEndDash(cp);
                    break;
                }
                case State$1.COMMENT_END: {
                    this._stateCommentEnd(cp);
                    break;
                }
                case State$1.COMMENT_END_BANG: {
                    this._stateCommentEndBang(cp);
                    break;
                }
                case State$1.DOCTYPE: {
                    this._stateDoctype(cp);
                    break;
                }
                case State$1.BEFORE_DOCTYPE_NAME: {
                    this._stateBeforeDoctypeName(cp);
                    break;
                }
                case State$1.DOCTYPE_NAME: {
                    this._stateDoctypeName(cp);
                    break;
                }
                case State$1.AFTER_DOCTYPE_NAME: {
                    this._stateAfterDoctypeName(cp);
                    break;
                }
                case State$1.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
                    this._stateAfterDoctypePublicKeyword(cp);
                    break;
                }
                case State$1.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
                    this._stateBeforeDoctypePublicIdentifier(cp);
                    break;
                }
                case State$1.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
                    this._stateDoctypePublicIdentifierDoubleQuoted(cp);
                    break;
                }
                case State$1.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
                    this._stateDoctypePublicIdentifierSingleQuoted(cp);
                    break;
                }
                case State$1.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
                    this._stateAfterDoctypePublicIdentifier(cp);
                    break;
                }
                case State$1.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
                    this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);
                    break;
                }
                case State$1.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
                    this._stateAfterDoctypeSystemKeyword(cp);
                    break;
                }
                case State$1.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
                    this._stateBeforeDoctypeSystemIdentifier(cp);
                    break;
                }
                case State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
                    this._stateDoctypeSystemIdentifierDoubleQuoted(cp);
                    break;
                }
                case State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
                    this._stateDoctypeSystemIdentifierSingleQuoted(cp);
                    break;
                }
                case State$1.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
                    this._stateAfterDoctypeSystemIdentifier(cp);
                    break;
                }
                case State$1.BOGUS_DOCTYPE: {
                    this._stateBogusDoctype(cp);
                    break;
                }
                case State$1.CDATA_SECTION: {
                    this._stateCdataSection(cp);
                    break;
                }
                case State$1.CDATA_SECTION_BRACKET: {
                    this._stateCdataSectionBracket(cp);
                    break;
                }
                case State$1.CDATA_SECTION_END: {
                    this._stateCdataSectionEnd(cp);
                    break;
                }
                case State$1.CHARACTER_REFERENCE: {
                    this._stateCharacterReference(cp);
                    break;
                }
                case State$1.NAMED_CHARACTER_REFERENCE: {
                    this._stateNamedCharacterReference(cp);
                    break;
                }
                case State$1.AMBIGUOUS_AMPERSAND: {
                    this._stateAmbiguousAmpersand(cp);
                    break;
                }
                case State$1.NUMERIC_CHARACTER_REFERENCE: {
                    this._stateNumericCharacterReference(cp);
                    break;
                }
                case State$1.HEXADEMICAL_CHARACTER_REFERENCE_START: {
                    this._stateHexademicalCharacterReferenceStart(cp);
                    break;
                }
                case State$1.HEXADEMICAL_CHARACTER_REFERENCE: {
                    this._stateHexademicalCharacterReference(cp);
                    break;
                }
                case State$1.DECIMAL_CHARACTER_REFERENCE: {
                    this._stateDecimalCharacterReference(cp);
                    break;
                }
                case State$1.NUMERIC_CHARACTER_REFERENCE_END: {
                    this._stateNumericCharacterReferenceEnd(cp);
                    break;
                }
                default: {
                    throw new Error('Unknown state');
                }
            }
        }
        // State machine
        // Data state
        //------------------------------------------------------------------
        _stateData(cp) {
            switch (cp) {
                case CODE_POINTS.LESS_THAN_SIGN: {
                    this.state = State$1.TAG_OPEN;
                    break;
                }
                case CODE_POINTS.AMPERSAND: {
                    this.returnState = State$1.DATA;
                    this.state = State$1.CHARACTER_REFERENCE;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this._emitCodePoint(cp);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._emitCodePoint(cp);
                }
            }
        }
        //  RCDATA state
        //------------------------------------------------------------------
        _stateRcdata(cp) {
            switch (cp) {
                case CODE_POINTS.AMPERSAND: {
                    this.returnState = State$1.RCDATA;
                    this.state = State$1.CHARACTER_REFERENCE;
                    break;
                }
                case CODE_POINTS.LESS_THAN_SIGN: {
                    this.state = State$1.RCDATA_LESS_THAN_SIGN;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this._emitChars(REPLACEMENT_CHARACTER);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._emitCodePoint(cp);
                }
            }
        }
        // RAWTEXT state
        //------------------------------------------------------------------
        _stateRawtext(cp) {
            switch (cp) {
                case CODE_POINTS.LESS_THAN_SIGN: {
                    this.state = State$1.RAWTEXT_LESS_THAN_SIGN;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this._emitChars(REPLACEMENT_CHARACTER);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._emitCodePoint(cp);
                }
            }
        }
        // Script data state
        //------------------------------------------------------------------
        _stateScriptData(cp) {
            switch (cp) {
                case CODE_POINTS.LESS_THAN_SIGN: {
                    this.state = State$1.SCRIPT_DATA_LESS_THAN_SIGN;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this._emitChars(REPLACEMENT_CHARACTER);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._emitCodePoint(cp);
                }
            }
        }
        // PLAINTEXT state
        //------------------------------------------------------------------
        _statePlaintext(cp) {
            switch (cp) {
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this._emitChars(REPLACEMENT_CHARACTER);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._emitCodePoint(cp);
                }
            }
        }
        // Tag open state
        //------------------------------------------------------------------
        _stateTagOpen(cp) {
            if (isAsciiLetter(cp)) {
                this._createStartTagToken();
                this.state = State$1.TAG_NAME;
                this._stateTagName(cp);
            }
            else
                switch (cp) {
                    case CODE_POINTS.EXCLAMATION_MARK: {
                        this.state = State$1.MARKUP_DECLARATION_OPEN;
                        break;
                    }
                    case CODE_POINTS.SOLIDUS: {
                        this.state = State$1.END_TAG_OPEN;
                        break;
                    }
                    case CODE_POINTS.QUESTION_MARK: {
                        this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
                        this._createCommentToken(1);
                        this.state = State$1.BOGUS_COMMENT;
                        this._stateBogusComment(cp);
                        break;
                    }
                    case CODE_POINTS.EOF: {
                        this._err(ERR.eofBeforeTagName);
                        this._emitChars('<');
                        this._emitEOFToken();
                        break;
                    }
                    default: {
                        this._err(ERR.invalidFirstCharacterOfTagName);
                        this._emitChars('<');
                        this.state = State$1.DATA;
                        this._stateData(cp);
                    }
                }
        }
        // End tag open state
        //------------------------------------------------------------------
        _stateEndTagOpen(cp) {
            if (isAsciiLetter(cp)) {
                this._createEndTagToken();
                this.state = State$1.TAG_NAME;
                this._stateTagName(cp);
            }
            else
                switch (cp) {
                    case CODE_POINTS.GREATER_THAN_SIGN: {
                        this._err(ERR.missingEndTagName);
                        this.state = State$1.DATA;
                        break;
                    }
                    case CODE_POINTS.EOF: {
                        this._err(ERR.eofBeforeTagName);
                        this._emitChars('</');
                        this._emitEOFToken();
                        break;
                    }
                    default: {
                        this._err(ERR.invalidFirstCharacterOfTagName);
                        this._createCommentToken(2);
                        this.state = State$1.BOGUS_COMMENT;
                        this._stateBogusComment(cp);
                    }
                }
        }
        // Tag name state
        //------------------------------------------------------------------
        _stateTagName(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    this.state = State$1.BEFORE_ATTRIBUTE_NAME;
                    break;
                }
                case CODE_POINTS.SOLIDUS: {
                    this.state = State$1.SELF_CLOSING_START_TAG;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.state = State$1.DATA;
                    this.emitCurrentTagToken();
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    token.tagName += REPLACEMENT_CHARACTER;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInTag);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
                }
            }
        }
        // RCDATA less-than sign state
        //------------------------------------------------------------------
        _stateRcdataLessThanSign(cp) {
            if (cp === CODE_POINTS.SOLIDUS) {
                this.state = State$1.RCDATA_END_TAG_OPEN;
            }
            else {
                this._emitChars('<');
                this.state = State$1.RCDATA;
                this._stateRcdata(cp);
            }
        }
        // RCDATA end tag open state
        //------------------------------------------------------------------
        _stateRcdataEndTagOpen(cp) {
            if (isAsciiLetter(cp)) {
                this.state = State$1.RCDATA_END_TAG_NAME;
                this._stateRcdataEndTagName(cp);
            }
            else {
                this._emitChars('</');
                this.state = State$1.RCDATA;
                this._stateRcdata(cp);
            }
        }
        handleSpecialEndTag(_cp) {
            if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {
                return !this._ensureHibernation();
            }
            this._createEndTagToken();
            const token = this.currentToken;
            token.tagName = this.lastStartTagName;
            const cp = this.preprocessor.peek(this.lastStartTagName.length);
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    this._advanceBy(this.lastStartTagName.length);
                    this.state = State$1.BEFORE_ATTRIBUTE_NAME;
                    return false;
                }
                case CODE_POINTS.SOLIDUS: {
                    this._advanceBy(this.lastStartTagName.length);
                    this.state = State$1.SELF_CLOSING_START_TAG;
                    return false;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._advanceBy(this.lastStartTagName.length);
                    this.emitCurrentTagToken();
                    this.state = State$1.DATA;
                    return false;
                }
                default: {
                    return !this._ensureHibernation();
                }
            }
        }
        // RCDATA end tag name state
        //------------------------------------------------------------------
        _stateRcdataEndTagName(cp) {
            if (this.handleSpecialEndTag(cp)) {
                this._emitChars('</');
                this.state = State$1.RCDATA;
                this._stateRcdata(cp);
            }
        }
        // RAWTEXT less-than sign state
        //------------------------------------------------------------------
        _stateRawtextLessThanSign(cp) {
            if (cp === CODE_POINTS.SOLIDUS) {
                this.state = State$1.RAWTEXT_END_TAG_OPEN;
            }
            else {
                this._emitChars('<');
                this.state = State$1.RAWTEXT;
                this._stateRawtext(cp);
            }
        }
        // RAWTEXT end tag open state
        //------------------------------------------------------------------
        _stateRawtextEndTagOpen(cp) {
            if (isAsciiLetter(cp)) {
                this.state = State$1.RAWTEXT_END_TAG_NAME;
                this._stateRawtextEndTagName(cp);
            }
            else {
                this._emitChars('</');
                this.state = State$1.RAWTEXT;
                this._stateRawtext(cp);
            }
        }
        // RAWTEXT end tag name state
        //------------------------------------------------------------------
        _stateRawtextEndTagName(cp) {
            if (this.handleSpecialEndTag(cp)) {
                this._emitChars('</');
                this.state = State$1.RAWTEXT;
                this._stateRawtext(cp);
            }
        }
        // Script data less-than sign state
        //------------------------------------------------------------------
        _stateScriptDataLessThanSign(cp) {
            switch (cp) {
                case CODE_POINTS.SOLIDUS: {
                    this.state = State$1.SCRIPT_DATA_END_TAG_OPEN;
                    break;
                }
                case CODE_POINTS.EXCLAMATION_MARK: {
                    this.state = State$1.SCRIPT_DATA_ESCAPE_START;
                    this._emitChars('<!');
                    break;
                }
                default: {
                    this._emitChars('<');
                    this.state = State$1.SCRIPT_DATA;
                    this._stateScriptData(cp);
                }
            }
        }
        // Script data end tag open state
        //------------------------------------------------------------------
        _stateScriptDataEndTagOpen(cp) {
            if (isAsciiLetter(cp)) {
                this.state = State$1.SCRIPT_DATA_END_TAG_NAME;
                this._stateScriptDataEndTagName(cp);
            }
            else {
                this._emitChars('</');
                this.state = State$1.SCRIPT_DATA;
                this._stateScriptData(cp);
            }
        }
        // Script data end tag name state
        //------------------------------------------------------------------
        _stateScriptDataEndTagName(cp) {
            if (this.handleSpecialEndTag(cp)) {
                this._emitChars('</');
                this.state = State$1.SCRIPT_DATA;
                this._stateScriptData(cp);
            }
        }
        // Script data escape start state
        //------------------------------------------------------------------
        _stateScriptDataEscapeStart(cp) {
            if (cp === CODE_POINTS.HYPHEN_MINUS) {
                this.state = State$1.SCRIPT_DATA_ESCAPE_START_DASH;
                this._emitChars('-');
            }
            else {
                this.state = State$1.SCRIPT_DATA;
                this._stateScriptData(cp);
            }
        }
        // Script data escape start dash state
        //------------------------------------------------------------------
        _stateScriptDataEscapeStartDash(cp) {
            if (cp === CODE_POINTS.HYPHEN_MINUS) {
                this.state = State$1.SCRIPT_DATA_ESCAPED_DASH_DASH;
                this._emitChars('-');
            }
            else {
                this.state = State$1.SCRIPT_DATA;
                this._stateScriptData(cp);
            }
        }
        // Script data escaped state
        //------------------------------------------------------------------
        _stateScriptDataEscaped(cp) {
            switch (cp) {
                case CODE_POINTS.HYPHEN_MINUS: {
                    this.state = State$1.SCRIPT_DATA_ESCAPED_DASH;
                    this._emitChars('-');
                    break;
                }
                case CODE_POINTS.LESS_THAN_SIGN: {
                    this.state = State$1.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this._emitChars(REPLACEMENT_CHARACTER);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInScriptHtmlCommentLikeText);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._emitCodePoint(cp);
                }
            }
        }
        // Script data escaped dash state
        //------------------------------------------------------------------
        _stateScriptDataEscapedDash(cp) {
            switch (cp) {
                case CODE_POINTS.HYPHEN_MINUS: {
                    this.state = State$1.SCRIPT_DATA_ESCAPED_DASH_DASH;
                    this._emitChars('-');
                    break;
                }
                case CODE_POINTS.LESS_THAN_SIGN: {
                    this.state = State$1.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this.state = State$1.SCRIPT_DATA_ESCAPED;
                    this._emitChars(REPLACEMENT_CHARACTER);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInScriptHtmlCommentLikeText);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this.state = State$1.SCRIPT_DATA_ESCAPED;
                    this._emitCodePoint(cp);
                }
            }
        }
        // Script data escaped dash dash state
        //------------------------------------------------------------------
        _stateScriptDataEscapedDashDash(cp) {
            switch (cp) {
                case CODE_POINTS.HYPHEN_MINUS: {
                    this._emitChars('-');
                    break;
                }
                case CODE_POINTS.LESS_THAN_SIGN: {
                    this.state = State$1.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.state = State$1.SCRIPT_DATA;
                    this._emitChars('>');
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this.state = State$1.SCRIPT_DATA_ESCAPED;
                    this._emitChars(REPLACEMENT_CHARACTER);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInScriptHtmlCommentLikeText);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this.state = State$1.SCRIPT_DATA_ESCAPED;
                    this._emitCodePoint(cp);
                }
            }
        }
        // Script data escaped less-than sign state
        //------------------------------------------------------------------
        _stateScriptDataEscapedLessThanSign(cp) {
            if (cp === CODE_POINTS.SOLIDUS) {
                this.state = State$1.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;
            }
            else if (isAsciiLetter(cp)) {
                this._emitChars('<');
                this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPE_START;
                this._stateScriptDataDoubleEscapeStart(cp);
            }
            else {
                this._emitChars('<');
                this.state = State$1.SCRIPT_DATA_ESCAPED;
                this._stateScriptDataEscaped(cp);
            }
        }
        // Script data escaped end tag open state
        //------------------------------------------------------------------
        _stateScriptDataEscapedEndTagOpen(cp) {
            if (isAsciiLetter(cp)) {
                this.state = State$1.SCRIPT_DATA_ESCAPED_END_TAG_NAME;
                this._stateScriptDataEscapedEndTagName(cp);
            }
            else {
                this._emitChars('</');
                this.state = State$1.SCRIPT_DATA_ESCAPED;
                this._stateScriptDataEscaped(cp);
            }
        }
        // Script data escaped end tag name state
        //------------------------------------------------------------------
        _stateScriptDataEscapedEndTagName(cp) {
            if (this.handleSpecialEndTag(cp)) {
                this._emitChars('</');
                this.state = State$1.SCRIPT_DATA_ESCAPED;
                this._stateScriptDataEscaped(cp);
            }
        }
        // Script data double escape start state
        //------------------------------------------------------------------
        _stateScriptDataDoubleEscapeStart(cp) {
            if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) &&
                isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
                this._emitCodePoint(cp);
                for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
                    this._emitCodePoint(this._consume());
                }
                this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
            }
            else if (!this._ensureHibernation()) {
                this.state = State$1.SCRIPT_DATA_ESCAPED;
                this._stateScriptDataEscaped(cp);
            }
        }
        // Script data double escaped state
        //------------------------------------------------------------------
        _stateScriptDataDoubleEscaped(cp) {
            switch (cp) {
                case CODE_POINTS.HYPHEN_MINUS: {
                    this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;
                    this._emitChars('-');
                    break;
                }
                case CODE_POINTS.LESS_THAN_SIGN: {
                    this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
                    this._emitChars('<');
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this._emitChars(REPLACEMENT_CHARACTER);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInScriptHtmlCommentLikeText);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._emitCodePoint(cp);
                }
            }
        }
        // Script data double escaped dash state
        //------------------------------------------------------------------
        _stateScriptDataDoubleEscapedDash(cp) {
            switch (cp) {
                case CODE_POINTS.HYPHEN_MINUS: {
                    this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;
                    this._emitChars('-');
                    break;
                }
                case CODE_POINTS.LESS_THAN_SIGN: {
                    this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
                    this._emitChars('<');
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
                    this._emitChars(REPLACEMENT_CHARACTER);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInScriptHtmlCommentLikeText);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
                    this._emitCodePoint(cp);
                }
            }
        }
        // Script data double escaped dash dash state
        //------------------------------------------------------------------
        _stateScriptDataDoubleEscapedDashDash(cp) {
            switch (cp) {
                case CODE_POINTS.HYPHEN_MINUS: {
                    this._emitChars('-');
                    break;
                }
                case CODE_POINTS.LESS_THAN_SIGN: {
                    this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;
                    this._emitChars('<');
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.state = State$1.SCRIPT_DATA;
                    this._emitChars('>');
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
                    this._emitChars(REPLACEMENT_CHARACTER);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInScriptHtmlCommentLikeText);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
                    this._emitCodePoint(cp);
                }
            }
        }
        // Script data double escaped less-than sign state
        //------------------------------------------------------------------
        _stateScriptDataDoubleEscapedLessThanSign(cp) {
            if (cp === CODE_POINTS.SOLIDUS) {
                this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPE_END;
                this._emitChars('/');
            }
            else {
                this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
                this._stateScriptDataDoubleEscaped(cp);
            }
        }
        // Script data double escape end state
        //------------------------------------------------------------------
        _stateScriptDataDoubleEscapeEnd(cp) {
            if (this.preprocessor.startsWith(SEQUENCES.SCRIPT, false) &&
                isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek(SEQUENCES.SCRIPT.length))) {
                this._emitCodePoint(cp);
                for (let i = 0; i < SEQUENCES.SCRIPT.length; i++) {
                    this._emitCodePoint(this._consume());
                }
                this.state = State$1.SCRIPT_DATA_ESCAPED;
            }
            else if (!this._ensureHibernation()) {
                this.state = State$1.SCRIPT_DATA_DOUBLE_ESCAPED;
                this._stateScriptDataDoubleEscaped(cp);
            }
        }
        // Before attribute name state
        //------------------------------------------------------------------
        _stateBeforeAttributeName(cp) {
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    // Ignore whitespace
                    break;
                }
                case CODE_POINTS.SOLIDUS:
                case CODE_POINTS.GREATER_THAN_SIGN:
                case CODE_POINTS.EOF: {
                    this.state = State$1.AFTER_ATTRIBUTE_NAME;
                    this._stateAfterAttributeName(cp);
                    break;
                }
                case CODE_POINTS.EQUALS_SIGN: {
                    this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
                    this._createAttr('=');
                    this.state = State$1.ATTRIBUTE_NAME;
                    break;
                }
                default: {
                    this._createAttr('');
                    this.state = State$1.ATTRIBUTE_NAME;
                    this._stateAttributeName(cp);
                }
            }
        }
        // Attribute name state
        //------------------------------------------------------------------
        _stateAttributeName(cp) {
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED:
                case CODE_POINTS.SOLIDUS:
                case CODE_POINTS.GREATER_THAN_SIGN:
                case CODE_POINTS.EOF: {
                    this._leaveAttrName();
                    this.state = State$1.AFTER_ATTRIBUTE_NAME;
                    this._stateAfterAttributeName(cp);
                    break;
                }
                case CODE_POINTS.EQUALS_SIGN: {
                    this._leaveAttrName();
                    this.state = State$1.BEFORE_ATTRIBUTE_VALUE;
                    break;
                }
                case CODE_POINTS.QUOTATION_MARK:
                case CODE_POINTS.APOSTROPHE:
                case CODE_POINTS.LESS_THAN_SIGN: {
                    this._err(ERR.unexpectedCharacterInAttributeName);
                    this.currentAttr.name += String.fromCodePoint(cp);
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this.currentAttr.name += REPLACEMENT_CHARACTER;
                    break;
                }
                default: {
                    this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
                }
            }
        }
        // After attribute name state
        //------------------------------------------------------------------
        _stateAfterAttributeName(cp) {
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    // Ignore whitespace
                    break;
                }
                case CODE_POINTS.SOLIDUS: {
                    this.state = State$1.SELF_CLOSING_START_TAG;
                    break;
                }
                case CODE_POINTS.EQUALS_SIGN: {
                    this.state = State$1.BEFORE_ATTRIBUTE_VALUE;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.state = State$1.DATA;
                    this.emitCurrentTagToken();
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInTag);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._createAttr('');
                    this.state = State$1.ATTRIBUTE_NAME;
                    this._stateAttributeName(cp);
                }
            }
        }
        // Before attribute value state
        //------------------------------------------------------------------
        _stateBeforeAttributeValue(cp) {
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    // Ignore whitespace
                    break;
                }
                case CODE_POINTS.QUOTATION_MARK: {
                    this.state = State$1.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
                    break;
                }
                case CODE_POINTS.APOSTROPHE: {
                    this.state = State$1.ATTRIBUTE_VALUE_SINGLE_QUOTED;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._err(ERR.missingAttributeValue);
                    this.state = State$1.DATA;
                    this.emitCurrentTagToken();
                    break;
                }
                default: {
                    this.state = State$1.ATTRIBUTE_VALUE_UNQUOTED;
                    this._stateAttributeValueUnquoted(cp);
                }
            }
        }
        // Attribute value (double-quoted) state
        //------------------------------------------------------------------
        _stateAttributeValueDoubleQuoted(cp) {
            switch (cp) {
                case CODE_POINTS.QUOTATION_MARK: {
                    this.state = State$1.AFTER_ATTRIBUTE_VALUE_QUOTED;
                    break;
                }
                case CODE_POINTS.AMPERSAND: {
                    this.returnState = State$1.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
                    this.state = State$1.CHARACTER_REFERENCE;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this.currentAttr.value += REPLACEMENT_CHARACTER;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInTag);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this.currentAttr.value += String.fromCodePoint(cp);
                }
            }
        }
        // Attribute value (single-quoted) state
        //------------------------------------------------------------------
        _stateAttributeValueSingleQuoted(cp) {
            switch (cp) {
                case CODE_POINTS.APOSTROPHE: {
                    this.state = State$1.AFTER_ATTRIBUTE_VALUE_QUOTED;
                    break;
                }
                case CODE_POINTS.AMPERSAND: {
                    this.returnState = State$1.ATTRIBUTE_VALUE_SINGLE_QUOTED;
                    this.state = State$1.CHARACTER_REFERENCE;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this.currentAttr.value += REPLACEMENT_CHARACTER;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInTag);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this.currentAttr.value += String.fromCodePoint(cp);
                }
            }
        }
        // Attribute value (unquoted) state
        //------------------------------------------------------------------
        _stateAttributeValueUnquoted(cp) {
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    this._leaveAttrValue();
                    this.state = State$1.BEFORE_ATTRIBUTE_NAME;
                    break;
                }
                case CODE_POINTS.AMPERSAND: {
                    this.returnState = State$1.ATTRIBUTE_VALUE_UNQUOTED;
                    this.state = State$1.CHARACTER_REFERENCE;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._leaveAttrValue();
                    this.state = State$1.DATA;
                    this.emitCurrentTagToken();
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    this.currentAttr.value += REPLACEMENT_CHARACTER;
                    break;
                }
                case CODE_POINTS.QUOTATION_MARK:
                case CODE_POINTS.APOSTROPHE:
                case CODE_POINTS.LESS_THAN_SIGN:
                case CODE_POINTS.EQUALS_SIGN:
                case CODE_POINTS.GRAVE_ACCENT: {
                    this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
                    this.currentAttr.value += String.fromCodePoint(cp);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInTag);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this.currentAttr.value += String.fromCodePoint(cp);
                }
            }
        }
        // After attribute value (quoted) state
        //------------------------------------------------------------------
        _stateAfterAttributeValueQuoted(cp) {
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    this._leaveAttrValue();
                    this.state = State$1.BEFORE_ATTRIBUTE_NAME;
                    break;
                }
                case CODE_POINTS.SOLIDUS: {
                    this._leaveAttrValue();
                    this.state = State$1.SELF_CLOSING_START_TAG;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._leaveAttrValue();
                    this.state = State$1.DATA;
                    this.emitCurrentTagToken();
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInTag);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._err(ERR.missingWhitespaceBetweenAttributes);
                    this.state = State$1.BEFORE_ATTRIBUTE_NAME;
                    this._stateBeforeAttributeName(cp);
                }
            }
        }
        // Self-closing start tag state
        //------------------------------------------------------------------
        _stateSelfClosingStartTag(cp) {
            switch (cp) {
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    const token = this.currentToken;
                    token.selfClosing = true;
                    this.state = State$1.DATA;
                    this.emitCurrentTagToken();
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInTag);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._err(ERR.unexpectedSolidusInTag);
                    this.state = State$1.BEFORE_ATTRIBUTE_NAME;
                    this._stateBeforeAttributeName(cp);
                }
            }
        }
        // Bogus comment state
        //------------------------------------------------------------------
        _stateBogusComment(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.state = State$1.DATA;
                    this.emitCurrentComment(token);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this.emitCurrentComment(token);
                    this._emitEOFToken();
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    token.data += REPLACEMENT_CHARACTER;
                    break;
                }
                default: {
                    token.data += String.fromCodePoint(cp);
                }
            }
        }
        // Markup declaration open state
        //------------------------------------------------------------------
        _stateMarkupDeclarationOpen(cp) {
            if (this._consumeSequenceIfMatch(SEQUENCES.DASH_DASH, true)) {
                this._createCommentToken(SEQUENCES.DASH_DASH.length + 1);
                this.state = State$1.COMMENT_START;
            }
            else if (this._consumeSequenceIfMatch(SEQUENCES.DOCTYPE, false)) {
                // NOTE: Doctypes tokens are created without fixed offsets. We keep track of the moment a doctype *might* start here.
                this.currentLocation = this.getCurrentLocation(SEQUENCES.DOCTYPE.length + 1);
                this.state = State$1.DOCTYPE;
            }
            else if (this._consumeSequenceIfMatch(SEQUENCES.CDATA_START, true)) {
                if (this.inForeignNode) {
                    this.state = State$1.CDATA_SECTION;
                }
                else {
                    this._err(ERR.cdataInHtmlContent);
                    this._createCommentToken(SEQUENCES.CDATA_START.length + 1);
                    this.currentToken.data = '[CDATA[';
                    this.state = State$1.BOGUS_COMMENT;
                }
            }
            //NOTE: Sequence lookups can be abrupted by hibernation. In that case, lookup
            //results are no longer valid and we will need to start over.
            else if (!this._ensureHibernation()) {
                this._err(ERR.incorrectlyOpenedComment);
                this._createCommentToken(2);
                this.state = State$1.BOGUS_COMMENT;
                this._stateBogusComment(cp);
            }
        }
        // Comment start state
        //------------------------------------------------------------------
        _stateCommentStart(cp) {
            switch (cp) {
                case CODE_POINTS.HYPHEN_MINUS: {
                    this.state = State$1.COMMENT_START_DASH;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._err(ERR.abruptClosingOfEmptyComment);
                    this.state = State$1.DATA;
                    const token = this.currentToken;
                    this.emitCurrentComment(token);
                    break;
                }
                default: {
                    this.state = State$1.COMMENT;
                    this._stateComment(cp);
                }
            }
        }
        // Comment start dash state
        //------------------------------------------------------------------
        _stateCommentStartDash(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.HYPHEN_MINUS: {
                    this.state = State$1.COMMENT_END;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._err(ERR.abruptClosingOfEmptyComment);
                    this.state = State$1.DATA;
                    this.emitCurrentComment(token);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInComment);
                    this.emitCurrentComment(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    token.data += '-';
                    this.state = State$1.COMMENT;
                    this._stateComment(cp);
                }
            }
        }
        // Comment state
        //------------------------------------------------------------------
        _stateComment(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.HYPHEN_MINUS: {
                    this.state = State$1.COMMENT_END_DASH;
                    break;
                }
                case CODE_POINTS.LESS_THAN_SIGN: {
                    token.data += '<';
                    this.state = State$1.COMMENT_LESS_THAN_SIGN;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    token.data += REPLACEMENT_CHARACTER;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInComment);
                    this.emitCurrentComment(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    token.data += String.fromCodePoint(cp);
                }
            }
        }
        // Comment less-than sign state
        //------------------------------------------------------------------
        _stateCommentLessThanSign(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.EXCLAMATION_MARK: {
                    token.data += '!';
                    this.state = State$1.COMMENT_LESS_THAN_SIGN_BANG;
                    break;
                }
                case CODE_POINTS.LESS_THAN_SIGN: {
                    token.data += '<';
                    break;
                }
                default: {
                    this.state = State$1.COMMENT;
                    this._stateComment(cp);
                }
            }
        }
        // Comment less-than sign bang state
        //------------------------------------------------------------------
        _stateCommentLessThanSignBang(cp) {
            if (cp === CODE_POINTS.HYPHEN_MINUS) {
                this.state = State$1.COMMENT_LESS_THAN_SIGN_BANG_DASH;
            }
            else {
                this.state = State$1.COMMENT;
                this._stateComment(cp);
            }
        }
        // Comment less-than sign bang dash state
        //------------------------------------------------------------------
        _stateCommentLessThanSignBangDash(cp) {
            if (cp === CODE_POINTS.HYPHEN_MINUS) {
                this.state = State$1.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;
            }
            else {
                this.state = State$1.COMMENT_END_DASH;
                this._stateCommentEndDash(cp);
            }
        }
        // Comment less-than sign bang dash dash state
        //------------------------------------------------------------------
        _stateCommentLessThanSignBangDashDash(cp) {
            if (cp !== CODE_POINTS.GREATER_THAN_SIGN && cp !== CODE_POINTS.EOF) {
                this._err(ERR.nestedComment);
            }
            this.state = State$1.COMMENT_END;
            this._stateCommentEnd(cp);
        }
        // Comment end dash state
        //------------------------------------------------------------------
        _stateCommentEndDash(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.HYPHEN_MINUS: {
                    this.state = State$1.COMMENT_END;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInComment);
                    this.emitCurrentComment(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    token.data += '-';
                    this.state = State$1.COMMENT;
                    this._stateComment(cp);
                }
            }
        }
        // Comment end state
        //------------------------------------------------------------------
        _stateCommentEnd(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.state = State$1.DATA;
                    this.emitCurrentComment(token);
                    break;
                }
                case CODE_POINTS.EXCLAMATION_MARK: {
                    this.state = State$1.COMMENT_END_BANG;
                    break;
                }
                case CODE_POINTS.HYPHEN_MINUS: {
                    token.data += '-';
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInComment);
                    this.emitCurrentComment(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    token.data += '--';
                    this.state = State$1.COMMENT;
                    this._stateComment(cp);
                }
            }
        }
        // Comment end bang state
        //------------------------------------------------------------------
        _stateCommentEndBang(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.HYPHEN_MINUS: {
                    token.data += '--!';
                    this.state = State$1.COMMENT_END_DASH;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._err(ERR.incorrectlyClosedComment);
                    this.state = State$1.DATA;
                    this.emitCurrentComment(token);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInComment);
                    this.emitCurrentComment(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    token.data += '--!';
                    this.state = State$1.COMMENT;
                    this._stateComment(cp);
                }
            }
        }
        // DOCTYPE state
        //------------------------------------------------------------------
        _stateDoctype(cp) {
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    this.state = State$1.BEFORE_DOCTYPE_NAME;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.state = State$1.BEFORE_DOCTYPE_NAME;
                    this._stateBeforeDoctypeName(cp);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    this._createDoctypeToken(null);
                    const token = this.currentToken;
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._err(ERR.missingWhitespaceBeforeDoctypeName);
                    this.state = State$1.BEFORE_DOCTYPE_NAME;
                    this._stateBeforeDoctypeName(cp);
                }
            }
        }
        // Before DOCTYPE name state
        //------------------------------------------------------------------
        _stateBeforeDoctypeName(cp) {
            if (isAsciiUpper(cp)) {
                this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));
                this.state = State$1.DOCTYPE_NAME;
            }
            else
                switch (cp) {
                    case CODE_POINTS.SPACE:
                    case CODE_POINTS.LINE_FEED:
                    case CODE_POINTS.TABULATION:
                    case CODE_POINTS.FORM_FEED: {
                        // Ignore whitespace
                        break;
                    }
                    case CODE_POINTS.NULL: {
                        this._err(ERR.unexpectedNullCharacter);
                        this._createDoctypeToken(REPLACEMENT_CHARACTER);
                        this.state = State$1.DOCTYPE_NAME;
                        break;
                    }
                    case CODE_POINTS.GREATER_THAN_SIGN: {
                        this._err(ERR.missingDoctypeName);
                        this._createDoctypeToken(null);
                        const token = this.currentToken;
                        token.forceQuirks = true;
                        this.emitCurrentDoctype(token);
                        this.state = State$1.DATA;
                        break;
                    }
                    case CODE_POINTS.EOF: {
                        this._err(ERR.eofInDoctype);
                        this._createDoctypeToken(null);
                        const token = this.currentToken;
                        token.forceQuirks = true;
                        this.emitCurrentDoctype(token);
                        this._emitEOFToken();
                        break;
                    }
                    default: {
                        this._createDoctypeToken(String.fromCodePoint(cp));
                        this.state = State$1.DOCTYPE_NAME;
                    }
                }
        }
        // DOCTYPE name state
        //------------------------------------------------------------------
        _stateDoctypeName(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    this.state = State$1.AFTER_DOCTYPE_NAME;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.state = State$1.DATA;
                    this.emitCurrentDoctype(token);
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    token.name += REPLACEMENT_CHARACTER;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);
                }
            }
        }
        // After DOCTYPE name state
        //------------------------------------------------------------------
        _stateAfterDoctypeName(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    // Ignore whitespace
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.state = State$1.DATA;
                    this.emitCurrentDoctype(token);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    if (this._consumeSequenceIfMatch(SEQUENCES.PUBLIC, false)) {
                        this.state = State$1.AFTER_DOCTYPE_PUBLIC_KEYWORD;
                    }
                    else if (this._consumeSequenceIfMatch(SEQUENCES.SYSTEM, false)) {
                        this.state = State$1.AFTER_DOCTYPE_SYSTEM_KEYWORD;
                    }
                    //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup
                    //results are no longer valid and we will need to start over.
                    else if (!this._ensureHibernation()) {
                        this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
                        token.forceQuirks = true;
                        this.state = State$1.BOGUS_DOCTYPE;
                        this._stateBogusDoctype(cp);
                    }
                }
            }
        }
        // After DOCTYPE public keyword state
        //------------------------------------------------------------------
        _stateAfterDoctypePublicKeyword(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    this.state = State$1.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
                    break;
                }
                case CODE_POINTS.QUOTATION_MARK: {
                    this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
                    token.publicId = '';
                    this.state = State$1.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
                    break;
                }
                case CODE_POINTS.APOSTROPHE: {
                    this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
                    token.publicId = '';
                    this.state = State$1.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._err(ERR.missingDoctypePublicIdentifier);
                    token.forceQuirks = true;
                    this.state = State$1.DATA;
                    this.emitCurrentDoctype(token);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
                    token.forceQuirks = true;
                    this.state = State$1.BOGUS_DOCTYPE;
                    this._stateBogusDoctype(cp);
                }
            }
        }
        // Before DOCTYPE public identifier state
        //------------------------------------------------------------------
        _stateBeforeDoctypePublicIdentifier(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    // Ignore whitespace
                    break;
                }
                case CODE_POINTS.QUOTATION_MARK: {
                    token.publicId = '';
                    this.state = State$1.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
                    break;
                }
                case CODE_POINTS.APOSTROPHE: {
                    token.publicId = '';
                    this.state = State$1.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._err(ERR.missingDoctypePublicIdentifier);
                    token.forceQuirks = true;
                    this.state = State$1.DATA;
                    this.emitCurrentDoctype(token);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
                    token.forceQuirks = true;
                    this.state = State$1.BOGUS_DOCTYPE;
                    this._stateBogusDoctype(cp);
                }
            }
        }
        // DOCTYPE public identifier (double-quoted) state
        //------------------------------------------------------------------
        _stateDoctypePublicIdentifierDoubleQuoted(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.QUOTATION_MARK: {
                    this.state = State$1.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    token.publicId += REPLACEMENT_CHARACTER;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._err(ERR.abruptDoctypePublicIdentifier);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this.state = State$1.DATA;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    token.publicId += String.fromCodePoint(cp);
                }
            }
        }
        // DOCTYPE public identifier (single-quoted) state
        //------------------------------------------------------------------
        _stateDoctypePublicIdentifierSingleQuoted(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.APOSTROPHE: {
                    this.state = State$1.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    token.publicId += REPLACEMENT_CHARACTER;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._err(ERR.abruptDoctypePublicIdentifier);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this.state = State$1.DATA;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    token.publicId += String.fromCodePoint(cp);
                }
            }
        }
        // After DOCTYPE public identifier state
        //------------------------------------------------------------------
        _stateAfterDoctypePublicIdentifier(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    this.state = State$1.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.state = State$1.DATA;
                    this.emitCurrentDoctype(token);
                    break;
                }
                case CODE_POINTS.QUOTATION_MARK: {
                    this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
                    token.systemId = '';
                    this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
                    break;
                }
                case CODE_POINTS.APOSTROPHE: {
                    this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
                    token.systemId = '';
                    this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
                    token.forceQuirks = true;
                    this.state = State$1.BOGUS_DOCTYPE;
                    this._stateBogusDoctype(cp);
                }
            }
        }
        // Between DOCTYPE public and system identifiers state
        //------------------------------------------------------------------
        _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    // Ignore whitespace
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.emitCurrentDoctype(token);
                    this.state = State$1.DATA;
                    break;
                }
                case CODE_POINTS.QUOTATION_MARK: {
                    token.systemId = '';
                    this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
                    break;
                }
                case CODE_POINTS.APOSTROPHE: {
                    token.systemId = '';
                    this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
                    token.forceQuirks = true;
                    this.state = State$1.BOGUS_DOCTYPE;
                    this._stateBogusDoctype(cp);
                }
            }
        }
        // After DOCTYPE system keyword state
        //------------------------------------------------------------------
        _stateAfterDoctypeSystemKeyword(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    this.state = State$1.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
                    break;
                }
                case CODE_POINTS.QUOTATION_MARK: {
                    this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
                    token.systemId = '';
                    this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
                    break;
                }
                case CODE_POINTS.APOSTROPHE: {
                    this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
                    token.systemId = '';
                    this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._err(ERR.missingDoctypeSystemIdentifier);
                    token.forceQuirks = true;
                    this.state = State$1.DATA;
                    this.emitCurrentDoctype(token);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
                    token.forceQuirks = true;
                    this.state = State$1.BOGUS_DOCTYPE;
                    this._stateBogusDoctype(cp);
                }
            }
        }
        // Before DOCTYPE system identifier state
        //------------------------------------------------------------------
        _stateBeforeDoctypeSystemIdentifier(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    // Ignore whitespace
                    break;
                }
                case CODE_POINTS.QUOTATION_MARK: {
                    token.systemId = '';
                    this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
                    break;
                }
                case CODE_POINTS.APOSTROPHE: {
                    token.systemId = '';
                    this.state = State$1.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._err(ERR.missingDoctypeSystemIdentifier);
                    token.forceQuirks = true;
                    this.state = State$1.DATA;
                    this.emitCurrentDoctype(token);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
                    token.forceQuirks = true;
                    this.state = State$1.BOGUS_DOCTYPE;
                    this._stateBogusDoctype(cp);
                }
            }
        }
        // DOCTYPE system identifier (double-quoted) state
        //------------------------------------------------------------------
        _stateDoctypeSystemIdentifierDoubleQuoted(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.QUOTATION_MARK: {
                    this.state = State$1.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    token.systemId += REPLACEMENT_CHARACTER;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._err(ERR.abruptDoctypeSystemIdentifier);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this.state = State$1.DATA;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    token.systemId += String.fromCodePoint(cp);
                }
            }
        }
        // DOCTYPE system identifier (single-quoted) state
        //------------------------------------------------------------------
        _stateDoctypeSystemIdentifierSingleQuoted(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.APOSTROPHE: {
                    this.state = State$1.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    token.systemId += REPLACEMENT_CHARACTER;
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this._err(ERR.abruptDoctypeSystemIdentifier);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this.state = State$1.DATA;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    token.systemId += String.fromCodePoint(cp);
                }
            }
        }
        // After DOCTYPE system identifier state
        //------------------------------------------------------------------
        _stateAfterDoctypeSystemIdentifier(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.SPACE:
                case CODE_POINTS.LINE_FEED:
                case CODE_POINTS.TABULATION:
                case CODE_POINTS.FORM_FEED: {
                    // Ignore whitespace
                    break;
                }
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.emitCurrentDoctype(token);
                    this.state = State$1.DATA;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInDoctype);
                    token.forceQuirks = true;
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
                    this.state = State$1.BOGUS_DOCTYPE;
                    this._stateBogusDoctype(cp);
                }
            }
        }
        // Bogus DOCTYPE state
        //------------------------------------------------------------------
        _stateBogusDoctype(cp) {
            const token = this.currentToken;
            switch (cp) {
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.emitCurrentDoctype(token);
                    this.state = State$1.DATA;
                    break;
                }
                case CODE_POINTS.NULL: {
                    this._err(ERR.unexpectedNullCharacter);
                    break;
                }
                case CODE_POINTS.EOF: {
                    this.emitCurrentDoctype(token);
                    this._emitEOFToken();
                    break;
                }
                // Do nothing
            }
        }
        // CDATA section state
        //------------------------------------------------------------------
        _stateCdataSection(cp) {
            switch (cp) {
                case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
                    this.state = State$1.CDATA_SECTION_BRACKET;
                    break;
                }
                case CODE_POINTS.EOF: {
                    this._err(ERR.eofInCdata);
                    this._emitEOFToken();
                    break;
                }
                default: {
                    this._emitCodePoint(cp);
                }
            }
        }
        // CDATA section bracket state
        //------------------------------------------------------------------
        _stateCdataSectionBracket(cp) {
            if (cp === CODE_POINTS.RIGHT_SQUARE_BRACKET) {
                this.state = State$1.CDATA_SECTION_END;
            }
            else {
                this._emitChars(']');
                this.state = State$1.CDATA_SECTION;
                this._stateCdataSection(cp);
            }
        }
        // CDATA section end state
        //------------------------------------------------------------------
        _stateCdataSectionEnd(cp) {
            switch (cp) {
                case CODE_POINTS.GREATER_THAN_SIGN: {
                    this.state = State$1.DATA;
                    break;
                }
                case CODE_POINTS.RIGHT_SQUARE_BRACKET: {
                    this._emitChars(']');
                    break;
                }
                default: {
                    this._emitChars(']]');
                    this.state = State$1.CDATA_SECTION;
                    this._stateCdataSection(cp);
                }
            }
        }
        // Character reference state
        //------------------------------------------------------------------
        _stateCharacterReference(cp) {
            if (cp === CODE_POINTS.NUMBER_SIGN) {
                this.state = State$1.NUMERIC_CHARACTER_REFERENCE;
            }
            else if (isAsciiAlphaNumeric(cp)) {
                this.state = State$1.NAMED_CHARACTER_REFERENCE;
                this._stateNamedCharacterReference(cp);
            }
            else {
                this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
                this._reconsumeInState(this.returnState, cp);
            }
        }
        // Named character reference state
        //------------------------------------------------------------------
        _stateNamedCharacterReference(cp) {
            const matchResult = this._matchNamedCharacterReference(cp);
            //NOTE: Matching can be abrupted by hibernation. In that case, match
            //results are no longer valid and we will need to start over.
            if (this._ensureHibernation()) ;
            else if (matchResult) {
                for (let i = 0; i < matchResult.length; i++) {
                    this._flushCodePointConsumedAsCharacterReference(matchResult[i]);
                }
                this.state = this.returnState;
            }
            else {
                this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
                this.state = State$1.AMBIGUOUS_AMPERSAND;
            }
        }
        // Ambiguos ampersand state
        //------------------------------------------------------------------
        _stateAmbiguousAmpersand(cp) {
            if (isAsciiAlphaNumeric(cp)) {
                this._flushCodePointConsumedAsCharacterReference(cp);
            }
            else {
                if (cp === CODE_POINTS.SEMICOLON) {
                    this._err(ERR.unknownNamedCharacterReference);
                }
                this._reconsumeInState(this.returnState, cp);
            }
        }
        // Numeric character reference state
        //------------------------------------------------------------------
        _stateNumericCharacterReference(cp) {
            this.charRefCode = 0;
            if (cp === CODE_POINTS.LATIN_SMALL_X || cp === CODE_POINTS.LATIN_CAPITAL_X) {
                this.state = State$1.HEXADEMICAL_CHARACTER_REFERENCE_START;
            }
            // Inlined decimal character reference start state
            else if (isAsciiDigit(cp)) {
                this.state = State$1.DECIMAL_CHARACTER_REFERENCE;
                this._stateDecimalCharacterReference(cp);
            }
            else {
                this._err(ERR.absenceOfDigitsInNumericCharacterReference);
                this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
                this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
                this._reconsumeInState(this.returnState, cp);
            }
        }
        // Hexademical character reference start state
        //------------------------------------------------------------------
        _stateHexademicalCharacterReferenceStart(cp) {
            if (isAsciiHexDigit(cp)) {
                this.state = State$1.HEXADEMICAL_CHARACTER_REFERENCE;
                this._stateHexademicalCharacterReference(cp);
            }
            else {
                this._err(ERR.absenceOfDigitsInNumericCharacterReference);
                this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.AMPERSAND);
                this._flushCodePointConsumedAsCharacterReference(CODE_POINTS.NUMBER_SIGN);
                this._unconsume(2);
                this.state = this.returnState;
            }
        }
        // Hexademical character reference state
        //------------------------------------------------------------------
        _stateHexademicalCharacterReference(cp) {
            if (isAsciiUpperHexDigit(cp)) {
                this.charRefCode = this.charRefCode * 16 + cp - 0x37;
            }
            else if (isAsciiLowerHexDigit(cp)) {
                this.charRefCode = this.charRefCode * 16 + cp - 0x57;
            }
            else if (isAsciiDigit(cp)) {
                this.charRefCode = this.charRefCode * 16 + cp - 0x30;
            }
            else if (cp === CODE_POINTS.SEMICOLON) {
                this.state = State$1.NUMERIC_CHARACTER_REFERENCE_END;
            }
            else {
                this._err(ERR.missingSemicolonAfterCharacterReference);
                this.state = State$1.NUMERIC_CHARACTER_REFERENCE_END;
                this._stateNumericCharacterReferenceEnd(cp);
            }
        }
        // Decimal character reference state
        //------------------------------------------------------------------
        _stateDecimalCharacterReference(cp) {
            if (isAsciiDigit(cp)) {
                this.charRefCode = this.charRefCode * 10 + cp - 0x30;
            }
            else if (cp === CODE_POINTS.SEMICOLON) {
                this.state = State$1.NUMERIC_CHARACTER_REFERENCE_END;
            }
            else {
                this._err(ERR.missingSemicolonAfterCharacterReference);
                this.state = State$1.NUMERIC_CHARACTER_REFERENCE_END;
                this._stateNumericCharacterReferenceEnd(cp);
            }
        }
        // Numeric character reference end state
        //------------------------------------------------------------------
        _stateNumericCharacterReferenceEnd(cp) {
            if (this.charRefCode === CODE_POINTS.NULL) {
                this._err(ERR.nullCharacterReference);
                this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
            }
            else if (this.charRefCode > 1114111) {
                this._err(ERR.characterReferenceOutsideUnicodeRange);
                this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
            }
            else if (isSurrogate(this.charRefCode)) {
                this._err(ERR.surrogateCharacterReference);
                this.charRefCode = CODE_POINTS.REPLACEMENT_CHARACTER;
            }
            else if (isUndefinedCodePoint(this.charRefCode)) {
                this._err(ERR.noncharacterCharacterReference);
            }
            else if (isControlCodePoint(this.charRefCode) || this.charRefCode === CODE_POINTS.CARRIAGE_RETURN) {
                this._err(ERR.controlCharacterReference);
                const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS.get(this.charRefCode);
                if (replacement !== undefined) {
                    this.charRefCode = replacement;
                }
            }
            this._flushCodePointConsumedAsCharacterReference(this.charRefCode);
            this._reconsumeInState(this.returnState, cp);
        }
    }

    //Element utils
    const IMPLICIT_END_TAG_REQUIRED = new Set([TAG_ID.DD, TAG_ID.DT, TAG_ID.LI, TAG_ID.OPTGROUP, TAG_ID.OPTION, TAG_ID.P, TAG_ID.RB, TAG_ID.RP, TAG_ID.RT, TAG_ID.RTC]);
    const IMPLICIT_END_TAG_REQUIRED_THOROUGHLY = new Set([
        ...IMPLICIT_END_TAG_REQUIRED,
        TAG_ID.CAPTION,
        TAG_ID.COLGROUP,
        TAG_ID.TBODY,
        TAG_ID.TD,
        TAG_ID.TFOOT,
        TAG_ID.TH,
        TAG_ID.THEAD,
        TAG_ID.TR,
    ]);
    const SCOPING_ELEMENT_NS = new Map([
        [TAG_ID.APPLET, NS.HTML],
        [TAG_ID.CAPTION, NS.HTML],
        [TAG_ID.HTML, NS.HTML],
        [TAG_ID.MARQUEE, NS.HTML],
        [TAG_ID.OBJECT, NS.HTML],
        [TAG_ID.TABLE, NS.HTML],
        [TAG_ID.TD, NS.HTML],
        [TAG_ID.TEMPLATE, NS.HTML],
        [TAG_ID.TH, NS.HTML],
        [TAG_ID.ANNOTATION_XML, NS.MATHML],
        [TAG_ID.MI, NS.MATHML],
        [TAG_ID.MN, NS.MATHML],
        [TAG_ID.MO, NS.MATHML],
        [TAG_ID.MS, NS.MATHML],
        [TAG_ID.MTEXT, NS.MATHML],
        [TAG_ID.DESC, NS.SVG],
        [TAG_ID.FOREIGN_OBJECT, NS.SVG],
        [TAG_ID.TITLE, NS.SVG],
    ]);
    const NAMED_HEADERS = [TAG_ID.H1, TAG_ID.H2, TAG_ID.H3, TAG_ID.H4, TAG_ID.H5, TAG_ID.H6];
    const TABLE_ROW_CONTEXT = [TAG_ID.TR, TAG_ID.TEMPLATE, TAG_ID.HTML];
    const TABLE_BODY_CONTEXT = [TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TEMPLATE, TAG_ID.HTML];
    const TABLE_CONTEXT = [TAG_ID.TABLE, TAG_ID.TEMPLATE, TAG_ID.HTML];
    const TABLE_CELLS = [TAG_ID.TD, TAG_ID.TH];
    //Stack of open elements
    class OpenElementStack {
        get currentTmplContentOrNode() {
            return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
        }
        constructor(document, treeAdapter, handler) {
            this.treeAdapter = treeAdapter;
            this.handler = handler;
            this.items = [];
            this.tagIDs = [];
            this.stackTop = -1;
            this.tmplCount = 0;
            this.currentTagId = TAG_ID.UNKNOWN;
            this.current = document;
        }
        //Index of element
        _indexOf(element) {
            return this.items.lastIndexOf(element, this.stackTop);
        }
        //Update current element
        _isInTemplate() {
            return this.currentTagId === TAG_ID.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === NS.HTML;
        }
        _updateCurrentElement() {
            this.current = this.items[this.stackTop];
            this.currentTagId = this.tagIDs[this.stackTop];
        }
        //Mutations
        push(element, tagID) {
            this.stackTop++;
            this.items[this.stackTop] = element;
            this.current = element;
            this.tagIDs[this.stackTop] = tagID;
            this.currentTagId = tagID;
            if (this._isInTemplate()) {
                this.tmplCount++;
            }
            this.handler.onItemPush(element, tagID, true);
        }
        pop() {
            const popped = this.current;
            if (this.tmplCount > 0 && this._isInTemplate()) {
                this.tmplCount--;
            }
            this.stackTop--;
            this._updateCurrentElement();
            this.handler.onItemPop(popped, true);
        }
        replace(oldElement, newElement) {
            const idx = this._indexOf(oldElement);
            this.items[idx] = newElement;
            if (idx === this.stackTop) {
                this.current = newElement;
            }
        }
        insertAfter(referenceElement, newElement, newElementID) {
            const insertionIdx = this._indexOf(referenceElement) + 1;
            this.items.splice(insertionIdx, 0, newElement);
            this.tagIDs.splice(insertionIdx, 0, newElementID);
            this.stackTop++;
            if (insertionIdx === this.stackTop) {
                this._updateCurrentElement();
            }
            this.handler.onItemPush(this.current, this.currentTagId, insertionIdx === this.stackTop);
        }
        popUntilTagNamePopped(tagName) {
            let targetIdx = this.stackTop + 1;
            do {
                targetIdx = this.tagIDs.lastIndexOf(tagName, targetIdx - 1);
            } while (targetIdx > 0 && this.treeAdapter.getNamespaceURI(this.items[targetIdx]) !== NS.HTML);
            this.shortenToLength(targetIdx < 0 ? 0 : targetIdx);
        }
        shortenToLength(idx) {
            while (this.stackTop >= idx) {
                const popped = this.current;
                if (this.tmplCount > 0 && this._isInTemplate()) {
                    this.tmplCount -= 1;
                }
                this.stackTop--;
                this._updateCurrentElement();
                this.handler.onItemPop(popped, this.stackTop < idx);
            }
        }
        popUntilElementPopped(element) {
            const idx = this._indexOf(element);
            this.shortenToLength(idx < 0 ? 0 : idx);
        }
        popUntilPopped(tagNames, targetNS) {
            const idx = this._indexOfTagNames(tagNames, targetNS);
            this.shortenToLength(idx < 0 ? 0 : idx);
        }
        popUntilNumberedHeaderPopped() {
            this.popUntilPopped(NAMED_HEADERS, NS.HTML);
        }
        popUntilTableCellPopped() {
            this.popUntilPopped(TABLE_CELLS, NS.HTML);
        }
        popAllUpToHtmlElement() {
            //NOTE: here we assume that the root <html> element is always first in the open element stack, so
            //we perform this fast stack clean up.
            this.tmplCount = 0;
            this.shortenToLength(1);
        }
        _indexOfTagNames(tagNames, namespace) {
            for (let i = this.stackTop; i >= 0; i--) {
                if (tagNames.includes(this.tagIDs[i]) && this.treeAdapter.getNamespaceURI(this.items[i]) === namespace) {
                    return i;
                }
            }
            return -1;
        }
        clearBackTo(tagNames, targetNS) {
            const idx = this._indexOfTagNames(tagNames, targetNS);
            this.shortenToLength(idx + 1);
        }
        clearBackToTableContext() {
            this.clearBackTo(TABLE_CONTEXT, NS.HTML);
        }
        clearBackToTableBodyContext() {
            this.clearBackTo(TABLE_BODY_CONTEXT, NS.HTML);
        }
        clearBackToTableRowContext() {
            this.clearBackTo(TABLE_ROW_CONTEXT, NS.HTML);
        }
        remove(element) {
            const idx = this._indexOf(element);
            if (idx >= 0) {
                if (idx === this.stackTop) {
                    this.pop();
                }
                else {
                    this.items.splice(idx, 1);
                    this.tagIDs.splice(idx, 1);
                    this.stackTop--;
                    this._updateCurrentElement();
                    this.handler.onItemPop(element, false);
                }
            }
        }
        //Search
        tryPeekProperlyNestedBodyElement() {
            //Properly nested <body> element (should be second element in stack).
            return this.stackTop >= 1 && this.tagIDs[1] === TAG_ID.BODY ? this.items[1] : null;
        }
        contains(element) {
            return this._indexOf(element) > -1;
        }
        getCommonAncestor(element) {
            const elementIdx = this._indexOf(element) - 1;
            return elementIdx >= 0 ? this.items[elementIdx] : null;
        }
        isRootHtmlElementCurrent() {
            return this.stackTop === 0 && this.tagIDs[0] === TAG_ID.HTML;
        }
        //Element in scope
        hasInScope(tagName) {
            for (let i = this.stackTop; i >= 0; i--) {
                const tn = this.tagIDs[i];
                const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
                if (tn === tagName && ns === NS.HTML) {
                    return true;
                }
                if (SCOPING_ELEMENT_NS.get(tn) === ns) {
                    return false;
                }
            }
            return true;
        }
        hasNumberedHeaderInScope() {
            for (let i = this.stackTop; i >= 0; i--) {
                const tn = this.tagIDs[i];
                const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
                if (isNumberedHeader(tn) && ns === NS.HTML) {
                    return true;
                }
                if (SCOPING_ELEMENT_NS.get(tn) === ns) {
                    return false;
                }
            }
            return true;
        }
        hasInListItemScope(tagName) {
            for (let i = this.stackTop; i >= 0; i--) {
                const tn = this.tagIDs[i];
                const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
                if (tn === tagName && ns === NS.HTML) {
                    return true;
                }
                if (((tn === TAG_ID.UL || tn === TAG_ID.OL) && ns === NS.HTML) || SCOPING_ELEMENT_NS.get(tn) === ns) {
                    return false;
                }
            }
            return true;
        }
        hasInButtonScope(tagName) {
            for (let i = this.stackTop; i >= 0; i--) {
                const tn = this.tagIDs[i];
                const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
                if (tn === tagName && ns === NS.HTML) {
                    return true;
                }
                if ((tn === TAG_ID.BUTTON && ns === NS.HTML) || SCOPING_ELEMENT_NS.get(tn) === ns) {
                    return false;
                }
            }
            return true;
        }
        hasInTableScope(tagName) {
            for (let i = this.stackTop; i >= 0; i--) {
                const tn = this.tagIDs[i];
                const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
                if (ns !== NS.HTML) {
                    continue;
                }
                if (tn === tagName) {
                    return true;
                }
                if (tn === TAG_ID.TABLE || tn === TAG_ID.TEMPLATE || tn === TAG_ID.HTML) {
                    return false;
                }
            }
            return true;
        }
        hasTableBodyContextInTableScope() {
            for (let i = this.stackTop; i >= 0; i--) {
                const tn = this.tagIDs[i];
                const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
                if (ns !== NS.HTML) {
                    continue;
                }
                if (tn === TAG_ID.TBODY || tn === TAG_ID.THEAD || tn === TAG_ID.TFOOT) {
                    return true;
                }
                if (tn === TAG_ID.TABLE || tn === TAG_ID.HTML) {
                    return false;
                }
            }
            return true;
        }
        hasInSelectScope(tagName) {
            for (let i = this.stackTop; i >= 0; i--) {
                const tn = this.tagIDs[i];
                const ns = this.treeAdapter.getNamespaceURI(this.items[i]);
                if (ns !== NS.HTML) {
                    continue;
                }
                if (tn === tagName) {
                    return true;
                }
                if (tn !== TAG_ID.OPTION && tn !== TAG_ID.OPTGROUP) {
                    return false;
                }
            }
            return true;
        }
        //Implied end tags
        generateImpliedEndTags() {
            while (IMPLICIT_END_TAG_REQUIRED.has(this.currentTagId)) {
                this.pop();
            }
        }
        generateImpliedEndTagsThoroughly() {
            while (IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
                this.pop();
            }
        }
        generateImpliedEndTagsWithExclusion(exclusionId) {
            while (this.currentTagId !== exclusionId && IMPLICIT_END_TAG_REQUIRED_THOROUGHLY.has(this.currentTagId)) {
                this.pop();
            }
        }
    }

    //Const
    const NOAH_ARK_CAPACITY = 3;
    var EntryType;
    (function (EntryType) {
        EntryType[EntryType["Marker"] = 0] = "Marker";
        EntryType[EntryType["Element"] = 1] = "Element";
    })(EntryType = EntryType || (EntryType = {}));
    const MARKER = { type: EntryType.Marker };
    //List of formatting elements
    class FormattingElementList {
        constructor(treeAdapter) {
            this.treeAdapter = treeAdapter;
            this.entries = [];
            this.bookmark = null;
        }
        //Noah Ark's condition
        //OPTIMIZATION: at first we try to find possible candidates for exclusion using
        //lightweight heuristics without thorough attributes check.
        _getNoahArkConditionCandidates(newElement, neAttrs) {
            const candidates = [];
            const neAttrsLength = neAttrs.length;
            const neTagName = this.treeAdapter.getTagName(newElement);
            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
            for (let i = 0; i < this.entries.length; i++) {
                const entry = this.entries[i];
                if (entry.type === EntryType.Marker) {
                    break;
                }
                const { element } = entry;
                if (this.treeAdapter.getTagName(element) === neTagName &&
                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {
                    const elementAttrs = this.treeAdapter.getAttrList(element);
                    if (elementAttrs.length === neAttrsLength) {
                        candidates.push({ idx: i, attrs: elementAttrs });
                    }
                }
            }
            return candidates;
        }
        _ensureNoahArkCondition(newElement) {
            if (this.entries.length < NOAH_ARK_CAPACITY)
                return;
            const neAttrs = this.treeAdapter.getAttrList(newElement);
            const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);
            if (candidates.length < NOAH_ARK_CAPACITY)
                return;
            //NOTE: build attrs map for the new element, so we can perform fast lookups
            const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));
            let validCandidates = 0;
            //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met
            for (let i = 0; i < candidates.length; i++) {
                const candidate = candidates[i];
                // We know that `candidate.attrs.length === neAttrs.length`
                if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {
                    validCandidates += 1;
                    if (validCandidates >= NOAH_ARK_CAPACITY) {
                        this.entries.splice(candidate.idx, 1);
                    }
                }
            }
        }
        //Mutations
        insertMarker() {
            this.entries.unshift(MARKER);
        }
        pushElement(element, token) {
            this._ensureNoahArkCondition(element);
            this.entries.unshift({
                type: EntryType.Element,
                element,
                token,
            });
        }
        insertElementAfterBookmark(element, token) {
            const bookmarkIdx = this.entries.indexOf(this.bookmark);
            this.entries.splice(bookmarkIdx, 0, {
                type: EntryType.Element,
                element,
                token,
            });
        }
        removeEntry(entry) {
            const entryIndex = this.entries.indexOf(entry);
            if (entryIndex >= 0) {
                this.entries.splice(entryIndex, 1);
            }
        }
        /**
         * Clears the list of formatting elements up to the last marker.
         *
         * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
         */
        clearToLastMarker() {
            const markerIdx = this.entries.indexOf(MARKER);
            if (markerIdx >= 0) {
                this.entries.splice(0, markerIdx + 1);
            }
            else {
                this.entries.length = 0;
            }
        }
        //Search
        getElementEntryInScopeWithTagName(tagName) {
            const entry = this.entries.find((entry) => entry.type === EntryType.Marker || this.treeAdapter.getTagName(entry.element) === tagName);
            return entry && entry.type === EntryType.Element ? entry : null;
        }
        getElementEntry(element) {
            return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);
        }
    }

    function createTextNode$1(value) {
        return {
            nodeName: '#text',
            value,
            parentNode: null,
        };
    }
    const defaultTreeAdapter = {
        //Node construction
        createDocument() {
            return {
                nodeName: '#document',
                mode: DOCUMENT_MODE.NO_QUIRKS,
                childNodes: [],
            };
        },
        createDocumentFragment() {
            return {
                nodeName: '#document-fragment',
                childNodes: [],
            };
        },
        createElement(tagName, namespaceURI, attrs) {
            return {
                nodeName: tagName,
                tagName,
                attrs,
                namespaceURI,
                childNodes: [],
                parentNode: null,
            };
        },
        createCommentNode(data) {
            return {
                nodeName: '#comment',
                data,
                parentNode: null,
            };
        },
        //Tree mutation
        appendChild(parentNode, newNode) {
            parentNode.childNodes.push(newNode);
            newNode.parentNode = parentNode;
        },
        insertBefore(parentNode, newNode, referenceNode) {
            const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
            parentNode.childNodes.splice(insertionIdx, 0, newNode);
            newNode.parentNode = parentNode;
        },
        setTemplateContent(templateElement, contentElement) {
            templateElement.content = contentElement;
        },
        getTemplateContent(templateElement) {
            return templateElement.content;
        },
        setDocumentType(document, name, publicId, systemId) {
            const doctypeNode = document.childNodes.find((node) => node.nodeName === '#documentType');
            if (doctypeNode) {
                doctypeNode.name = name;
                doctypeNode.publicId = publicId;
                doctypeNode.systemId = systemId;
            }
            else {
                const node = {
                    nodeName: '#documentType',
                    name,
                    publicId,
                    systemId,
                    parentNode: null,
                };
                defaultTreeAdapter.appendChild(document, node);
            }
        },
        setDocumentMode(document, mode) {
            document.mode = mode;
        },
        getDocumentMode(document) {
            return document.mode;
        },
        detachNode(node) {
            if (node.parentNode) {
                const idx = node.parentNode.childNodes.indexOf(node);
                node.parentNode.childNodes.splice(idx, 1);
                node.parentNode = null;
            }
        },
        insertText(parentNode, text) {
            if (parentNode.childNodes.length > 0) {
                const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
                if (defaultTreeAdapter.isTextNode(prevNode)) {
                    prevNode.value += text;
                    return;
                }
            }
            defaultTreeAdapter.appendChild(parentNode, createTextNode$1(text));
        },
        insertTextBefore(parentNode, text, referenceNode) {
            const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
            if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {
                prevNode.value += text;
            }
            else {
                defaultTreeAdapter.insertBefore(parentNode, createTextNode$1(text), referenceNode);
            }
        },
        adoptAttributes(recipient, attrs) {
            const recipientAttrsMap = new Set(recipient.attrs.map((attr) => attr.name));
            for (let j = 0; j < attrs.length; j++) {
                if (!recipientAttrsMap.has(attrs[j].name)) {
                    recipient.attrs.push(attrs[j]);
                }
            }
        },
        //Tree traversing
        getFirstChild(node) {
            return node.childNodes[0];
        },
        getChildNodes(node) {
            return node.childNodes;
        },
        getParentNode(node) {
            return node.parentNode;
        },
        getAttrList(element) {
            return element.attrs;
        },
        //Node data
        getTagName(element) {
            return element.tagName;
        },
        getNamespaceURI(element) {
            return element.namespaceURI;
        },
        getTextNodeContent(textNode) {
            return textNode.value;
        },
        getCommentNodeContent(commentNode) {
            return commentNode.data;
        },
        getDocumentTypeNodeName(doctypeNode) {
            return doctypeNode.name;
        },
        getDocumentTypeNodePublicId(doctypeNode) {
            return doctypeNode.publicId;
        },
        getDocumentTypeNodeSystemId(doctypeNode) {
            return doctypeNode.systemId;
        },
        //Node types
        isTextNode(node) {
            return node.nodeName === '#text';
        },
        isCommentNode(node) {
            return node.nodeName === '#comment';
        },
        isDocumentTypeNode(node) {
            return node.nodeName === '#documentType';
        },
        isElementNode(node) {
            return Object.prototype.hasOwnProperty.call(node, 'tagName');
        },
        // Source code location
        setNodeSourceCodeLocation(node, location) {
            node.sourceCodeLocation = location;
        },
        getNodeSourceCodeLocation(node) {
            return node.sourceCodeLocation;
        },
        updateNodeSourceCodeLocation(node, endLocation) {
            node.sourceCodeLocation = { ...node.sourceCodeLocation, ...endLocation };
        },
    };

    //Const
    const VALID_DOCTYPE_NAME = 'html';
    const VALID_SYSTEM_ID = 'about:legacy-compat';
    const QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';
    const QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
        '+//silmaril//dtd html pro v0r11 19970101//',
        '-//as//dtd html 3.0 aswedit + extensions//',
        '-//advasoft ltd//dtd html 3.0 aswedit + extensions//',
        '-//ietf//dtd html 2.0 level 1//',
        '-//ietf//dtd html 2.0 level 2//',
        '-//ietf//dtd html 2.0 strict level 1//',
        '-//ietf//dtd html 2.0 strict level 2//',
        '-//ietf//dtd html 2.0 strict//',
        '-//ietf//dtd html 2.0//',
        '-//ietf//dtd html 2.1e//',
        '-//ietf//dtd html 3.0//',
        '-//ietf//dtd html 3.2 final//',
        '-//ietf//dtd html 3.2//',
        '-//ietf//dtd html 3//',
        '-//ietf//dtd html level 0//',
        '-//ietf//dtd html level 1//',
        '-//ietf//dtd html level 2//',
        '-//ietf//dtd html level 3//',
        '-//ietf//dtd html strict level 0//',
        '-//ietf//dtd html strict level 1//',
        '-//ietf//dtd html strict level 2//',
        '-//ietf//dtd html strict level 3//',
        '-//ietf//dtd html strict//',
        '-//ietf//dtd html//',
        '-//metrius//dtd metrius presentational//',
        '-//microsoft//dtd internet explorer 2.0 html strict//',
        '-//microsoft//dtd internet explorer 2.0 html//',
        '-//microsoft//dtd internet explorer 2.0 tables//',
        '-//microsoft//dtd internet explorer 3.0 html strict//',
        '-//microsoft//dtd internet explorer 3.0 html//',
        '-//microsoft//dtd internet explorer 3.0 tables//',
        '-//netscape comm. corp.//dtd html//',
        '-//netscape comm. corp.//dtd strict html//',
        "-//o'reilly and associates//dtd html 2.0//",
        "-//o'reilly and associates//dtd html extended 1.0//",
        "-//o'reilly and associates//dtd html extended relaxed 1.0//",
        '-//sq//dtd html 2.0 hotmetal + extensions//',
        '-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//',
        '-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//',
        '-//spyglass//dtd html 2.0 extended//',
        '-//sun microsystems corp.//dtd hotjava html//',
        '-//sun microsystems corp.//dtd hotjava strict html//',
        '-//w3c//dtd html 3 1995-03-24//',
        '-//w3c//dtd html 3.2 draft//',
        '-//w3c//dtd html 3.2 final//',
        '-//w3c//dtd html 3.2//',
        '-//w3c//dtd html 3.2s draft//',
        '-//w3c//dtd html 4.0 frameset//',
        '-//w3c//dtd html 4.0 transitional//',
        '-//w3c//dtd html experimental 19960712//',
        '-//w3c//dtd html experimental 970421//',
        '-//w3c//dtd w3 html//',
        '-//w3o//dtd w3 html 3.0//',
        '-//webtechs//dtd mozilla html 2.0//',
        '-//webtechs//dtd mozilla html//',
    ];
    const QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
        ...QUIRKS_MODE_PUBLIC_ID_PREFIXES,
        '-//w3c//dtd html 4.01 frameset//',
        '-//w3c//dtd html 4.01 transitional//',
    ];
    const QUIRKS_MODE_PUBLIC_IDS = new Set([
        '-//w3o//dtd w3 html strict 3.0//en//',
        '-/w3c/dtd html 4.0 transitional/en',
        'html',
    ]);
    const LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'];
    const LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = [
        ...LIMITED_QUIRKS_PUBLIC_ID_PREFIXES,
        '-//w3c//dtd html 4.01 frameset//',
        '-//w3c//dtd html 4.01 transitional//',
    ];
    //Utils
    function hasPrefix(publicId, prefixes) {
        return prefixes.some((prefix) => publicId.startsWith(prefix));
    }
    //API
    function isConforming(token) {
        return (token.name === VALID_DOCTYPE_NAME &&
            token.publicId === null &&
            (token.systemId === null || token.systemId === VALID_SYSTEM_ID));
    }
    function getDocumentMode(token) {
        if (token.name !== VALID_DOCTYPE_NAME) {
            return DOCUMENT_MODE.QUIRKS;
        }
        const { systemId } = token;
        if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
            return DOCUMENT_MODE.QUIRKS;
        }
        let { publicId } = token;
        if (publicId !== null) {
            publicId = publicId.toLowerCase();
            if (QUIRKS_MODE_PUBLIC_IDS.has(publicId)) {
                return DOCUMENT_MODE.QUIRKS;
            }
            let prefixes = systemId === null ? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES : QUIRKS_MODE_PUBLIC_ID_PREFIXES;
            if (hasPrefix(publicId, prefixes)) {
                return DOCUMENT_MODE.QUIRKS;
            }
            prefixes =
                systemId === null ? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES : LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
            if (hasPrefix(publicId, prefixes)) {
                return DOCUMENT_MODE.LIMITED_QUIRKS;
            }
        }
        return DOCUMENT_MODE.NO_QUIRKS;
    }

    //MIME types
    const MIME_TYPES = {
        TEXT_HTML: 'text/html',
        APPLICATION_XML: 'application/xhtml+xml',
    };
    //Attributes
    const DEFINITION_URL_ATTR = 'definitionurl';
    const ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL';
    const SVG_ATTRS_ADJUSTMENT_MAP = new Map([
        'attributeName',
        'attributeType',
        'baseFrequency',
        'baseProfile',
        'calcMode',
        'clipPathUnits',
        'diffuseConstant',
        'edgeMode',
        'filterUnits',
        'glyphRef',
        'gradientTransform',
        'gradientUnits',
        'kernelMatrix',
        'kernelUnitLength',
        'keyPoints',
        'keySplines',
        'keyTimes',
        'lengthAdjust',
        'limitingConeAngle',
        'markerHeight',
        'markerUnits',
        'markerWidth',
        'maskContentUnits',
        'maskUnits',
        'numOctaves',
        'pathLength',
        'patternContentUnits',
        'patternTransform',
        'patternUnits',
        'pointsAtX',
        'pointsAtY',
        'pointsAtZ',
        'preserveAlpha',
        'preserveAspectRatio',
        'primitiveUnits',
        'refX',
        'refY',
        'repeatCount',
        'repeatDur',
        'requiredExtensions',
        'requiredFeatures',
        'specularConstant',
        'specularExponent',
        'spreadMethod',
        'startOffset',
        'stdDeviation',
        'stitchTiles',
        'surfaceScale',
        'systemLanguage',
        'tableValues',
        'targetX',
        'targetY',
        'textLength',
        'viewBox',
        'viewTarget',
        'xChannelSelector',
        'yChannelSelector',
        'zoomAndPan',
    ].map((attr) => [attr.toLowerCase(), attr]));
    const XML_ATTRS_ADJUSTMENT_MAP = new Map([
        ['xlink:actuate', { prefix: 'xlink', name: 'actuate', namespace: NS.XLINK }],
        ['xlink:arcrole', { prefix: 'xlink', name: 'arcrole', namespace: NS.XLINK }],
        ['xlink:href', { prefix: 'xlink', name: 'href', namespace: NS.XLINK }],
        ['xlink:role', { prefix: 'xlink', name: 'role', namespace: NS.XLINK }],
        ['xlink:show', { prefix: 'xlink', name: 'show', namespace: NS.XLINK }],
        ['xlink:title', { prefix: 'xlink', name: 'title', namespace: NS.XLINK }],
        ['xlink:type', { prefix: 'xlink', name: 'type', namespace: NS.XLINK }],
        ['xml:base', { prefix: 'xml', name: 'base', namespace: NS.XML }],
        ['xml:lang', { prefix: 'xml', name: 'lang', namespace: NS.XML }],
        ['xml:space', { prefix: 'xml', name: 'space', namespace: NS.XML }],
        ['xmlns', { prefix: '', name: 'xmlns', namespace: NS.XMLNS }],
        ['xmlns:xlink', { prefix: 'xmlns', name: 'xlink', namespace: NS.XMLNS }],
    ]);
    //SVG tag names adjustment map
    const SVG_TAG_NAMES_ADJUSTMENT_MAP = new Map([
        'altGlyph',
        'altGlyphDef',
        'altGlyphItem',
        'animateColor',
        'animateMotion',
        'animateTransform',
        'clipPath',
        'feBlend',
        'feColorMatrix',
        'feComponentTransfer',
        'feComposite',
        'feConvolveMatrix',
        'feDiffuseLighting',
        'feDisplacementMap',
        'feDistantLight',
        'feFlood',
        'feFuncA',
        'feFuncB',
        'feFuncG',
        'feFuncR',
        'feGaussianBlur',
        'feImage',
        'feMerge',
        'feMergeNode',
        'feMorphology',
        'feOffset',
        'fePointLight',
        'feSpecularLighting',
        'feSpotLight',
        'feTile',
        'feTurbulence',
        'foreignObject',
        'glyphRef',
        'linearGradient',
        'radialGradient',
        'textPath',
    ].map((tn) => [tn.toLowerCase(), tn]));
    //Tags that causes exit from foreign content
    const EXITS_FOREIGN_CONTENT = new Set([
        TAG_ID.B,
        TAG_ID.BIG,
        TAG_ID.BLOCKQUOTE,
        TAG_ID.BODY,
        TAG_ID.BR,
        TAG_ID.CENTER,
        TAG_ID.CODE,
        TAG_ID.DD,
        TAG_ID.DIV,
        TAG_ID.DL,
        TAG_ID.DT,
        TAG_ID.EM,
        TAG_ID.EMBED,
        TAG_ID.H1,
        TAG_ID.H2,
        TAG_ID.H3,
        TAG_ID.H4,
        TAG_ID.H5,
        TAG_ID.H6,
        TAG_ID.HEAD,
        TAG_ID.HR,
        TAG_ID.I,
        TAG_ID.IMG,
        TAG_ID.LI,
        TAG_ID.LISTING,
        TAG_ID.MENU,
        TAG_ID.META,
        TAG_ID.NOBR,
        TAG_ID.OL,
        TAG_ID.P,
        TAG_ID.PRE,
        TAG_ID.RUBY,
        TAG_ID.S,
        TAG_ID.SMALL,
        TAG_ID.SPAN,
        TAG_ID.STRONG,
        TAG_ID.STRIKE,
        TAG_ID.SUB,
        TAG_ID.SUP,
        TAG_ID.TABLE,
        TAG_ID.TT,
        TAG_ID.U,
        TAG_ID.UL,
        TAG_ID.VAR,
    ]);
    //Check exit from foreign content
    function causesExit(startTagToken) {
        const tn = startTagToken.tagID;
        const isFontWithAttrs = tn === TAG_ID.FONT &&
            startTagToken.attrs.some(({ name }) => name === ATTRS.COLOR || name === ATTRS.SIZE || name === ATTRS.FACE);
        return isFontWithAttrs || EXITS_FOREIGN_CONTENT.has(tn);
    }
    //Token adjustments
    function adjustTokenMathMLAttrs(token) {
        for (let i = 0; i < token.attrs.length; i++) {
            if (token.attrs[i].name === DEFINITION_URL_ATTR) {
                token.attrs[i].name = ADJUSTED_DEFINITION_URL_ATTR;
                break;
            }
        }
    }
    function adjustTokenSVGAttrs(token) {
        for (let i = 0; i < token.attrs.length; i++) {
            const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
            if (adjustedAttrName != null) {
                token.attrs[i].name = adjustedAttrName;
            }
        }
    }
    function adjustTokenXMLAttrs(token) {
        for (let i = 0; i < token.attrs.length; i++) {
            const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP.get(token.attrs[i].name);
            if (adjustedAttrEntry) {
                token.attrs[i].prefix = adjustedAttrEntry.prefix;
                token.attrs[i].name = adjustedAttrEntry.name;
                token.attrs[i].namespace = adjustedAttrEntry.namespace;
            }
        }
    }
    function adjustTokenSVGTagName(token) {
        const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP.get(token.tagName);
        if (adjustedTagName != null) {
            token.tagName = adjustedTagName;
            token.tagID = getTagID(token.tagName);
        }
    }
    //Integration points
    function isMathMLTextIntegrationPoint(tn, ns) {
        return ns === NS.MATHML && (tn === TAG_ID.MI || tn === TAG_ID.MO || tn === TAG_ID.MN || tn === TAG_ID.MS || tn === TAG_ID.MTEXT);
    }
    function isHtmlIntegrationPoint(tn, ns, attrs) {
        if (ns === NS.MATHML && tn === TAG_ID.ANNOTATION_XML) {
            for (let i = 0; i < attrs.length; i++) {
                if (attrs[i].name === ATTRS.ENCODING) {
                    const value = attrs[i].value.toLowerCase();
                    return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
                }
            }
        }
        return ns === NS.SVG && (tn === TAG_ID.FOREIGN_OBJECT || tn === TAG_ID.DESC || tn === TAG_ID.TITLE);
    }
    function isIntegrationPoint(tn, ns, attrs, foreignNS) {
        return (((!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) ||
            ((!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns)));
    }

    //Misc constants
    const HIDDEN_INPUT_TYPE = 'hidden';
    //Adoption agency loops iteration count
    const AA_OUTER_LOOP_ITER = 8;
    const AA_INNER_LOOP_ITER = 3;
    //Insertion modes
    var InsertionMode;
    (function (InsertionMode) {
        InsertionMode[InsertionMode["INITIAL"] = 0] = "INITIAL";
        InsertionMode[InsertionMode["BEFORE_HTML"] = 1] = "BEFORE_HTML";
        InsertionMode[InsertionMode["BEFORE_HEAD"] = 2] = "BEFORE_HEAD";
        InsertionMode[InsertionMode["IN_HEAD"] = 3] = "IN_HEAD";
        InsertionMode[InsertionMode["IN_HEAD_NO_SCRIPT"] = 4] = "IN_HEAD_NO_SCRIPT";
        InsertionMode[InsertionMode["AFTER_HEAD"] = 5] = "AFTER_HEAD";
        InsertionMode[InsertionMode["IN_BODY"] = 6] = "IN_BODY";
        InsertionMode[InsertionMode["TEXT"] = 7] = "TEXT";
        InsertionMode[InsertionMode["IN_TABLE"] = 8] = "IN_TABLE";
        InsertionMode[InsertionMode["IN_TABLE_TEXT"] = 9] = "IN_TABLE_TEXT";
        InsertionMode[InsertionMode["IN_CAPTION"] = 10] = "IN_CAPTION";
        InsertionMode[InsertionMode["IN_COLUMN_GROUP"] = 11] = "IN_COLUMN_GROUP";
        InsertionMode[InsertionMode["IN_TABLE_BODY"] = 12] = "IN_TABLE_BODY";
        InsertionMode[InsertionMode["IN_ROW"] = 13] = "IN_ROW";
        InsertionMode[InsertionMode["IN_CELL"] = 14] = "IN_CELL";
        InsertionMode[InsertionMode["IN_SELECT"] = 15] = "IN_SELECT";
        InsertionMode[InsertionMode["IN_SELECT_IN_TABLE"] = 16] = "IN_SELECT_IN_TABLE";
        InsertionMode[InsertionMode["IN_TEMPLATE"] = 17] = "IN_TEMPLATE";
        InsertionMode[InsertionMode["AFTER_BODY"] = 18] = "AFTER_BODY";
        InsertionMode[InsertionMode["IN_FRAMESET"] = 19] = "IN_FRAMESET";
        InsertionMode[InsertionMode["AFTER_FRAMESET"] = 20] = "AFTER_FRAMESET";
        InsertionMode[InsertionMode["AFTER_AFTER_BODY"] = 21] = "AFTER_AFTER_BODY";
        InsertionMode[InsertionMode["AFTER_AFTER_FRAMESET"] = 22] = "AFTER_AFTER_FRAMESET";
    })(InsertionMode || (InsertionMode = {}));
    const BASE_LOC = {
        startLine: -1,
        startCol: -1,
        startOffset: -1,
        endLine: -1,
        endCol: -1,
        endOffset: -1,
    };
    const TABLE_STRUCTURE_TAGS = new Set([TAG_ID.TABLE, TAG_ID.TBODY, TAG_ID.TFOOT, TAG_ID.THEAD, TAG_ID.TR]);
    const defaultParserOptions = {
        scriptingEnabled: true,
        sourceCodeLocationInfo: false,
        treeAdapter: defaultTreeAdapter,
        onParseError: null,
    };
    //Parser
    class Parser$1 {
        constructor(options, document, fragmentContext = null, scriptHandler = null) {
            this.fragmentContext = fragmentContext;
            this.scriptHandler = scriptHandler;
            this.currentToken = null;
            this.stopped = false;
            this.insertionMode = InsertionMode.INITIAL;
            this.originalInsertionMode = InsertionMode.INITIAL;
            this.headElement = null;
            this.formElement = null;
            /** Indicates that the current node is not an element in the HTML namespace */
            this.currentNotInHTML = false;
            /**
             * The template insertion mode stack is maintained from the left.
             * Ie. the topmost element will always have index 0.
             */
            this.tmplInsertionModeStack = [];
            this.pendingCharacterTokens = [];
            this.hasNonWhitespacePendingCharacterToken = false;
            this.framesetOk = true;
            this.skipNextNewLine = false;
            this.fosterParentingEnabled = false;
            this.options = {
                ...defaultParserOptions,
                ...options,
            };
            this.treeAdapter = this.options.treeAdapter;
            this.onParseError = this.options.onParseError;
            // Always enable location info if we report parse errors.
            if (this.onParseError) {
                this.options.sourceCodeLocationInfo = true;
            }
            this.document = document !== null && document !== void 0 ? document : this.treeAdapter.createDocument();
            this.tokenizer = new Tokenizer$1(this.options, this);
            this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
            this.fragmentContextID = fragmentContext ? getTagID(this.treeAdapter.getTagName(fragmentContext)) : TAG_ID.UNKNOWN;
            this._setContextModes(fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : this.document, this.fragmentContextID);
            this.openElements = new OpenElementStack(this.document, this.treeAdapter, this);
        }
        // API
        static parse(html, options) {
            const parser = new this(options);
            parser.tokenizer.write(html, true);
            return parser.document;
        }
        static getFragmentParser(fragmentContext, options) {
            const opts = {
                ...defaultParserOptions,
                ...options,
            };
            //NOTE: use a <template> element as the fragment context if no context element was provided,
            //so we will parse in a "forgiving" manner
            fragmentContext !== null && fragmentContext !== void 0 ? fragmentContext : (fragmentContext = opts.treeAdapter.createElement(TAG_NAMES.TEMPLATE, NS.HTML, []));
            //NOTE: create a fake element which will be used as the `document` for fragment parsing.
            //This is important for jsdom, where a new `document` cannot be created. This led to
            //fragment parsing messing with the main `document`.
            const documentMock = opts.treeAdapter.createElement('documentmock', NS.HTML, []);
            const parser = new this(opts, documentMock, fragmentContext);
            if (parser.fragmentContextID === TAG_ID.TEMPLATE) {
                parser.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
            }
            parser._initTokenizerForFragmentParsing();
            parser._insertFakeRootElement();
            parser._resetInsertionMode();
            parser._findFormInFragmentContext();
            return parser;
        }
        getFragment() {
            const rootElement = this.treeAdapter.getFirstChild(this.document);
            const fragment = this.treeAdapter.createDocumentFragment();
            this._adoptNodes(rootElement, fragment);
            return fragment;
        }
        //Errors
        _err(token, code, beforeToken) {
            var _a;
            if (!this.onParseError)
                return;
            const loc = (_a = token.location) !== null && _a !== void 0 ? _a : BASE_LOC;
            const err = {
                code,
                startLine: loc.startLine,
                startCol: loc.startCol,
                startOffset: loc.startOffset,
                endLine: beforeToken ? loc.startLine : loc.endLine,
                endCol: beforeToken ? loc.startCol : loc.endCol,
                endOffset: beforeToken ? loc.startOffset : loc.endOffset,
            };
            this.onParseError(err);
        }
        //Stack events
        onItemPush(node, tid, isTop) {
            var _a, _b;
            (_b = (_a = this.treeAdapter).onItemPush) === null || _b === void 0 ? void 0 : _b.call(_a, node);
            if (isTop && this.openElements.stackTop > 0)
                this._setContextModes(node, tid);
        }
        onItemPop(node, isTop) {
            var _a, _b;
            if (this.options.sourceCodeLocationInfo) {
                this._setEndLocation(node, this.currentToken);
            }
            (_b = (_a = this.treeAdapter).onItemPop) === null || _b === void 0 ? void 0 : _b.call(_a, node, this.openElements.current);
            if (isTop) {
                let current;
                let currentTagId;
                if (this.openElements.stackTop === 0 && this.fragmentContext) {
                    current = this.fragmentContext;
                    currentTagId = this.fragmentContextID;
                }
                else {
                    ({ current, currentTagId } = this.openElements);
                }
                this._setContextModes(current, currentTagId);
            }
        }
        _setContextModes(current, tid) {
            const isHTML = current === this.document || this.treeAdapter.getNamespaceURI(current) === NS.HTML;
            this.currentNotInHTML = !isHTML;
            this.tokenizer.inForeignNode = !isHTML && !this._isIntegrationPoint(tid, current);
        }
        _switchToTextParsing(currentToken, nextTokenizerState) {
            this._insertElement(currentToken, NS.HTML);
            this.tokenizer.state = nextTokenizerState;
            this.originalInsertionMode = this.insertionMode;
            this.insertionMode = InsertionMode.TEXT;
        }
        switchToPlaintextParsing() {
            this.insertionMode = InsertionMode.TEXT;
            this.originalInsertionMode = InsertionMode.IN_BODY;
            this.tokenizer.state = TokenizerMode.PLAINTEXT;
        }
        //Fragment parsing
        _getAdjustedCurrentElement() {
            return this.openElements.stackTop === 0 && this.fragmentContext
                ? this.fragmentContext
                : this.openElements.current;
        }
        _findFormInFragmentContext() {
            let node = this.fragmentContext;
            while (node) {
                if (this.treeAdapter.getTagName(node) === TAG_NAMES.FORM) {
                    this.formElement = node;
                    break;
                }
                node = this.treeAdapter.getParentNode(node);
            }
        }
        _initTokenizerForFragmentParsing() {
            if (!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== NS.HTML) {
                return;
            }
            switch (this.fragmentContextID) {
                case TAG_ID.TITLE:
                case TAG_ID.TEXTAREA: {
                    this.tokenizer.state = TokenizerMode.RCDATA;
                    break;
                }
                case TAG_ID.STYLE:
                case TAG_ID.XMP:
                case TAG_ID.IFRAME:
                case TAG_ID.NOEMBED:
                case TAG_ID.NOFRAMES:
                case TAG_ID.NOSCRIPT: {
                    this.tokenizer.state = TokenizerMode.RAWTEXT;
                    break;
                }
                case TAG_ID.SCRIPT: {
                    this.tokenizer.state = TokenizerMode.SCRIPT_DATA;
                    break;
                }
                case TAG_ID.PLAINTEXT: {
                    this.tokenizer.state = TokenizerMode.PLAINTEXT;
                    break;
                }
                // Do nothing
            }
        }
        //Tree mutation
        _setDocumentType(token) {
            const name = token.name || '';
            const publicId = token.publicId || '';
            const systemId = token.systemId || '';
            this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
            if (token.location) {
                const documentChildren = this.treeAdapter.getChildNodes(this.document);
                const docTypeNode = documentChildren.find((node) => this.treeAdapter.isDocumentTypeNode(node));
                if (docTypeNode) {
                    this.treeAdapter.setNodeSourceCodeLocation(docTypeNode, token.location);
                }
            }
        }
        _attachElementToTree(element, location) {
            if (this.options.sourceCodeLocationInfo) {
                const loc = location && {
                    ...location,
                    startTag: location,
                };
                this.treeAdapter.setNodeSourceCodeLocation(element, loc);
            }
            if (this._shouldFosterParentOnInsertion()) {
                this._fosterParentElement(element);
            }
            else {
                const parent = this.openElements.currentTmplContentOrNode;
                this.treeAdapter.appendChild(parent, element);
            }
        }
        _appendElement(token, namespaceURI) {
            const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
            this._attachElementToTree(element, token.location);
        }
        _insertElement(token, namespaceURI) {
            const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
            this._attachElementToTree(element, token.location);
            this.openElements.push(element, token.tagID);
        }
        _insertFakeElement(tagName, tagID) {
            const element = this.treeAdapter.createElement(tagName, NS.HTML, []);
            this._attachElementToTree(element, null);
            this.openElements.push(element, tagID);
        }
        _insertTemplate(token) {
            const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
            const content = this.treeAdapter.createDocumentFragment();
            this.treeAdapter.setTemplateContent(tmpl, content);
            this._attachElementToTree(tmpl, token.location);
            this.openElements.push(tmpl, token.tagID);
            if (this.options.sourceCodeLocationInfo)
                this.treeAdapter.setNodeSourceCodeLocation(content, null);
        }
        _insertFakeRootElement() {
            const element = this.treeAdapter.createElement(TAG_NAMES.HTML, NS.HTML, []);
            if (this.options.sourceCodeLocationInfo)
                this.treeAdapter.setNodeSourceCodeLocation(element, null);
            this.treeAdapter.appendChild(this.openElements.current, element);
            this.openElements.push(element, TAG_ID.HTML);
        }
        _appendCommentNode(token, parent) {
            const commentNode = this.treeAdapter.createCommentNode(token.data);
            this.treeAdapter.appendChild(parent, commentNode);
            if (this.options.sourceCodeLocationInfo) {
                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
            }
        }
        _insertCharacters(token) {
            let parent;
            let beforeElement;
            if (this._shouldFosterParentOnInsertion()) {
                ({ parent, beforeElement } = this._findFosterParentingLocation());
                if (beforeElement) {
                    this.treeAdapter.insertTextBefore(parent, token.chars, beforeElement);
                }
                else {
                    this.treeAdapter.insertText(parent, token.chars);
                }
            }
            else {
                parent = this.openElements.currentTmplContentOrNode;
                this.treeAdapter.insertText(parent, token.chars);
            }
            if (!token.location)
                return;
            const siblings = this.treeAdapter.getChildNodes(parent);
            const textNodeIdx = beforeElement ? siblings.lastIndexOf(beforeElement) : siblings.length;
            const textNode = siblings[textNodeIdx - 1];
            //NOTE: if we have a location assigned by another token, then just update the end position
            const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
            if (tnLoc) {
                const { endLine, endCol, endOffset } = token.location;
                this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });
            }
            else if (this.options.sourceCodeLocationInfo) {
                this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
            }
        }
        _adoptNodes(donor, recipient) {
            for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {
                this.treeAdapter.detachNode(child);
                this.treeAdapter.appendChild(recipient, child);
            }
        }
        _setEndLocation(element, closingToken) {
            if (this.treeAdapter.getNodeSourceCodeLocation(element) && closingToken.location) {
                const ctLoc = closingToken.location;
                const tn = this.treeAdapter.getTagName(element);
                const endLoc = 
                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
                closingToken.type === TokenType.END_TAG && tn === closingToken.tagName
                    ? {
                        endTag: { ...ctLoc },
                        endLine: ctLoc.endLine,
                        endCol: ctLoc.endCol,
                        endOffset: ctLoc.endOffset,
                    }
                    : {
                        endLine: ctLoc.startLine,
                        endCol: ctLoc.startCol,
                        endOffset: ctLoc.startOffset,
                    };
                this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
            }
        }
        //Token processing
        shouldProcessStartTagTokenInForeignContent(token) {
            // Check that neither current === document, or ns === NS.HTML
            if (!this.currentNotInHTML)
                return false;
            let current;
            let currentTagId;
            if (this.openElements.stackTop === 0 && this.fragmentContext) {
                current = this.fragmentContext;
                currentTagId = this.fragmentContextID;
            }
            else {
                ({ current, currentTagId } = this.openElements);
            }
            if (token.tagID === TAG_ID.SVG &&
                this.treeAdapter.getTagName(current) === TAG_NAMES.ANNOTATION_XML &&
                this.treeAdapter.getNamespaceURI(current) === NS.MATHML) {
                return false;
            }
            return (
            // Check that `current` is not an integration point for HTML or MathML elements.
            this.tokenizer.inForeignNode ||
                // If it _is_ an integration point, then we might have to check that it is not an HTML
                // integration point.
                ((token.tagID === TAG_ID.MGLYPH || token.tagID === TAG_ID.MALIGNMARK) &&
                    !this._isIntegrationPoint(currentTagId, current, NS.HTML)));
        }
        _processToken(token) {
            switch (token.type) {
                case TokenType.CHARACTER: {
                    this.onCharacter(token);
                    break;
                }
                case TokenType.NULL_CHARACTER: {
                    this.onNullCharacter(token);
                    break;
                }
                case TokenType.COMMENT: {
                    this.onComment(token);
                    break;
                }
                case TokenType.DOCTYPE: {
                    this.onDoctype(token);
                    break;
                }
                case TokenType.START_TAG: {
                    this._processStartTag(token);
                    break;
                }
                case TokenType.END_TAG: {
                    this.onEndTag(token);
                    break;
                }
                case TokenType.EOF: {
                    this.onEof(token);
                    break;
                }
                case TokenType.WHITESPACE_CHARACTER: {
                    this.onWhitespaceCharacter(token);
                    break;
                }
            }
        }
        //Integration points
        _isIntegrationPoint(tid, element, foreignNS) {
            const ns = this.treeAdapter.getNamespaceURI(element);
            const attrs = this.treeAdapter.getAttrList(element);
            return isIntegrationPoint(tid, ns, attrs, foreignNS);
        }
        //Active formatting elements reconstruction
        _reconstructActiveFormattingElements() {
            const listLength = this.activeFormattingElements.entries.length;
            if (listLength) {
                const endIndex = this.activeFormattingElements.entries.findIndex((entry) => entry.type === EntryType.Marker || this.openElements.contains(entry.element));
                const unopenIdx = endIndex < 0 ? listLength - 1 : endIndex - 1;
                for (let i = unopenIdx; i >= 0; i--) {
                    const entry = this.activeFormattingElements.entries[i];
                    this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));
                    entry.element = this.openElements.current;
                }
            }
        }
        //Close elements
        _closeTableCell() {
            this.openElements.generateImpliedEndTags();
            this.openElements.popUntilTableCellPopped();
            this.activeFormattingElements.clearToLastMarker();
            this.insertionMode = InsertionMode.IN_ROW;
        }
        _closePElement() {
            this.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.P);
            this.openElements.popUntilTagNamePopped(TAG_ID.P);
        }
        //Insertion modes
        _resetInsertionMode() {
            for (let i = this.openElements.stackTop; i >= 0; i--) {
                //Insertion mode reset map
                switch (i === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[i]) {
                    case TAG_ID.TR: {
                        this.insertionMode = InsertionMode.IN_ROW;
                        return;
                    }
                    case TAG_ID.TBODY:
                    case TAG_ID.THEAD:
                    case TAG_ID.TFOOT: {
                        this.insertionMode = InsertionMode.IN_TABLE_BODY;
                        return;
                    }
                    case TAG_ID.CAPTION: {
                        this.insertionMode = InsertionMode.IN_CAPTION;
                        return;
                    }
                    case TAG_ID.COLGROUP: {
                        this.insertionMode = InsertionMode.IN_COLUMN_GROUP;
                        return;
                    }
                    case TAG_ID.TABLE: {
                        this.insertionMode = InsertionMode.IN_TABLE;
                        return;
                    }
                    case TAG_ID.BODY: {
                        this.insertionMode = InsertionMode.IN_BODY;
                        return;
                    }
                    case TAG_ID.FRAMESET: {
                        this.insertionMode = InsertionMode.IN_FRAMESET;
                        return;
                    }
                    case TAG_ID.SELECT: {
                        this._resetInsertionModeForSelect(i);
                        return;
                    }
                    case TAG_ID.TEMPLATE: {
                        this.insertionMode = this.tmplInsertionModeStack[0];
                        return;
                    }
                    case TAG_ID.HTML: {
                        this.insertionMode = this.headElement ? InsertionMode.AFTER_HEAD : InsertionMode.BEFORE_HEAD;
                        return;
                    }
                    case TAG_ID.TD:
                    case TAG_ID.TH: {
                        if (i > 0) {
                            this.insertionMode = InsertionMode.IN_CELL;
                            return;
                        }
                        break;
                    }
                    case TAG_ID.HEAD: {
                        if (i > 0) {
                            this.insertionMode = InsertionMode.IN_HEAD;
                            return;
                        }
                        break;
                    }
                }
            }
            this.insertionMode = InsertionMode.IN_BODY;
        }
        _resetInsertionModeForSelect(selectIdx) {
            if (selectIdx > 0) {
                for (let i = selectIdx - 1; i > 0; i--) {
                    const tn = this.openElements.tagIDs[i];
                    if (tn === TAG_ID.TEMPLATE) {
                        break;
                    }
                    else if (tn === TAG_ID.TABLE) {
                        this.insertionMode = InsertionMode.IN_SELECT_IN_TABLE;
                        return;
                    }
                }
            }
            this.insertionMode = InsertionMode.IN_SELECT;
        }
        //Foster parenting
        _isElementCausesFosterParenting(tn) {
            return TABLE_STRUCTURE_TAGS.has(tn);
        }
        _shouldFosterParentOnInsertion() {
            return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
        }
        _findFosterParentingLocation() {
            for (let i = this.openElements.stackTop; i >= 0; i--) {
                const openElement = this.openElements.items[i];
                switch (this.openElements.tagIDs[i]) {
                    case TAG_ID.TEMPLATE: {
                        if (this.treeAdapter.getNamespaceURI(openElement) === NS.HTML) {
                            return { parent: this.treeAdapter.getTemplateContent(openElement), beforeElement: null };
                        }
                        break;
                    }
                    case TAG_ID.TABLE: {
                        const parent = this.treeAdapter.getParentNode(openElement);
                        if (parent) {
                            return { parent, beforeElement: openElement };
                        }
                        return { parent: this.openElements.items[i - 1], beforeElement: null };
                    }
                    // Do nothing
                }
            }
            return { parent: this.openElements.items[0], beforeElement: null };
        }
        _fosterParentElement(element) {
            const location = this._findFosterParentingLocation();
            if (location.beforeElement) {
                this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);
            }
            else {
                this.treeAdapter.appendChild(location.parent, element);
            }
        }
        //Special elements
        _isSpecialElement(element, id) {
            const ns = this.treeAdapter.getNamespaceURI(element);
            return SPECIAL_ELEMENTS[ns].has(id);
        }
        onCharacter(token) {
            this.skipNextNewLine = false;
            if (this.tokenizer.inForeignNode) {
                characterInForeignContent(this, token);
                return;
            }
            switch (this.insertionMode) {
                case InsertionMode.INITIAL: {
                    tokenInInitialMode(this, token);
                    break;
                }
                case InsertionMode.BEFORE_HTML: {
                    tokenBeforeHtml(this, token);
                    break;
                }
                case InsertionMode.BEFORE_HEAD: {
                    tokenBeforeHead(this, token);
                    break;
                }
                case InsertionMode.IN_HEAD: {
                    tokenInHead(this, token);
                    break;
                }
                case InsertionMode.IN_HEAD_NO_SCRIPT: {
                    tokenInHeadNoScript(this, token);
                    break;
                }
                case InsertionMode.AFTER_HEAD: {
                    tokenAfterHead(this, token);
                    break;
                }
                case InsertionMode.IN_BODY:
                case InsertionMode.IN_CAPTION:
                case InsertionMode.IN_CELL:
                case InsertionMode.IN_TEMPLATE: {
                    characterInBody(this, token);
                    break;
                }
                case InsertionMode.TEXT:
                case InsertionMode.IN_SELECT:
                case InsertionMode.IN_SELECT_IN_TABLE: {
                    this._insertCharacters(token);
                    break;
                }
                case InsertionMode.IN_TABLE:
                case InsertionMode.IN_TABLE_BODY:
                case InsertionMode.IN_ROW: {
                    characterInTable(this, token);
                    break;
                }
                case InsertionMode.IN_TABLE_TEXT: {
                    characterInTableText(this, token);
                    break;
                }
                case InsertionMode.IN_COLUMN_GROUP: {
                    tokenInColumnGroup(this, token);
                    break;
                }
                case InsertionMode.AFTER_BODY: {
                    tokenAfterBody(this, token);
                    break;
                }
                case InsertionMode.AFTER_AFTER_BODY: {
                    tokenAfterAfterBody(this, token);
                    break;
                }
                // Do nothing
            }
        }
        onNullCharacter(token) {
            this.skipNextNewLine = false;
            if (this.tokenizer.inForeignNode) {
                nullCharacterInForeignContent(this, token);
                return;
            }
            switch (this.insertionMode) {
                case InsertionMode.INITIAL: {
                    tokenInInitialMode(this, token);
                    break;
                }
                case InsertionMode.BEFORE_HTML: {
                    tokenBeforeHtml(this, token);
                    break;
                }
                case InsertionMode.BEFORE_HEAD: {
                    tokenBeforeHead(this, token);
                    break;
                }
                case InsertionMode.IN_HEAD: {
                    tokenInHead(this, token);
                    break;
                }
                case InsertionMode.IN_HEAD_NO_SCRIPT: {
                    tokenInHeadNoScript(this, token);
                    break;
                }
                case InsertionMode.AFTER_HEAD: {
                    tokenAfterHead(this, token);
                    break;
                }
                case InsertionMode.TEXT: {
                    this._insertCharacters(token);
                    break;
                }
                case InsertionMode.IN_TABLE:
                case InsertionMode.IN_TABLE_BODY:
                case InsertionMode.IN_ROW: {
                    characterInTable(this, token);
                    break;
                }
                case InsertionMode.IN_COLUMN_GROUP: {
                    tokenInColumnGroup(this, token);
                    break;
                }
                case InsertionMode.AFTER_BODY: {
                    tokenAfterBody(this, token);
                    break;
                }
                case InsertionMode.AFTER_AFTER_BODY: {
                    tokenAfterAfterBody(this, token);
                    break;
                }
                // Do nothing
            }
        }
        onComment(token) {
            this.skipNextNewLine = false;
            if (this.currentNotInHTML) {
                appendComment(this, token);
                return;
            }
            switch (this.insertionMode) {
                case InsertionMode.INITIAL:
                case InsertionMode.BEFORE_HTML:
                case InsertionMode.BEFORE_HEAD:
                case InsertionMode.IN_HEAD:
                case InsertionMode.IN_HEAD_NO_SCRIPT:
                case InsertionMode.AFTER_HEAD:
                case InsertionMode.IN_BODY:
                case InsertionMode.IN_TABLE:
                case InsertionMode.IN_CAPTION:
                case InsertionMode.IN_COLUMN_GROUP:
                case InsertionMode.IN_TABLE_BODY:
                case InsertionMode.IN_ROW:
                case InsertionMode.IN_CELL:
                case InsertionMode.IN_SELECT:
                case InsertionMode.IN_SELECT_IN_TABLE:
                case InsertionMode.IN_TEMPLATE:
                case InsertionMode.IN_FRAMESET:
                case InsertionMode.AFTER_FRAMESET: {
                    appendComment(this, token);
                    break;
                }
                case InsertionMode.IN_TABLE_TEXT: {
                    tokenInTableText(this, token);
                    break;
                }
                case InsertionMode.AFTER_BODY: {
                    appendCommentToRootHtmlElement(this, token);
                    break;
                }
                case InsertionMode.AFTER_AFTER_BODY:
                case InsertionMode.AFTER_AFTER_FRAMESET: {
                    appendCommentToDocument(this, token);
                    break;
                }
                // Do nothing
            }
        }
        onDoctype(token) {
            this.skipNextNewLine = false;
            switch (this.insertionMode) {
                case InsertionMode.INITIAL: {
                    doctypeInInitialMode(this, token);
                    break;
                }
                case InsertionMode.BEFORE_HEAD:
                case InsertionMode.IN_HEAD:
                case InsertionMode.IN_HEAD_NO_SCRIPT:
                case InsertionMode.AFTER_HEAD: {
                    this._err(token, ERR.misplacedDoctype);
                    break;
                }
                case InsertionMode.IN_TABLE_TEXT: {
                    tokenInTableText(this, token);
                    break;
                }
                // Do nothing
            }
        }
        onStartTag(token) {
            this.skipNextNewLine = false;
            this.currentToken = token;
            this._processStartTag(token);
            if (token.selfClosing && !token.ackSelfClosing) {
                this._err(token, ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
            }
        }
        /**
         * Processes a given start tag.
         *
         * `onStartTag` checks if a self-closing tag was recognized. When a token
         * is moved inbetween multiple insertion modes, this check for self-closing
         * could lead to false positives. To avoid this, `_processStartTag` is used
         * for nested calls.
         *
         * @param token The token to process.
         */
        _processStartTag(token) {
            if (this.shouldProcessStartTagTokenInForeignContent(token)) {
                startTagInForeignContent(this, token);
            }
            else {
                this._startTagOutsideForeignContent(token);
            }
        }
        _startTagOutsideForeignContent(token) {
            switch (this.insertionMode) {
                case InsertionMode.INITIAL: {
                    tokenInInitialMode(this, token);
                    break;
                }
                case InsertionMode.BEFORE_HTML: {
                    startTagBeforeHtml(this, token);
                    break;
                }
                case InsertionMode.BEFORE_HEAD: {
                    startTagBeforeHead(this, token);
                    break;
                }
                case InsertionMode.IN_HEAD: {
                    startTagInHead(this, token);
                    break;
                }
                case InsertionMode.IN_HEAD_NO_SCRIPT: {
                    startTagInHeadNoScript(this, token);
                    break;
                }
                case InsertionMode.AFTER_HEAD: {
                    startTagAfterHead(this, token);
                    break;
                }
                case InsertionMode.IN_BODY: {
                    startTagInBody(this, token);
                    break;
                }
                case InsertionMode.IN_TABLE: {
                    startTagInTable(this, token);
                    break;
                }
                case InsertionMode.IN_TABLE_TEXT: {
                    tokenInTableText(this, token);
                    break;
                }
                case InsertionMode.IN_CAPTION: {
                    startTagInCaption(this, token);
                    break;
                }
                case InsertionMode.IN_COLUMN_GROUP: {
                    startTagInColumnGroup(this, token);
                    break;
                }
                case InsertionMode.IN_TABLE_BODY: {
                    startTagInTableBody(this, token);
                    break;
                }
                case InsertionMode.IN_ROW: {
                    startTagInRow(this, token);
                    break;
                }
                case InsertionMode.IN_CELL: {
                    startTagInCell(this, token);
                    break;
                }
                case InsertionMode.IN_SELECT: {
                    startTagInSelect(this, token);
                    break;
                }
                case InsertionMode.IN_SELECT_IN_TABLE: {
                    startTagInSelectInTable(this, token);
                    break;
                }
                case InsertionMode.IN_TEMPLATE: {
                    startTagInTemplate(this, token);
                    break;
                }
                case InsertionMode.AFTER_BODY: {
                    startTagAfterBody(this, token);
                    break;
                }
                case InsertionMode.IN_FRAMESET: {
                    startTagInFrameset(this, token);
                    break;
                }
                case InsertionMode.AFTER_FRAMESET: {
                    startTagAfterFrameset(this, token);
                    break;
                }
                case InsertionMode.AFTER_AFTER_BODY: {
                    startTagAfterAfterBody(this, token);
                    break;
                }
                case InsertionMode.AFTER_AFTER_FRAMESET: {
                    startTagAfterAfterFrameset(this, token);
                    break;
                }
                // Do nothing
            }
        }
        onEndTag(token) {
            this.skipNextNewLine = false;
            this.currentToken = token;
            if (this.currentNotInHTML) {
                endTagInForeignContent(this, token);
            }
            else {
                this._endTagOutsideForeignContent(token);
            }
        }
        _endTagOutsideForeignContent(token) {
            switch (this.insertionMode) {
                case InsertionMode.INITIAL: {
                    tokenInInitialMode(this, token);
                    break;
                }
                case InsertionMode.BEFORE_HTML: {
                    endTagBeforeHtml(this, token);
                    break;
                }
                case InsertionMode.BEFORE_HEAD: {
                    endTagBeforeHead(this, token);
                    break;
                }
                case InsertionMode.IN_HEAD: {
                    endTagInHead(this, token);
                    break;
                }
                case InsertionMode.IN_HEAD_NO_SCRIPT: {
                    endTagInHeadNoScript(this, token);
                    break;
                }
                case InsertionMode.AFTER_HEAD: {
                    endTagAfterHead(this, token);
                    break;
                }
                case InsertionMode.IN_BODY: {
                    endTagInBody(this, token);
                    break;
                }
                case InsertionMode.TEXT: {
                    endTagInText(this, token);
                    break;
                }
                case InsertionMode.IN_TABLE: {
                    endTagInTable(this, token);
                    break;
                }
                case InsertionMode.IN_TABLE_TEXT: {
                    tokenInTableText(this, token);
                    break;
                }
                case InsertionMode.IN_CAPTION: {
                    endTagInCaption(this, token);
                    break;
                }
                case InsertionMode.IN_COLUMN_GROUP: {
                    endTagInColumnGroup(this, token);
                    break;
                }
                case InsertionMode.IN_TABLE_BODY: {
                    endTagInTableBody(this, token);
                    break;
                }
                case InsertionMode.IN_ROW: {
                    endTagInRow(this, token);
                    break;
                }
                case InsertionMode.IN_CELL: {
                    endTagInCell(this, token);
                    break;
                }
                case InsertionMode.IN_SELECT: {
                    endTagInSelect(this, token);
                    break;
                }
                case InsertionMode.IN_SELECT_IN_TABLE: {
                    endTagInSelectInTable(this, token);
                    break;
                }
                case InsertionMode.IN_TEMPLATE: {
                    endTagInTemplate(this, token);
                    break;
                }
                case InsertionMode.AFTER_BODY: {
                    endTagAfterBody(this, token);
                    break;
                }
                case InsertionMode.IN_FRAMESET: {
                    endTagInFrameset(this, token);
                    break;
                }
                case InsertionMode.AFTER_FRAMESET: {
                    endTagAfterFrameset(this, token);
                    break;
                }
                case InsertionMode.AFTER_AFTER_BODY: {
                    tokenAfterAfterBody(this, token);
                    break;
                }
                // Do nothing
            }
        }
        onEof(token) {
            switch (this.insertionMode) {
                case InsertionMode.INITIAL: {
                    tokenInInitialMode(this, token);
                    break;
                }
                case InsertionMode.BEFORE_HTML: {
                    tokenBeforeHtml(this, token);
                    break;
                }
                case InsertionMode.BEFORE_HEAD: {
                    tokenBeforeHead(this, token);
                    break;
                }
                case InsertionMode.IN_HEAD: {
                    tokenInHead(this, token);
                    break;
                }
                case InsertionMode.IN_HEAD_NO_SCRIPT: {
                    tokenInHeadNoScript(this, token);
                    break;
                }
                case InsertionMode.AFTER_HEAD: {
                    tokenAfterHead(this, token);
                    break;
                }
                case InsertionMode.IN_BODY:
                case InsertionMode.IN_TABLE:
                case InsertionMode.IN_CAPTION:
                case InsertionMode.IN_COLUMN_GROUP:
                case InsertionMode.IN_TABLE_BODY:
                case InsertionMode.IN_ROW:
                case InsertionMode.IN_CELL:
                case InsertionMode.IN_SELECT:
                case InsertionMode.IN_SELECT_IN_TABLE: {
                    eofInBody(this, token);
                    break;
                }
                case InsertionMode.TEXT: {
                    eofInText(this, token);
                    break;
                }
                case InsertionMode.IN_TABLE_TEXT: {
                    tokenInTableText(this, token);
                    break;
                }
                case InsertionMode.IN_TEMPLATE: {
                    eofInTemplate(this, token);
                    break;
                }
                case InsertionMode.AFTER_BODY:
                case InsertionMode.IN_FRAMESET:
                case InsertionMode.AFTER_FRAMESET:
                case InsertionMode.AFTER_AFTER_BODY:
                case InsertionMode.AFTER_AFTER_FRAMESET: {
                    stopParsing(this, token);
                    break;
                }
                // Do nothing
            }
        }
        onWhitespaceCharacter(token) {
            if (this.skipNextNewLine) {
                this.skipNextNewLine = false;
                if (token.chars.charCodeAt(0) === CODE_POINTS.LINE_FEED) {
                    if (token.chars.length === 1) {
                        return;
                    }
                    token.chars = token.chars.substr(1);
                }
            }
            if (this.tokenizer.inForeignNode) {
                this._insertCharacters(token);
                return;
            }
            switch (this.insertionMode) {
                case InsertionMode.IN_HEAD:
                case InsertionMode.IN_HEAD_NO_SCRIPT:
                case InsertionMode.AFTER_HEAD:
                case InsertionMode.TEXT:
                case InsertionMode.IN_COLUMN_GROUP:
                case InsertionMode.IN_SELECT:
                case InsertionMode.IN_SELECT_IN_TABLE:
                case InsertionMode.IN_FRAMESET:
                case InsertionMode.AFTER_FRAMESET: {
                    this._insertCharacters(token);
                    break;
                }
                case InsertionMode.IN_BODY:
                case InsertionMode.IN_CAPTION:
                case InsertionMode.IN_CELL:
                case InsertionMode.IN_TEMPLATE:
                case InsertionMode.AFTER_BODY:
                case InsertionMode.AFTER_AFTER_BODY:
                case InsertionMode.AFTER_AFTER_FRAMESET: {
                    whitespaceCharacterInBody(this, token);
                    break;
                }
                case InsertionMode.IN_TABLE:
                case InsertionMode.IN_TABLE_BODY:
                case InsertionMode.IN_ROW: {
                    characterInTable(this, token);
                    break;
                }
                case InsertionMode.IN_TABLE_TEXT: {
                    whitespaceCharacterInTableText(this, token);
                    break;
                }
                // Do nothing
            }
        }
    }
    //Adoption agency algorithm
    //(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)
    //------------------------------------------------------------------
    //Steps 5-8 of the algorithm
    function aaObtainFormattingElementEntry(p, token) {
        let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);
        if (formattingElementEntry) {
            if (!p.openElements.contains(formattingElementEntry.element)) {
                p.activeFormattingElements.removeEntry(formattingElementEntry);
                formattingElementEntry = null;
            }
            else if (!p.openElements.hasInScope(token.tagID)) {
                formattingElementEntry = null;
            }
        }
        else {
            genericEndTagInBody(p, token);
        }
        return formattingElementEntry;
    }
    //Steps 9 and 10 of the algorithm
    function aaObtainFurthestBlock(p, formattingElementEntry) {
        let furthestBlock = null;
        let idx = p.openElements.stackTop;
        for (; idx >= 0; idx--) {
            const element = p.openElements.items[idx];
            if (element === formattingElementEntry.element) {
                break;
            }
            if (p._isSpecialElement(element, p.openElements.tagIDs[idx])) {
                furthestBlock = element;
            }
        }
        if (!furthestBlock) {
            p.openElements.shortenToLength(idx < 0 ? 0 : idx);
            p.activeFormattingElements.removeEntry(formattingElementEntry);
        }
        return furthestBlock;
    }
    //Step 13 of the algorithm
    function aaInnerLoop(p, furthestBlock, formattingElement) {
        let lastElement = furthestBlock;
        let nextElement = p.openElements.getCommonAncestor(furthestBlock);
        for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {
            //NOTE: store the next element for the next loop iteration (it may be deleted from the stack by step 9.5)
            nextElement = p.openElements.getCommonAncestor(element);
            const elementEntry = p.activeFormattingElements.getElementEntry(element);
            const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;
            const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
            if (shouldRemoveFromOpenElements) {
                if (counterOverflow) {
                    p.activeFormattingElements.removeEntry(elementEntry);
                }
                p.openElements.remove(element);
            }
            else {
                element = aaRecreateElementFromEntry(p, elementEntry);
                if (lastElement === furthestBlock) {
                    p.activeFormattingElements.bookmark = elementEntry;
                }
                p.treeAdapter.detachNode(lastElement);
                p.treeAdapter.appendChild(element, lastElement);
                lastElement = element;
            }
        }
        return lastElement;
    }
    //Step 13.7 of the algorithm
    function aaRecreateElementFromEntry(p, elementEntry) {
        const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);
        const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);
        p.openElements.replace(elementEntry.element, newElement);
        elementEntry.element = newElement;
        return newElement;
    }
    //Step 14 of the algorithm
    function aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {
        const tn = p.treeAdapter.getTagName(commonAncestor);
        const tid = getTagID(tn);
        if (p._isElementCausesFosterParenting(tid)) {
            p._fosterParentElement(lastElement);
        }
        else {
            const ns = p.treeAdapter.getNamespaceURI(commonAncestor);
            if (tid === TAG_ID.TEMPLATE && ns === NS.HTML) {
                commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);
            }
            p.treeAdapter.appendChild(commonAncestor, lastElement);
        }
    }
    //Steps 15-19 of the algorithm
    function aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {
        const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);
        const { token } = formattingElementEntry;
        const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);
        p._adoptNodes(furthestBlock, newElement);
        p.treeAdapter.appendChild(furthestBlock, newElement);
        p.activeFormattingElements.insertElementAfterBookmark(newElement, token);
        p.activeFormattingElements.removeEntry(formattingElementEntry);
        p.openElements.remove(formattingElementEntry.element);
        p.openElements.insertAfter(furthestBlock, newElement, token.tagID);
    }
    //Algorithm entry point
    function callAdoptionAgency(p, token) {
        for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {
            const formattingElementEntry = aaObtainFormattingElementEntry(p, token);
            if (!formattingElementEntry) {
                break;
            }
            const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);
            if (!furthestBlock) {
                break;
            }
            p.activeFormattingElements.bookmark = formattingElementEntry;
            const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);
            const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);
            p.treeAdapter.detachNode(lastElement);
            if (commonAncestor)
                aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);
            aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);
        }
    }
    //Generic token handlers
    //------------------------------------------------------------------
    function appendComment(p, token) {
        p._appendCommentNode(token, p.openElements.currentTmplContentOrNode);
    }
    function appendCommentToRootHtmlElement(p, token) {
        p._appendCommentNode(token, p.openElements.items[0]);
    }
    function appendCommentToDocument(p, token) {
        p._appendCommentNode(token, p.document);
    }
    function stopParsing(p, token) {
        p.stopped = true;
        // NOTE: Set end locations for elements that remain on the open element stack.
        if (token.location) {
            // NOTE: If we are not in a fragment, `html` and `body` will stay on the stack.
            // This is a problem, as we might overwrite their end position here.
            const target = p.fragmentContext ? 0 : 2;
            for (let i = p.openElements.stackTop; i >= target; i--) {
                p._setEndLocation(p.openElements.items[i], token);
            }
            // Handle `html` and `body`
            if (!p.fragmentContext && p.openElements.stackTop >= 0) {
                const htmlElement = p.openElements.items[0];
                const htmlLocation = p.treeAdapter.getNodeSourceCodeLocation(htmlElement);
                if (htmlLocation && !htmlLocation.endTag) {
                    p._setEndLocation(htmlElement, token);
                    if (p.openElements.stackTop >= 1) {
                        const bodyElement = p.openElements.items[1];
                        const bodyLocation = p.treeAdapter.getNodeSourceCodeLocation(bodyElement);
                        if (bodyLocation && !bodyLocation.endTag) {
                            p._setEndLocation(bodyElement, token);
                        }
                    }
                }
            }
        }
    }
    // The "initial" insertion mode
    //------------------------------------------------------------------
    function doctypeInInitialMode(p, token) {
        p._setDocumentType(token);
        const mode = token.forceQuirks ? DOCUMENT_MODE.QUIRKS : getDocumentMode(token);
        if (!isConforming(token)) {
            p._err(token, ERR.nonConformingDoctype);
        }
        p.treeAdapter.setDocumentMode(p.document, mode);
        p.insertionMode = InsertionMode.BEFORE_HTML;
    }
    function tokenInInitialMode(p, token) {
        p._err(token, ERR.missingDoctype, true);
        p.treeAdapter.setDocumentMode(p.document, DOCUMENT_MODE.QUIRKS);
        p.insertionMode = InsertionMode.BEFORE_HTML;
        p._processToken(token);
    }
    // The "before html" insertion mode
    //------------------------------------------------------------------
    function startTagBeforeHtml(p, token) {
        if (token.tagID === TAG_ID.HTML) {
            p._insertElement(token, NS.HTML);
            p.insertionMode = InsertionMode.BEFORE_HEAD;
        }
        else {
            tokenBeforeHtml(p, token);
        }
    }
    function endTagBeforeHtml(p, token) {
        const tn = token.tagID;
        if (tn === TAG_ID.HTML || tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.BR) {
            tokenBeforeHtml(p, token);
        }
    }
    function tokenBeforeHtml(p, token) {
        p._insertFakeRootElement();
        p.insertionMode = InsertionMode.BEFORE_HEAD;
        p._processToken(token);
    }
    // The "before head" insertion mode
    //------------------------------------------------------------------
    function startTagBeforeHead(p, token) {
        switch (token.tagID) {
            case TAG_ID.HTML: {
                startTagInBody(p, token);
                break;
            }
            case TAG_ID.HEAD: {
                p._insertElement(token, NS.HTML);
                p.headElement = p.openElements.current;
                p.insertionMode = InsertionMode.IN_HEAD;
                break;
            }
            default: {
                tokenBeforeHead(p, token);
            }
        }
    }
    function endTagBeforeHead(p, token) {
        const tn = token.tagID;
        if (tn === TAG_ID.HEAD || tn === TAG_ID.BODY || tn === TAG_ID.HTML || tn === TAG_ID.BR) {
            tokenBeforeHead(p, token);
        }
        else {
            p._err(token, ERR.endTagWithoutMatchingOpenElement);
        }
    }
    function tokenBeforeHead(p, token) {
        p._insertFakeElement(TAG_NAMES.HEAD, TAG_ID.HEAD);
        p.headElement = p.openElements.current;
        p.insertionMode = InsertionMode.IN_HEAD;
        p._processToken(token);
    }
    // The "in head" insertion mode
    //------------------------------------------------------------------
    function startTagInHead(p, token) {
        switch (token.tagID) {
            case TAG_ID.HTML: {
                startTagInBody(p, token);
                break;
            }
            case TAG_ID.BASE:
            case TAG_ID.BASEFONT:
            case TAG_ID.BGSOUND:
            case TAG_ID.LINK:
            case TAG_ID.META: {
                p._appendElement(token, NS.HTML);
                token.ackSelfClosing = true;
                break;
            }
            case TAG_ID.TITLE: {
                p._switchToTextParsing(token, TokenizerMode.RCDATA);
                break;
            }
            case TAG_ID.NOSCRIPT: {
                if (p.options.scriptingEnabled) {
                    p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
                }
                else {
                    p._insertElement(token, NS.HTML);
                    p.insertionMode = InsertionMode.IN_HEAD_NO_SCRIPT;
                }
                break;
            }
            case TAG_ID.NOFRAMES:
            case TAG_ID.STYLE: {
                p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
                break;
            }
            case TAG_ID.SCRIPT: {
                p._switchToTextParsing(token, TokenizerMode.SCRIPT_DATA);
                break;
            }
            case TAG_ID.TEMPLATE: {
                p._insertTemplate(token);
                p.activeFormattingElements.insertMarker();
                p.framesetOk = false;
                p.insertionMode = InsertionMode.IN_TEMPLATE;
                p.tmplInsertionModeStack.unshift(InsertionMode.IN_TEMPLATE);
                break;
            }
            case TAG_ID.HEAD: {
                p._err(token, ERR.misplacedStartTagForHeadElement);
                break;
            }
            default: {
                tokenInHead(p, token);
            }
        }
    }
    function endTagInHead(p, token) {
        switch (token.tagID) {
            case TAG_ID.HEAD: {
                p.openElements.pop();
                p.insertionMode = InsertionMode.AFTER_HEAD;
                break;
            }
            case TAG_ID.BODY:
            case TAG_ID.BR:
            case TAG_ID.HTML: {
                tokenInHead(p, token);
                break;
            }
            case TAG_ID.TEMPLATE: {
                templateEndTagInHead(p, token);
                break;
            }
            default: {
                p._err(token, ERR.endTagWithoutMatchingOpenElement);
            }
        }
    }
    function templateEndTagInHead(p, token) {
        if (p.openElements.tmplCount > 0) {
            p.openElements.generateImpliedEndTagsThoroughly();
            if (p.openElements.currentTagId !== TAG_ID.TEMPLATE) {
                p._err(token, ERR.closingOfElementWithOpenChildElements);
            }
            p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
            p.activeFormattingElements.clearToLastMarker();
            p.tmplInsertionModeStack.shift();
            p._resetInsertionMode();
        }
        else {
            p._err(token, ERR.endTagWithoutMatchingOpenElement);
        }
    }
    function tokenInHead(p, token) {
        p.openElements.pop();
        p.insertionMode = InsertionMode.AFTER_HEAD;
        p._processToken(token);
    }
    // The "in head no script" insertion mode
    //------------------------------------------------------------------
    function startTagInHeadNoScript(p, token) {
        switch (token.tagID) {
            case TAG_ID.HTML: {
                startTagInBody(p, token);
                break;
            }
            case TAG_ID.BASEFONT:
            case TAG_ID.BGSOUND:
            case TAG_ID.HEAD:
            case TAG_ID.LINK:
            case TAG_ID.META:
            case TAG_ID.NOFRAMES:
            case TAG_ID.STYLE: {
                startTagInHead(p, token);
                break;
            }
            case TAG_ID.NOSCRIPT: {
                p._err(token, ERR.nestedNoscriptInHead);
                break;
            }
            default: {
                tokenInHeadNoScript(p, token);
            }
        }
    }
    function endTagInHeadNoScript(p, token) {
        switch (token.tagID) {
            case TAG_ID.NOSCRIPT: {
                p.openElements.pop();
                p.insertionMode = InsertionMode.IN_HEAD;
                break;
            }
            case TAG_ID.BR: {
                tokenInHeadNoScript(p, token);
                break;
            }
            default: {
                p._err(token, ERR.endTagWithoutMatchingOpenElement);
            }
        }
    }
    function tokenInHeadNoScript(p, token) {
        const errCode = token.type === TokenType.EOF ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;
        p._err(token, errCode);
        p.openElements.pop();
        p.insertionMode = InsertionMode.IN_HEAD;
        p._processToken(token);
    }
    // The "after head" insertion mode
    //------------------------------------------------------------------
    function startTagAfterHead(p, token) {
        switch (token.tagID) {
            case TAG_ID.HTML: {
                startTagInBody(p, token);
                break;
            }
            case TAG_ID.BODY: {
                p._insertElement(token, NS.HTML);
                p.framesetOk = false;
                p.insertionMode = InsertionMode.IN_BODY;
                break;
            }
            case TAG_ID.FRAMESET: {
                p._insertElement(token, NS.HTML);
                p.insertionMode = InsertionMode.IN_FRAMESET;
                break;
            }
            case TAG_ID.BASE:
            case TAG_ID.BASEFONT:
            case TAG_ID.BGSOUND:
            case TAG_ID.LINK:
            case TAG_ID.META:
            case TAG_ID.NOFRAMES:
            case TAG_ID.SCRIPT:
            case TAG_ID.STYLE:
            case TAG_ID.TEMPLATE:
            case TAG_ID.TITLE: {
                p._err(token, ERR.abandonedHeadElementChild);
                p.openElements.push(p.headElement, TAG_ID.HEAD);
                startTagInHead(p, token);
                p.openElements.remove(p.headElement);
                break;
            }
            case TAG_ID.HEAD: {
                p._err(token, ERR.misplacedStartTagForHeadElement);
                break;
            }
            default: {
                tokenAfterHead(p, token);
            }
        }
    }
    function endTagAfterHead(p, token) {
        switch (token.tagID) {
            case TAG_ID.BODY:
            case TAG_ID.HTML:
            case TAG_ID.BR: {
                tokenAfterHead(p, token);
                break;
            }
            case TAG_ID.TEMPLATE: {
                templateEndTagInHead(p, token);
                break;
            }
            default: {
                p._err(token, ERR.endTagWithoutMatchingOpenElement);
            }
        }
    }
    function tokenAfterHead(p, token) {
        p._insertFakeElement(TAG_NAMES.BODY, TAG_ID.BODY);
        p.insertionMode = InsertionMode.IN_BODY;
        modeInBody(p, token);
    }
    // The "in body" insertion mode
    //------------------------------------------------------------------
    function modeInBody(p, token) {
        switch (token.type) {
            case TokenType.CHARACTER: {
                characterInBody(p, token);
                break;
            }
            case TokenType.WHITESPACE_CHARACTER: {
                whitespaceCharacterInBody(p, token);
                break;
            }
            case TokenType.COMMENT: {
                appendComment(p, token);
                break;
            }
            case TokenType.START_TAG: {
                startTagInBody(p, token);
                break;
            }
            case TokenType.END_TAG: {
                endTagInBody(p, token);
                break;
            }
            case TokenType.EOF: {
                eofInBody(p, token);
                break;
            }
            // Do nothing
        }
    }
    function whitespaceCharacterInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._insertCharacters(token);
    }
    function characterInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._insertCharacters(token);
        p.framesetOk = false;
    }
    function htmlStartTagInBody(p, token) {
        if (p.openElements.tmplCount === 0) {
            p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);
        }
    }
    function bodyStartTagInBody(p, token) {
        const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
        if (bodyElement && p.openElements.tmplCount === 0) {
            p.framesetOk = false;
            p.treeAdapter.adoptAttributes(bodyElement, token.attrs);
        }
    }
    function framesetStartTagInBody(p, token) {
        const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
        if (p.framesetOk && bodyElement) {
            p.treeAdapter.detachNode(bodyElement);
            p.openElements.popAllUpToHtmlElement();
            p._insertElement(token, NS.HTML);
            p.insertionMode = InsertionMode.IN_FRAMESET;
        }
    }
    function addressStartTagInBody(p, token) {
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
            p._closePElement();
        }
        p._insertElement(token, NS.HTML);
    }
    function numberedHeaderStartTagInBody(p, token) {
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
            p._closePElement();
        }
        if (isNumberedHeader(p.openElements.currentTagId)) {
            p.openElements.pop();
        }
        p._insertElement(token, NS.HTML);
    }
    function preStartTagInBody(p, token) {
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
            p._closePElement();
        }
        p._insertElement(token, NS.HTML);
        //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
        //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
        p.skipNextNewLine = true;
        p.framesetOk = false;
    }
    function formStartTagInBody(p, token) {
        const inTemplate = p.openElements.tmplCount > 0;
        if (!p.formElement || inTemplate) {
            if (p.openElements.hasInButtonScope(TAG_ID.P)) {
                p._closePElement();
            }
            p._insertElement(token, NS.HTML);
            if (!inTemplate) {
                p.formElement = p.openElements.current;
            }
        }
    }
    function listItemStartTagInBody(p, token) {
        p.framesetOk = false;
        const tn = token.tagID;
        for (let i = p.openElements.stackTop; i >= 0; i--) {
            const elementId = p.openElements.tagIDs[i];
            if ((tn === TAG_ID.LI && elementId === TAG_ID.LI) ||
                ((tn === TAG_ID.DD || tn === TAG_ID.DT) && (elementId === TAG_ID.DD || elementId === TAG_ID.DT))) {
                p.openElements.generateImpliedEndTagsWithExclusion(elementId);
                p.openElements.popUntilTagNamePopped(elementId);
                break;
            }
            if (elementId !== TAG_ID.ADDRESS &&
                elementId !== TAG_ID.DIV &&
                elementId !== TAG_ID.P &&
                p._isSpecialElement(p.openElements.items[i], elementId)) {
                break;
            }
        }
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
            p._closePElement();
        }
        p._insertElement(token, NS.HTML);
    }
    function plaintextStartTagInBody(p, token) {
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
            p._closePElement();
        }
        p._insertElement(token, NS.HTML);
        p.tokenizer.state = TokenizerMode.PLAINTEXT;
    }
    function buttonStartTagInBody(p, token) {
        if (p.openElements.hasInScope(TAG_ID.BUTTON)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped(TAG_ID.BUTTON);
        }
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
        p.framesetOk = false;
    }
    function aStartTagInBody(p, token) {
        const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(TAG_NAMES.A);
        if (activeElementEntry) {
            callAdoptionAgency(p, token);
            p.openElements.remove(activeElementEntry.element);
            p.activeFormattingElements.removeEntry(activeElementEntry);
        }
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
        p.activeFormattingElements.pushElement(p.openElements.current, token);
    }
    function bStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
        p.activeFormattingElements.pushElement(p.openElements.current, token);
    }
    function nobrStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        if (p.openElements.hasInScope(TAG_ID.NOBR)) {
            callAdoptionAgency(p, token);
            p._reconstructActiveFormattingElements();
        }
        p._insertElement(token, NS.HTML);
        p.activeFormattingElements.pushElement(p.openElements.current, token);
    }
    function appletStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
        p.activeFormattingElements.insertMarker();
        p.framesetOk = false;
    }
    function tableStartTagInBody(p, token) {
        if (p.treeAdapter.getDocumentMode(p.document) !== DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope(TAG_ID.P)) {
            p._closePElement();
        }
        p._insertElement(token, NS.HTML);
        p.framesetOk = false;
        p.insertionMode = InsertionMode.IN_TABLE;
    }
    function areaStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._appendElement(token, NS.HTML);
        p.framesetOk = false;
        token.ackSelfClosing = true;
    }
    function isHiddenInput(token) {
        const inputType = getTokenAttr(token, ATTRS.TYPE);
        return inputType != null && inputType.toLowerCase() === HIDDEN_INPUT_TYPE;
    }
    function inputStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._appendElement(token, NS.HTML);
        if (!isHiddenInput(token)) {
            p.framesetOk = false;
        }
        token.ackSelfClosing = true;
    }
    function paramStartTagInBody(p, token) {
        p._appendElement(token, NS.HTML);
        token.ackSelfClosing = true;
    }
    function hrStartTagInBody(p, token) {
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
            p._closePElement();
        }
        p._appendElement(token, NS.HTML);
        p.framesetOk = false;
        token.ackSelfClosing = true;
    }
    function imageStartTagInBody(p, token) {
        token.tagName = TAG_NAMES.IMG;
        token.tagID = TAG_ID.IMG;
        areaStartTagInBody(p, token);
    }
    function textareaStartTagInBody(p, token) {
        p._insertElement(token, NS.HTML);
        //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move
        //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
        p.skipNextNewLine = true;
        p.tokenizer.state = TokenizerMode.RCDATA;
        p.originalInsertionMode = p.insertionMode;
        p.framesetOk = false;
        p.insertionMode = InsertionMode.TEXT;
    }
    function xmpStartTagInBody(p, token) {
        if (p.openElements.hasInButtonScope(TAG_ID.P)) {
            p._closePElement();
        }
        p._reconstructActiveFormattingElements();
        p.framesetOk = false;
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
    }
    function iframeStartTagInBody(p, token) {
        p.framesetOk = false;
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
    }
    //NOTE: here we assume that we always act as an user agent with enabled plugins, so we parse
    //<noembed> as rawtext.
    function noembedStartTagInBody(p, token) {
        p._switchToTextParsing(token, TokenizerMode.RAWTEXT);
    }
    function selectStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
        p.framesetOk = false;
        p.insertionMode =
            p.insertionMode === InsertionMode.IN_TABLE ||
                p.insertionMode === InsertionMode.IN_CAPTION ||
                p.insertionMode === InsertionMode.IN_TABLE_BODY ||
                p.insertionMode === InsertionMode.IN_ROW ||
                p.insertionMode === InsertionMode.IN_CELL
                ? InsertionMode.IN_SELECT_IN_TABLE
                : InsertionMode.IN_SELECT;
    }
    function optgroupStartTagInBody(p, token) {
        if (p.openElements.currentTagId === TAG_ID.OPTION) {
            p.openElements.pop();
        }
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
    }
    function rbStartTagInBody(p, token) {
        if (p.openElements.hasInScope(TAG_ID.RUBY)) {
            p.openElements.generateImpliedEndTags();
        }
        p._insertElement(token, NS.HTML);
    }
    function rtStartTagInBody(p, token) {
        if (p.openElements.hasInScope(TAG_ID.RUBY)) {
            p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.RTC);
        }
        p._insertElement(token, NS.HTML);
    }
    function mathStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        adjustTokenMathMLAttrs(token);
        adjustTokenXMLAttrs(token);
        if (token.selfClosing) {
            p._appendElement(token, NS.MATHML);
        }
        else {
            p._insertElement(token, NS.MATHML);
        }
        token.ackSelfClosing = true;
    }
    function svgStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        adjustTokenSVGAttrs(token);
        adjustTokenXMLAttrs(token);
        if (token.selfClosing) {
            p._appendElement(token, NS.SVG);
        }
        else {
            p._insertElement(token, NS.SVG);
        }
        token.ackSelfClosing = true;
    }
    function genericStartTagInBody(p, token) {
        p._reconstructActiveFormattingElements();
        p._insertElement(token, NS.HTML);
    }
    function startTagInBody(p, token) {
        switch (token.tagID) {
            case TAG_ID.I:
            case TAG_ID.S:
            case TAG_ID.B:
            case TAG_ID.U:
            case TAG_ID.EM:
            case TAG_ID.TT:
            case TAG_ID.BIG:
            case TAG_ID.CODE:
            case TAG_ID.FONT:
            case TAG_ID.SMALL:
            case TAG_ID.STRIKE:
            case TAG_ID.STRONG: {
                bStartTagInBody(p, token);
                break;
            }
            case TAG_ID.A: {
                aStartTagInBody(p, token);
                break;
            }
            case TAG_ID.H1:
            case TAG_ID.H2:
            case TAG_ID.H3:
            case TAG_ID.H4:
            case TAG_ID.H5:
            case TAG_ID.H6: {
                numberedHeaderStartTagInBody(p, token);
                break;
            }
            case TAG_ID.P:
            case TAG_ID.DL:
            case TAG_ID.OL:
            case TAG_ID.UL:
            case TAG_ID.DIV:
            case TAG_ID.DIR:
            case TAG_ID.NAV:
            case TAG_ID.MAIN:
            case TAG_ID.MENU:
            case TAG_ID.ASIDE:
            case TAG_ID.CENTER:
            case TAG_ID.FIGURE:
            case TAG_ID.FOOTER:
            case TAG_ID.HEADER:
            case TAG_ID.HGROUP:
            case TAG_ID.DIALOG:
            case TAG_ID.DETAILS:
            case TAG_ID.ADDRESS:
            case TAG_ID.ARTICLE:
            case TAG_ID.SECTION:
            case TAG_ID.SUMMARY:
            case TAG_ID.FIELDSET:
            case TAG_ID.BLOCKQUOTE:
            case TAG_ID.FIGCAPTION: {
                addressStartTagInBody(p, token);
                break;
            }
            case TAG_ID.LI:
            case TAG_ID.DD:
            case TAG_ID.DT: {
                listItemStartTagInBody(p, token);
                break;
            }
            case TAG_ID.BR:
            case TAG_ID.IMG:
            case TAG_ID.WBR:
            case TAG_ID.AREA:
            case TAG_ID.EMBED:
            case TAG_ID.KEYGEN: {
                areaStartTagInBody(p, token);
                break;
            }
            case TAG_ID.HR: {
                hrStartTagInBody(p, token);
                break;
            }
            case TAG_ID.RB:
            case TAG_ID.RTC: {
                rbStartTagInBody(p, token);
                break;
            }
            case TAG_ID.RT:
            case TAG_ID.RP: {
                rtStartTagInBody(p, token);
                break;
            }
            case TAG_ID.PRE:
            case TAG_ID.LISTING: {
                preStartTagInBody(p, token);
                break;
            }
            case TAG_ID.XMP: {
                xmpStartTagInBody(p, token);
                break;
            }
            case TAG_ID.SVG: {
                svgStartTagInBody(p, token);
                break;
            }
            case TAG_ID.HTML: {
                htmlStartTagInBody(p, token);
                break;
            }
            case TAG_ID.BASE:
            case TAG_ID.LINK:
            case TAG_ID.META:
            case TAG_ID.STYLE:
            case TAG_ID.TITLE:
            case TAG_ID.SCRIPT:
            case TAG_ID.BGSOUND:
            case TAG_ID.BASEFONT:
            case TAG_ID.TEMPLATE: {
                startTagInHead(p, token);
                break;
            }
            case TAG_ID.BODY: {
                bodyStartTagInBody(p, token);
                break;
            }
            case TAG_ID.FORM: {
                formStartTagInBody(p, token);
                break;
            }
            case TAG_ID.NOBR: {
                nobrStartTagInBody(p, token);
                break;
            }
            case TAG_ID.MATH: {
                mathStartTagInBody(p, token);
                break;
            }
            case TAG_ID.TABLE: {
                tableStartTagInBody(p, token);
                break;
            }
            case TAG_ID.INPUT: {
                inputStartTagInBody(p, token);
                break;
            }
            case TAG_ID.PARAM:
            case TAG_ID.TRACK:
            case TAG_ID.SOURCE: {
                paramStartTagInBody(p, token);
                break;
            }
            case TAG_ID.IMAGE: {
                imageStartTagInBody(p, token);
                break;
            }
            case TAG_ID.BUTTON: {
                buttonStartTagInBody(p, token);
                break;
            }
            case TAG_ID.APPLET:
            case TAG_ID.OBJECT:
            case TAG_ID.MARQUEE: {
                appletStartTagInBody(p, token);
                break;
            }
            case TAG_ID.IFRAME: {
                iframeStartTagInBody(p, token);
                break;
            }
            case TAG_ID.SELECT: {
                selectStartTagInBody(p, token);
                break;
            }
            case TAG_ID.OPTION:
            case TAG_ID.OPTGROUP: {
                optgroupStartTagInBody(p, token);
                break;
            }
            case TAG_ID.NOEMBED: {
                noembedStartTagInBody(p, token);
                break;
            }
            case TAG_ID.FRAMESET: {
                framesetStartTagInBody(p, token);
                break;
            }
            case TAG_ID.TEXTAREA: {
                textareaStartTagInBody(p, token);
                break;
            }
            case TAG_ID.NOSCRIPT: {
                if (p.options.scriptingEnabled) {
                    noembedStartTagInBody(p, token);
                }
                else {
                    genericStartTagInBody(p, token);
                }
                break;
            }
            case TAG_ID.PLAINTEXT: {
                plaintextStartTagInBody(p, token);
                break;
            }
            case TAG_ID.COL:
            case TAG_ID.TH:
            case TAG_ID.TD:
            case TAG_ID.TR:
            case TAG_ID.HEAD:
            case TAG_ID.FRAME:
            case TAG_ID.TBODY:
            case TAG_ID.TFOOT:
            case TAG_ID.THEAD:
            case TAG_ID.CAPTION:
            case TAG_ID.COLGROUP: {
                // Ignore token
                break;
            }
            default: {
                genericStartTagInBody(p, token);
            }
        }
    }
    function bodyEndTagInBody(p, token) {
        if (p.openElements.hasInScope(TAG_ID.BODY)) {
            p.insertionMode = InsertionMode.AFTER_BODY;
            //NOTE: <body> is never popped from the stack, so we need to updated
            //the end location explicitly.
            if (p.options.sourceCodeLocationInfo) {
                const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();
                if (bodyElement) {
                    p._setEndLocation(bodyElement, token);
                }
            }
        }
    }
    function htmlEndTagInBody(p, token) {
        if (p.openElements.hasInScope(TAG_ID.BODY)) {
            p.insertionMode = InsertionMode.AFTER_BODY;
            endTagAfterBody(p, token);
        }
    }
    function addressEndTagInBody(p, token) {
        const tn = token.tagID;
        if (p.openElements.hasInScope(tn)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped(tn);
        }
    }
    function formEndTagInBody(p) {
        const inTemplate = p.openElements.tmplCount > 0;
        const { formElement } = p;
        if (!inTemplate) {
            p.formElement = null;
        }
        if ((formElement || inTemplate) && p.openElements.hasInScope(TAG_ID.FORM)) {
            p.openElements.generateImpliedEndTags();
            if (inTemplate) {
                p.openElements.popUntilTagNamePopped(TAG_ID.FORM);
            }
            else if (formElement) {
                p.openElements.remove(formElement);
            }
        }
    }
    function pEndTagInBody(p) {
        if (!p.openElements.hasInButtonScope(TAG_ID.P)) {
            p._insertFakeElement(TAG_NAMES.P, TAG_ID.P);
        }
        p._closePElement();
    }
    function liEndTagInBody(p) {
        if (p.openElements.hasInListItemScope(TAG_ID.LI)) {
            p.openElements.generateImpliedEndTagsWithExclusion(TAG_ID.LI);
            p.openElements.popUntilTagNamePopped(TAG_ID.LI);
        }
    }
    function ddEndTagInBody(p, token) {
        const tn = token.tagID;
        if (p.openElements.hasInScope(tn)) {
            p.openElements.generateImpliedEndTagsWithExclusion(tn);
            p.openElements.popUntilTagNamePopped(tn);
        }
    }
    function numberedHeaderEndTagInBody(p) {
        if (p.openElements.hasNumberedHeaderInScope()) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilNumberedHeaderPopped();
        }
    }
    function appletEndTagInBody(p, token) {
        const tn = token.tagID;
        if (p.openElements.hasInScope(tn)) {
            p.openElements.generateImpliedEndTags();
            p.openElements.popUntilTagNamePopped(tn);
            p.activeFormattingElements.clearToLastMarker();
        }
    }
    function brEndTagInBody(p) {
        p._reconstructActiveFormattingElements();
        p._insertFakeElement(TAG_NAMES.BR, TAG_ID.BR);
        p.openElements.pop();
        p.framesetOk = false;
    }
    function genericEndTagInBody(p, token) {
        const tn = token.tagName;
        const tid = token.tagID;
        for (let i = p.openElements.stackTop; i > 0; i--) {
            const element = p.openElements.items[i];
            const elementId = p.openElements.tagIDs[i];
            // Compare the tag name here, as the tag might not be a known tag with an ID.
            if (tid === elementId && (tid !== TAG_ID.UNKNOWN || p.treeAdapter.getTagName(element) === tn)) {
                p.openElements.generateImpliedEndTagsWithExclusion(tid);
                if (p.openElements.stackTop >= i)
                    p.openElements.shortenToLength(i);
                break;
            }
            if (p._isSpecialElement(element, elementId)) {
                break;
            }
        }
    }
    function endTagInBody(p, token) {
        switch (token.tagID) {
            case TAG_ID.A:
            case TAG_ID.B:
            case TAG_ID.I:
            case TAG_ID.S:
            case TAG_ID.U:
            case TAG_ID.EM:
            case TAG_ID.TT:
            case TAG_ID.BIG:
            case TAG_ID.CODE:
            case TAG_ID.FONT:
            case TAG_ID.NOBR:
            case TAG_ID.SMALL:
            case TAG_ID.STRIKE:
            case TAG_ID.STRONG: {
                callAdoptionAgency(p, token);
                break;
            }
            case TAG_ID.P: {
                pEndTagInBody(p);
                break;
            }
            case TAG_ID.DL:
            case TAG_ID.UL:
            case TAG_ID.OL:
            case TAG_ID.DIR:
            case TAG_ID.DIV:
            case TAG_ID.NAV:
            case TAG_ID.PRE:
            case TAG_ID.MAIN:
            case TAG_ID.MENU:
            case TAG_ID.ASIDE:
            case TAG_ID.BUTTON:
            case TAG_ID.CENTER:
            case TAG_ID.FIGURE:
            case TAG_ID.FOOTER:
            case TAG_ID.HEADER:
            case TAG_ID.HGROUP:
            case TAG_ID.DIALOG:
            case TAG_ID.ADDRESS:
            case TAG_ID.ARTICLE:
            case TAG_ID.DETAILS:
            case TAG_ID.SECTION:
            case TAG_ID.SUMMARY:
            case TAG_ID.LISTING:
            case TAG_ID.FIELDSET:
            case TAG_ID.BLOCKQUOTE:
            case TAG_ID.FIGCAPTION: {
                addressEndTagInBody(p, token);
                break;
            }
            case TAG_ID.LI: {
                liEndTagInBody(p);
                break;
            }
            case TAG_ID.DD:
            case TAG_ID.DT: {
                ddEndTagInBody(p, token);
                break;
            }
            case TAG_ID.H1:
            case TAG_ID.H2:
            case TAG_ID.H3:
            case TAG_ID.H4:
            case TAG_ID.H5:
            case TAG_ID.H6: {
                numberedHeaderEndTagInBody(p);
                break;
            }
            case TAG_ID.BR: {
                brEndTagInBody(p);
                break;
            }
            case TAG_ID.BODY: {
                bodyEndTagInBody(p, token);
                break;
            }
            case TAG_ID.HTML: {
                htmlEndTagInBody(p, token);
                break;
            }
            case TAG_ID.FORM: {
                formEndTagInBody(p);
                break;
            }
            case TAG_ID.APPLET:
            case TAG_ID.OBJECT:
            case TAG_ID.MARQUEE: {
                appletEndTagInBody(p, token);
                break;
            }
            case TAG_ID.TEMPLATE: {
                templateEndTagInHead(p, token);
                break;
            }
            default: {
                genericEndTagInBody(p, token);
            }
        }
    }
    function eofInBody(p, token) {
        if (p.tmplInsertionModeStack.length > 0) {
            eofInTemplate(p, token);
        }
        else {
            stopParsing(p, token);
        }
    }
    // The "text" insertion mode
    //------------------------------------------------------------------
    function endTagInText(p, token) {
        var _a;
        if (token.tagID === TAG_ID.SCRIPT) {
            (_a = p.scriptHandler) === null || _a === void 0 ? void 0 : _a.call(p, p.openElements.current);
        }
        p.openElements.pop();
        p.insertionMode = p.originalInsertionMode;
    }
    function eofInText(p, token) {
        p._err(token, ERR.eofInElementThatCanContainOnlyText);
        p.openElements.pop();
        p.insertionMode = p.originalInsertionMode;
        p.onEof(token);
    }
    // The "in table" insertion mode
    //------------------------------------------------------------------
    function characterInTable(p, token) {
        if (TABLE_STRUCTURE_TAGS.has(p.openElements.currentTagId)) {
            p.pendingCharacterTokens.length = 0;
            p.hasNonWhitespacePendingCharacterToken = false;
            p.originalInsertionMode = p.insertionMode;
            p.insertionMode = InsertionMode.IN_TABLE_TEXT;
            switch (token.type) {
                case TokenType.CHARACTER: {
                    characterInTableText(p, token);
                    break;
                }
                case TokenType.WHITESPACE_CHARACTER: {
                    whitespaceCharacterInTableText(p, token);
                    break;
                }
                // Ignore null
            }
        }
        else {
            tokenInTable(p, token);
        }
    }
    function captionStartTagInTable(p, token) {
        p.openElements.clearBackToTableContext();
        p.activeFormattingElements.insertMarker();
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_CAPTION;
    }
    function colgroupStartTagInTable(p, token) {
        p.openElements.clearBackToTableContext();
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
    }
    function colStartTagInTable(p, token) {
        p.openElements.clearBackToTableContext();
        p._insertFakeElement(TAG_NAMES.COLGROUP, TAG_ID.COLGROUP);
        p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
        startTagInColumnGroup(p, token);
    }
    function tbodyStartTagInTable(p, token) {
        p.openElements.clearBackToTableContext();
        p._insertElement(token, NS.HTML);
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
    }
    function tdStartTagInTable(p, token) {
        p.openElements.clearBackToTableContext();
        p._insertFakeElement(TAG_NAMES.TBODY, TAG_ID.TBODY);
        p.insertionMode = InsertionMode.IN_TABLE_BODY;
        startTagInTableBody(p, token);
    }
    function tableStartTagInTable(p, token) {
        if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
            p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
            p._resetInsertionMode();
            p._processStartTag(token);
        }
    }
    function inputStartTagInTable(p, token) {
        if (isHiddenInput(token)) {
            p._appendElement(token, NS.HTML);
        }
        else {
            tokenInTable(p, token);
        }
        token.ackSelfClosing = true;
    }
    function formStartTagInTable(p, token) {
        if (!p.formElement && p.openElements.tmplCount === 0) {
            p._insertElement(token, NS.HTML);
            p.formElement = p.openElements.current;
            p.openElements.pop();
        }
    }
    function startTagInTable(p, token) {
        switch (token.tagID) {
            case TAG_ID.TD:
            case TAG_ID.TH:
            case TAG_ID.TR: {
                tdStartTagInTable(p, token);
                break;
            }
            case TAG_ID.STYLE:
            case TAG_ID.SCRIPT:
            case TAG_ID.TEMPLATE: {
                startTagInHead(p, token);
                break;
            }
            case TAG_ID.COL: {
                colStartTagInTable(p, token);
                break;
            }
            case TAG_ID.FORM: {
                formStartTagInTable(p, token);
                break;
            }
            case TAG_ID.TABLE: {
                tableStartTagInTable(p, token);
                break;
            }
            case TAG_ID.TBODY:
            case TAG_ID.TFOOT:
            case TAG_ID.THEAD: {
                tbodyStartTagInTable(p, token);
                break;
            }
            case TAG_ID.INPUT: {
                inputStartTagInTable(p, token);
                break;
            }
            case TAG_ID.CAPTION: {
                captionStartTagInTable(p, token);
                break;
            }
            case TAG_ID.COLGROUP: {
                colgroupStartTagInTable(p, token);
                break;
            }
            default: {
                tokenInTable(p, token);
            }
        }
    }
    function endTagInTable(p, token) {
        switch (token.tagID) {
            case TAG_ID.TABLE: {
                if (p.openElements.hasInTableScope(TAG_ID.TABLE)) {
                    p.openElements.popUntilTagNamePopped(TAG_ID.TABLE);
                    p._resetInsertionMode();
                }
                break;
            }
            case TAG_ID.TEMPLATE: {
                templateEndTagInHead(p, token);
                break;
            }
            case TAG_ID.BODY:
            case TAG_ID.CAPTION:
            case TAG_ID.COL:
            case TAG_ID.COLGROUP:
            case TAG_ID.HTML:
            case TAG_ID.TBODY:
            case TAG_ID.TD:
            case TAG_ID.TFOOT:
            case TAG_ID.TH:
            case TAG_ID.THEAD:
            case TAG_ID.TR: {
                // Ignore token
                break;
            }
            default: {
                tokenInTable(p, token);
            }
        }
    }
    function tokenInTable(p, token) {
        const savedFosterParentingState = p.fosterParentingEnabled;
        p.fosterParentingEnabled = true;
        // Process token in `In Body` mode
        modeInBody(p, token);
        p.fosterParentingEnabled = savedFosterParentingState;
    }
    // The "in table text" insertion mode
    //------------------------------------------------------------------
    function whitespaceCharacterInTableText(p, token) {
        p.pendingCharacterTokens.push(token);
    }
    function characterInTableText(p, token) {
        p.pendingCharacterTokens.push(token);
        p.hasNonWhitespacePendingCharacterToken = true;
    }
    function tokenInTableText(p, token) {
        let i = 0;
        if (p.hasNonWhitespacePendingCharacterToken) {
            for (; i < p.pendingCharacterTokens.length; i++) {
                tokenInTable(p, p.pendingCharacterTokens[i]);
            }
        }
        else {
            for (; i < p.pendingCharacterTokens.length; i++) {
                p._insertCharacters(p.pendingCharacterTokens[i]);
            }
        }
        p.insertionMode = p.originalInsertionMode;
        p._processToken(token);
    }
    // The "in caption" insertion mode
    //------------------------------------------------------------------
    const TABLE_VOID_ELEMENTS = new Set([TAG_ID.CAPTION, TAG_ID.COL, TAG_ID.COLGROUP, TAG_ID.TBODY, TAG_ID.TD, TAG_ID.TFOOT, TAG_ID.TH, TAG_ID.THEAD, TAG_ID.TR]);
    function startTagInCaption(p, token) {
        const tn = token.tagID;
        if (TABLE_VOID_ELEMENTS.has(tn)) {
            if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
                p.openElements.generateImpliedEndTags();
                p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
                p.activeFormattingElements.clearToLastMarker();
                p.insertionMode = InsertionMode.IN_TABLE;
                startTagInTable(p, token);
            }
        }
        else {
            startTagInBody(p, token);
        }
    }
    function endTagInCaption(p, token) {
        const tn = token.tagID;
        switch (tn) {
            case TAG_ID.CAPTION:
            case TAG_ID.TABLE: {
                if (p.openElements.hasInTableScope(TAG_ID.CAPTION)) {
                    p.openElements.generateImpliedEndTags();
                    p.openElements.popUntilTagNamePopped(TAG_ID.CAPTION);
                    p.activeFormattingElements.clearToLastMarker();
                    p.insertionMode = InsertionMode.IN_TABLE;
                    if (tn === TAG_ID.TABLE) {
                        endTagInTable(p, token);
                    }
                }
                break;
            }
            case TAG_ID.BODY:
            case TAG_ID.COL:
            case TAG_ID.COLGROUP:
            case TAG_ID.HTML:
            case TAG_ID.TBODY:
            case TAG_ID.TD:
            case TAG_ID.TFOOT:
            case TAG_ID.TH:
            case TAG_ID.THEAD:
            case TAG_ID.TR: {
                // Ignore token
                break;
            }
            default: {
                endTagInBody(p, token);
            }
        }
    }
    // The "in column group" insertion mode
    //------------------------------------------------------------------
    function startTagInColumnGroup(p, token) {
        switch (token.tagID) {
            case TAG_ID.HTML: {
                startTagInBody(p, token);
                break;
            }
            case TAG_ID.COL: {
                p._appendElement(token, NS.HTML);
                token.ackSelfClosing = true;
                break;
            }
            case TAG_ID.TEMPLATE: {
                startTagInHead(p, token);
                break;
            }
            default: {
                tokenInColumnGroup(p, token);
            }
        }
    }
    function endTagInColumnGroup(p, token) {
        switch (token.tagID) {
            case TAG_ID.COLGROUP: {
                if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
                    p.openElements.pop();
                    p.insertionMode = InsertionMode.IN_TABLE;
                }
                break;
            }
            case TAG_ID.TEMPLATE: {
                templateEndTagInHead(p, token);
                break;
            }
            case TAG_ID.COL: {
                // Ignore token
                break;
            }
            default: {
                tokenInColumnGroup(p, token);
            }
        }
    }
    function tokenInColumnGroup(p, token) {
        if (p.openElements.currentTagId === TAG_ID.COLGROUP) {
            p.openElements.pop();
            p.insertionMode = InsertionMode.IN_TABLE;
            p._processToken(token);
        }
    }
    // The "in table body" insertion mode
    //------------------------------------------------------------------
    function startTagInTableBody(p, token) {
        switch (token.tagID) {
            case TAG_ID.TR: {
                p.openElements.clearBackToTableBodyContext();
                p._insertElement(token, NS.HTML);
                p.insertionMode = InsertionMode.IN_ROW;
                break;
            }
            case TAG_ID.TH:
            case TAG_ID.TD: {
                p.openElements.clearBackToTableBodyContext();
                p._insertFakeElement(TAG_NAMES.TR, TAG_ID.TR);
                p.insertionMode = InsertionMode.IN_ROW;
                startTagInRow(p, token);
                break;
            }
            case TAG_ID.CAPTION:
            case TAG_ID.COL:
            case TAG_ID.COLGROUP:
            case TAG_ID.TBODY:
            case TAG_ID.TFOOT:
            case TAG_ID.THEAD: {
                if (p.openElements.hasTableBodyContextInTableScope()) {
                    p.openElements.clearBackToTableBodyContext();
                    p.openElements.pop();
                    p.insertionMode = InsertionMode.IN_TABLE;
                    startTagInTable(p, token);
                }
                break;
            }
            default: {
                startTagInTable(p, token);
            }
        }
    }
    function endTagInTableBody(p, token) {
        const tn = token.tagID;
        switch (token.tagID) {
            case TAG_ID.TBODY:
            case TAG_ID.TFOOT:
            case TAG_ID.THEAD: {
                if (p.openElements.hasInTableScope(tn)) {
                    p.openElements.clearBackToTableBodyContext();
                    p.openElements.pop();
                    p.insertionMode = InsertionMode.IN_TABLE;
                }
                break;
            }
            case TAG_ID.TABLE: {
                if (p.openElements.hasTableBodyContextInTableScope()) {
                    p.openElements.clearBackToTableBodyContext();
                    p.openElements.pop();
                    p.insertionMode = InsertionMode.IN_TABLE;
                    endTagInTable(p, token);
                }
                break;
            }
            case TAG_ID.BODY:
            case TAG_ID.CAPTION:
            case TAG_ID.COL:
            case TAG_ID.COLGROUP:
            case TAG_ID.HTML:
            case TAG_ID.TD:
            case TAG_ID.TH:
            case TAG_ID.TR: {
                // Ignore token
                break;
            }
            default: {
                endTagInTable(p, token);
            }
        }
    }
    // The "in row" insertion mode
    //------------------------------------------------------------------
    function startTagInRow(p, token) {
        switch (token.tagID) {
            case TAG_ID.TH:
            case TAG_ID.TD: {
                p.openElements.clearBackToTableRowContext();
                p._insertElement(token, NS.HTML);
                p.insertionMode = InsertionMode.IN_CELL;
                p.activeFormattingElements.insertMarker();
                break;
            }
            case TAG_ID.CAPTION:
            case TAG_ID.COL:
            case TAG_ID.COLGROUP:
            case TAG_ID.TBODY:
            case TAG_ID.TFOOT:
            case TAG_ID.THEAD:
            case TAG_ID.TR: {
                if (p.openElements.hasInTableScope(TAG_ID.TR)) {
                    p.openElements.clearBackToTableRowContext();
                    p.openElements.pop();
                    p.insertionMode = InsertionMode.IN_TABLE_BODY;
                    startTagInTableBody(p, token);
                }
                break;
            }
            default: {
                startTagInTable(p, token);
            }
        }
    }
    function endTagInRow(p, token) {
        switch (token.tagID) {
            case TAG_ID.TR: {
                if (p.openElements.hasInTableScope(TAG_ID.TR)) {
                    p.openElements.clearBackToTableRowContext();
                    p.openElements.pop();
                    p.insertionMode = InsertionMode.IN_TABLE_BODY;
                }
                break;
            }
            case TAG_ID.TABLE: {
                if (p.openElements.hasInTableScope(TAG_ID.TR)) {
                    p.openElements.clearBackToTableRowContext();
                    p.openElements.pop();
                    p.insertionMode = InsertionMode.IN_TABLE_BODY;
                    endTagInTableBody(p, token);
                }
                break;
            }
            case TAG_ID.TBODY:
            case TAG_ID.TFOOT:
            case TAG_ID.THEAD: {
                if (p.openElements.hasInTableScope(token.tagID) || p.openElements.hasInTableScope(TAG_ID.TR)) {
                    p.openElements.clearBackToTableRowContext();
                    p.openElements.pop();
                    p.insertionMode = InsertionMode.IN_TABLE_BODY;
                    endTagInTableBody(p, token);
                }
                break;
            }
            case TAG_ID.BODY:
            case TAG_ID.CAPTION:
            case TAG_ID.COL:
            case TAG_ID.COLGROUP:
            case TAG_ID.HTML:
            case TAG_ID.TD:
            case TAG_ID.TH: {
                // Ignore end tag
                break;
            }
            default: {
                endTagInTable(p, token);
            }
        }
    }
    // The "in cell" insertion mode
    //------------------------------------------------------------------
    function startTagInCell(p, token) {
        const tn = token.tagID;
        if (TABLE_VOID_ELEMENTS.has(tn)) {
            if (p.openElements.hasInTableScope(TAG_ID.TD) || p.openElements.hasInTableScope(TAG_ID.TH)) {
                p._closeTableCell();
                startTagInRow(p, token);
            }
        }
        else {
            startTagInBody(p, token);
        }
    }
    function endTagInCell(p, token) {
        const tn = token.tagID;
        switch (tn) {
            case TAG_ID.TD:
            case TAG_ID.TH: {
                if (p.openElements.hasInTableScope(tn)) {
                    p.openElements.generateImpliedEndTags();
                    p.openElements.popUntilTagNamePopped(tn);
                    p.activeFormattingElements.clearToLastMarker();
                    p.insertionMode = InsertionMode.IN_ROW;
                }
                break;
            }
            case TAG_ID.TABLE:
            case TAG_ID.TBODY:
            case TAG_ID.TFOOT:
            case TAG_ID.THEAD:
            case TAG_ID.TR: {
                if (p.openElements.hasInTableScope(tn)) {
                    p._closeTableCell();
                    endTagInRow(p, token);
                }
                break;
            }
            case TAG_ID.BODY:
            case TAG_ID.CAPTION:
            case TAG_ID.COL:
            case TAG_ID.COLGROUP:
            case TAG_ID.HTML: {
                // Ignore token
                break;
            }
            default: {
                endTagInBody(p, token);
            }
        }
    }
    // The "in select" insertion mode
    //------------------------------------------------------------------
    function startTagInSelect(p, token) {
        switch (token.tagID) {
            case TAG_ID.HTML: {
                startTagInBody(p, token);
                break;
            }
            case TAG_ID.OPTION: {
                if (p.openElements.currentTagId === TAG_ID.OPTION) {
                    p.openElements.pop();
                }
                p._insertElement(token, NS.HTML);
                break;
            }
            case TAG_ID.OPTGROUP: {
                if (p.openElements.currentTagId === TAG_ID.OPTION) {
                    p.openElements.pop();
                }
                if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
                    p.openElements.pop();
                }
                p._insertElement(token, NS.HTML);
                break;
            }
            case TAG_ID.INPUT:
            case TAG_ID.KEYGEN:
            case TAG_ID.TEXTAREA:
            case TAG_ID.SELECT: {
                if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
                    p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
                    p._resetInsertionMode();
                    if (token.tagID !== TAG_ID.SELECT) {
                        p._processStartTag(token);
                    }
                }
                break;
            }
            case TAG_ID.SCRIPT:
            case TAG_ID.TEMPLATE: {
                startTagInHead(p, token);
                break;
            }
            // Do nothing
        }
    }
    function endTagInSelect(p, token) {
        switch (token.tagID) {
            case TAG_ID.OPTGROUP: {
                if (p.openElements.stackTop > 0 &&
                    p.openElements.currentTagId === TAG_ID.OPTION &&
                    p.openElements.tagIDs[p.openElements.stackTop - 1] === TAG_ID.OPTGROUP) {
                    p.openElements.pop();
                }
                if (p.openElements.currentTagId === TAG_ID.OPTGROUP) {
                    p.openElements.pop();
                }
                break;
            }
            case TAG_ID.OPTION: {
                if (p.openElements.currentTagId === TAG_ID.OPTION) {
                    p.openElements.pop();
                }
                break;
            }
            case TAG_ID.SELECT: {
                if (p.openElements.hasInSelectScope(TAG_ID.SELECT)) {
                    p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
                    p._resetInsertionMode();
                }
                break;
            }
            case TAG_ID.TEMPLATE: {
                templateEndTagInHead(p, token);
                break;
            }
            // Do nothing
        }
    }
    // The "in select in table" insertion mode
    //------------------------------------------------------------------
    function startTagInSelectInTable(p, token) {
        const tn = token.tagID;
        if (tn === TAG_ID.CAPTION ||
            tn === TAG_ID.TABLE ||
            tn === TAG_ID.TBODY ||
            tn === TAG_ID.TFOOT ||
            tn === TAG_ID.THEAD ||
            tn === TAG_ID.TR ||
            tn === TAG_ID.TD ||
            tn === TAG_ID.TH) {
            p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
            p._resetInsertionMode();
            p._processStartTag(token);
        }
        else {
            startTagInSelect(p, token);
        }
    }
    function endTagInSelectInTable(p, token) {
        const tn = token.tagID;
        if (tn === TAG_ID.CAPTION ||
            tn === TAG_ID.TABLE ||
            tn === TAG_ID.TBODY ||
            tn === TAG_ID.TFOOT ||
            tn === TAG_ID.THEAD ||
            tn === TAG_ID.TR ||
            tn === TAG_ID.TD ||
            tn === TAG_ID.TH) {
            if (p.openElements.hasInTableScope(tn)) {
                p.openElements.popUntilTagNamePopped(TAG_ID.SELECT);
                p._resetInsertionMode();
                p.onEndTag(token);
            }
        }
        else {
            endTagInSelect(p, token);
        }
    }
    // The "in template" insertion mode
    //------------------------------------------------------------------
    function startTagInTemplate(p, token) {
        switch (token.tagID) {
            // First, handle tags that can start without a mode change
            case TAG_ID.BASE:
            case TAG_ID.BASEFONT:
            case TAG_ID.BGSOUND:
            case TAG_ID.LINK:
            case TAG_ID.META:
            case TAG_ID.NOFRAMES:
            case TAG_ID.SCRIPT:
            case TAG_ID.STYLE:
            case TAG_ID.TEMPLATE:
            case TAG_ID.TITLE: {
                startTagInHead(p, token);
                break;
            }
            // Re-process the token in the appropriate mode
            case TAG_ID.CAPTION:
            case TAG_ID.COLGROUP:
            case TAG_ID.TBODY:
            case TAG_ID.TFOOT:
            case TAG_ID.THEAD: {
                p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE;
                p.insertionMode = InsertionMode.IN_TABLE;
                startTagInTable(p, token);
                break;
            }
            case TAG_ID.COL: {
                p.tmplInsertionModeStack[0] = InsertionMode.IN_COLUMN_GROUP;
                p.insertionMode = InsertionMode.IN_COLUMN_GROUP;
                startTagInColumnGroup(p, token);
                break;
            }
            case TAG_ID.TR: {
                p.tmplInsertionModeStack[0] = InsertionMode.IN_TABLE_BODY;
                p.insertionMode = InsertionMode.IN_TABLE_BODY;
                startTagInTableBody(p, token);
                break;
            }
            case TAG_ID.TD:
            case TAG_ID.TH: {
                p.tmplInsertionModeStack[0] = InsertionMode.IN_ROW;
                p.insertionMode = InsertionMode.IN_ROW;
                startTagInRow(p, token);
                break;
            }
            default: {
                p.tmplInsertionModeStack[0] = InsertionMode.IN_BODY;
                p.insertionMode = InsertionMode.IN_BODY;
                startTagInBody(p, token);
            }
        }
    }
    function endTagInTemplate(p, token) {
        if (token.tagID === TAG_ID.TEMPLATE) {
            templateEndTagInHead(p, token);
        }
    }
    function eofInTemplate(p, token) {
        if (p.openElements.tmplCount > 0) {
            p.openElements.popUntilTagNamePopped(TAG_ID.TEMPLATE);
            p.activeFormattingElements.clearToLastMarker();
            p.tmplInsertionModeStack.shift();
            p._resetInsertionMode();
            p.onEof(token);
        }
        else {
            stopParsing(p, token);
        }
    }
    // The "after body" insertion mode
    //------------------------------------------------------------------
    function startTagAfterBody(p, token) {
        if (token.tagID === TAG_ID.HTML) {
            startTagInBody(p, token);
        }
        else {
            tokenAfterBody(p, token);
        }
    }
    function endTagAfterBody(p, token) {
        var _a;
        if (token.tagID === TAG_ID.HTML) {
            if (!p.fragmentContext) {
                p.insertionMode = InsertionMode.AFTER_AFTER_BODY;
            }
            //NOTE: <html> is never popped from the stack, so we need to updated
            //the end location explicitly.
            if (p.options.sourceCodeLocationInfo && p.openElements.tagIDs[0] === TAG_ID.HTML) {
                p._setEndLocation(p.openElements.items[0], token);
                // Update the body element, if it doesn't have an end tag
                const bodyElement = p.openElements.items[1];
                if (bodyElement && !((_a = p.treeAdapter.getNodeSourceCodeLocation(bodyElement)) === null || _a === void 0 ? void 0 : _a.endTag)) {
                    p._setEndLocation(bodyElement, token);
                }
            }
        }
        else {
            tokenAfterBody(p, token);
        }
    }
    function tokenAfterBody(p, token) {
        p.insertionMode = InsertionMode.IN_BODY;
        modeInBody(p, token);
    }
    // The "in frameset" insertion mode
    //------------------------------------------------------------------
    function startTagInFrameset(p, token) {
        switch (token.tagID) {
            case TAG_ID.HTML: {
                startTagInBody(p, token);
                break;
            }
            case TAG_ID.FRAMESET: {
                p._insertElement(token, NS.HTML);
                break;
            }
            case TAG_ID.FRAME: {
                p._appendElement(token, NS.HTML);
                token.ackSelfClosing = true;
                break;
            }
            case TAG_ID.NOFRAMES: {
                startTagInHead(p, token);
                break;
            }
            // Do nothing
        }
    }
    function endTagInFrameset(p, token) {
        if (token.tagID === TAG_ID.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {
            p.openElements.pop();
            if (!p.fragmentContext && p.openElements.currentTagId !== TAG_ID.FRAMESET) {
                p.insertionMode = InsertionMode.AFTER_FRAMESET;
            }
        }
    }
    // The "after frameset" insertion mode
    //------------------------------------------------------------------
    function startTagAfterFrameset(p, token) {
        switch (token.tagID) {
            case TAG_ID.HTML: {
                startTagInBody(p, token);
                break;
            }
            case TAG_ID.NOFRAMES: {
                startTagInHead(p, token);
                break;
            }
            // Do nothing
        }
    }
    function endTagAfterFrameset(p, token) {
        if (token.tagID === TAG_ID.HTML) {
            p.insertionMode = InsertionMode.AFTER_AFTER_FRAMESET;
        }
    }
    // The "after after body" insertion mode
    //------------------------------------------------------------------
    function startTagAfterAfterBody(p, token) {
        if (token.tagID === TAG_ID.HTML) {
            startTagInBody(p, token);
        }
        else {
            tokenAfterAfterBody(p, token);
        }
    }
    function tokenAfterAfterBody(p, token) {
        p.insertionMode = InsertionMode.IN_BODY;
        modeInBody(p, token);
    }
    // The "after after frameset" insertion mode
    //------------------------------------------------------------------
    function startTagAfterAfterFrameset(p, token) {
        switch (token.tagID) {
            case TAG_ID.HTML: {
                startTagInBody(p, token);
                break;
            }
            case TAG_ID.NOFRAMES: {
                startTagInHead(p, token);
                break;
            }
            // Do nothing
        }
    }
    // The rules for parsing tokens in foreign content
    //------------------------------------------------------------------
    function nullCharacterInForeignContent(p, token) {
        token.chars = REPLACEMENT_CHARACTER;
        p._insertCharacters(token);
    }
    function characterInForeignContent(p, token) {
        p._insertCharacters(token);
        p.framesetOk = false;
    }
    function popUntilHtmlOrIntegrationPoint(p) {
        while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML &&
            !p._isIntegrationPoint(p.openElements.currentTagId, p.openElements.current)) {
            p.openElements.pop();
        }
    }
    function startTagInForeignContent(p, token) {
        if (causesExit(token)) {
            popUntilHtmlOrIntegrationPoint(p);
            p._startTagOutsideForeignContent(token);
        }
        else {
            const current = p._getAdjustedCurrentElement();
            const currentNs = p.treeAdapter.getNamespaceURI(current);
            if (currentNs === NS.MATHML) {
                adjustTokenMathMLAttrs(token);
            }
            else if (currentNs === NS.SVG) {
                adjustTokenSVGTagName(token);
                adjustTokenSVGAttrs(token);
            }
            adjustTokenXMLAttrs(token);
            if (token.selfClosing) {
                p._appendElement(token, currentNs);
            }
            else {
                p._insertElement(token, currentNs);
            }
            token.ackSelfClosing = true;
        }
    }
    function endTagInForeignContent(p, token) {
        if (token.tagID === TAG_ID.P || token.tagID === TAG_ID.BR) {
            popUntilHtmlOrIntegrationPoint(p);
            p._endTagOutsideForeignContent(token);
            return;
        }
        for (let i = p.openElements.stackTop; i > 0; i--) {
            const element = p.openElements.items[i];
            if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {
                p._endTagOutsideForeignContent(token);
                break;
            }
            const tagName = p.treeAdapter.getTagName(element);
            if (tagName.toLowerCase() === token.tagName) {
                //NOTE: update the token tag name for `_setEndLocation`.
                token.tagName = tagName;
                p.openElements.shortenToLength(i);
                break;
            }
        }
    }

    // Sets
    const VOID_ELEMENTS = new Set([
        TAG_NAMES.AREA,
        TAG_NAMES.BASE,
        TAG_NAMES.BASEFONT,
        TAG_NAMES.BGSOUND,
        TAG_NAMES.BR,
        TAG_NAMES.COL,
        TAG_NAMES.EMBED,
        TAG_NAMES.FRAME,
        TAG_NAMES.HR,
        TAG_NAMES.IMG,
        TAG_NAMES.INPUT,
        TAG_NAMES.KEYGEN,
        TAG_NAMES.LINK,
        TAG_NAMES.META,
        TAG_NAMES.PARAM,
        TAG_NAMES.SOURCE,
        TAG_NAMES.TRACK,
        TAG_NAMES.WBR,
    ]);
    function isVoidElement(node, options) {
        return (options.treeAdapter.isElementNode(node) &&
            options.treeAdapter.getNamespaceURI(node) === NS.HTML &&
            VOID_ELEMENTS.has(options.treeAdapter.getTagName(node)));
    }
    const defaultOpts = { treeAdapter: defaultTreeAdapter, scriptingEnabled: true };
    /**
     * Serializes an AST element node to an HTML string, including the element node.
     *
     * @example
     *
     * ```js
     * const parse5 = require('parse5');
     *
     * const document = parse5.parseFragment('<div>Hello, <b>world</b>!</div>');
     *
     * // Serializes the <div> element.
     * const html = parse5.serializeOuter(document.childNodes[0]);
     *
     * console.log(str); //> '<div>Hello, <b>world</b>!</div>'
     * ```
     *
     * @param node Node to serialize.
     * @param options Serialization options.
     */
    function serializeOuter(node, options) {
        const opts = { ...defaultOpts, ...options };
        return serializeNode(node, opts);
    }
    function serializeChildNodes(parentNode, options) {
        let html = '';
        // Get container of the child nodes
        const container = options.treeAdapter.isElementNode(parentNode) &&
            options.treeAdapter.getTagName(parentNode) === TAG_NAMES.TEMPLATE &&
            options.treeAdapter.getNamespaceURI(parentNode) === NS.HTML
            ? options.treeAdapter.getTemplateContent(parentNode)
            : parentNode;
        const childNodes = options.treeAdapter.getChildNodes(container);
        if (childNodes) {
            for (const currentNode of childNodes) {
                html += serializeNode(currentNode, options);
            }
        }
        return html;
    }
    function serializeNode(node, options) {
        if (options.treeAdapter.isElementNode(node)) {
            return serializeElement(node, options);
        }
        if (options.treeAdapter.isTextNode(node)) {
            return serializeTextNode(node, options);
        }
        if (options.treeAdapter.isCommentNode(node)) {
            return serializeCommentNode(node, options);
        }
        if (options.treeAdapter.isDocumentTypeNode(node)) {
            return serializeDocumentTypeNode(node, options);
        }
        // Return an empty string for unknown nodes
        return '';
    }
    function serializeElement(node, options) {
        const tn = options.treeAdapter.getTagName(node);
        return `<${tn}${serializeAttributes(node, options)}>${isVoidElement(node, options) ? '' : `${serializeChildNodes(node, options)}</${tn}>`}`;
    }
    function serializeAttributes(node, { treeAdapter }) {
        let html = '';
        for (const attr of treeAdapter.getAttrList(node)) {
            html += ' ';
            if (!attr.namespace) {
                html += attr.name;
            }
            else
                switch (attr.namespace) {
                    case NS.XML: {
                        html += `xml:${attr.name}`;
                        break;
                    }
                    case NS.XMLNS: {
                        if (attr.name !== 'xmlns') {
                            html += 'xmlns:';
                        }
                        html += attr.name;
                        break;
                    }
                    case NS.XLINK: {
                        html += `xlink:${attr.name}`;
                        break;
                    }
                    default: {
                        html += `${attr.prefix}:${attr.name}`;
                    }
                }
            html += `="${escapeAttribute(attr.value)}"`;
        }
        return html;
    }
    function serializeTextNode(node, options) {
        const { treeAdapter } = options;
        const content = treeAdapter.getTextNodeContent(node);
        const parent = treeAdapter.getParentNode(node);
        const parentTn = parent && treeAdapter.isElementNode(parent) && treeAdapter.getTagName(parent);
        return parentTn &&
            treeAdapter.getNamespaceURI(parent) === NS.HTML &&
            hasUnescapedText(parentTn, options.scriptingEnabled)
            ? content
            : escapeText(content);
    }
    function serializeCommentNode(node, { treeAdapter }) {
        return `<!--${treeAdapter.getCommentNodeContent(node)}-->`;
    }
    function serializeDocumentTypeNode(node, { treeAdapter }) {
        return `<!DOCTYPE ${treeAdapter.getDocumentTypeNodeName(node)}>`;
    }

    // Shorthands
    /**
     * Parses an HTML string.
     *
     * @param html Input HTML string.
     * @param options Parsing options.
     * @returns Document
     *
     * @example
     *
     * ```js
     * const parse5 = require('parse5');
     *
     * const document = parse5.parse('<!DOCTYPE html><html><head></head><body>Hi there!</body></html>');
     *
     * console.log(document.childNodes[1].tagName); //> 'html'
     *```
     */
    function parse$1(html, options) {
        return Parser$1.parse(html, options);
    }
    function parseFragment(fragmentContext, html, options) {
        if (typeof fragmentContext === 'string') {
            options = html;
            html = fragmentContext;
            fragmentContext = null;
        }
        const parser = Parser$1.getFragmentParser(fragmentContext, options);
        parser.tokenizer.write(html, true);
        return parser.getFragment();
    }

    function createTextNode(value) {
        return new Text(value);
    }
    function enquoteDoctypeId(id) {
        const quote = id.includes('"') ? "'" : '"';
        return quote + id + quote;
    }
    /** @internal */
    function serializeDoctypeContent(name, publicId, systemId) {
        let str = '!DOCTYPE ';
        if (name) {
            str += name;
        }
        if (publicId) {
            str += ` PUBLIC ${enquoteDoctypeId(publicId)}`;
        }
        else if (systemId) {
            str += ' SYSTEM';
        }
        if (systemId) {
            str += ` ${enquoteDoctypeId(systemId)}`;
        }
        return str;
    }
    const adapter = {
        // Re-exports from domhandler
        isCommentNode: isComment,
        isElementNode: isTag,
        isTextNode: isText,
        //Node construction
        createDocument() {
            const node = new Document([]);
            node['x-mode'] = DOCUMENT_MODE.NO_QUIRKS;
            return node;
        },
        createDocumentFragment() {
            return new Document([]);
        },
        createElement(tagName, namespaceURI, attrs) {
            const attribs = Object.create(null);
            const attribsNamespace = Object.create(null);
            const attribsPrefix = Object.create(null);
            for (let i = 0; i < attrs.length; i++) {
                const attrName = attrs[i].name;
                attribs[attrName] = attrs[i].value;
                attribsNamespace[attrName] = attrs[i].namespace;
                attribsPrefix[attrName] = attrs[i].prefix;
            }
            const node = new Element(tagName, attribs, []);
            node.namespace = namespaceURI;
            node['x-attribsNamespace'] = attribsNamespace;
            node['x-attribsPrefix'] = attribsPrefix;
            return node;
        },
        createCommentNode(data) {
            return new Comment(data);
        },
        //Tree mutation
        appendChild(parentNode, newNode) {
            const prev = parentNode.children[parentNode.children.length - 1];
            if (prev) {
                prev.next = newNode;
                newNode.prev = prev;
            }
            parentNode.children.push(newNode);
            newNode.parent = parentNode;
        },
        insertBefore(parentNode, newNode, referenceNode) {
            const insertionIdx = parentNode.children.indexOf(referenceNode);
            const { prev } = referenceNode;
            if (prev) {
                prev.next = newNode;
                newNode.prev = prev;
            }
            referenceNode.prev = newNode;
            newNode.next = referenceNode;
            parentNode.children.splice(insertionIdx, 0, newNode);
            newNode.parent = parentNode;
        },
        setTemplateContent(templateElement, contentElement) {
            adapter.appendChild(templateElement, contentElement);
        },
        getTemplateContent(templateElement) {
            return templateElement.children[0];
        },
        setDocumentType(document, name, publicId, systemId) {
            const data = serializeDoctypeContent(name, publicId, systemId);
            let doctypeNode = document.children.find((node) => isDirective(node) && node.name === '!doctype');
            if (doctypeNode) {
                doctypeNode.data = data !== null && data !== void 0 ? data : null;
            }
            else {
                doctypeNode = new ProcessingInstruction('!doctype', data);
                adapter.appendChild(document, doctypeNode);
            }
            doctypeNode['x-name'] = name !== null && name !== void 0 ? name : undefined;
            doctypeNode['x-publicId'] = publicId !== null && publicId !== void 0 ? publicId : undefined;
            doctypeNode['x-systemId'] = systemId !== null && systemId !== void 0 ? systemId : undefined;
        },
        setDocumentMode(document, mode) {
            document['x-mode'] = mode;
        },
        getDocumentMode(document) {
            return document['x-mode'];
        },
        detachNode(node) {
            if (node.parent) {
                const idx = node.parent.children.indexOf(node);
                const { prev, next } = node;
                node.prev = null;
                node.next = null;
                if (prev) {
                    prev.next = next;
                }
                if (next) {
                    next.prev = prev;
                }
                node.parent.children.splice(idx, 1);
                node.parent = null;
            }
        },
        insertText(parentNode, text) {
            const lastChild = parentNode.children[parentNode.children.length - 1];
            if (lastChild && isText(lastChild)) {
                lastChild.data += text;
            }
            else {
                adapter.appendChild(parentNode, createTextNode(text));
            }
        },
        insertTextBefore(parentNode, text, referenceNode) {
            const prevNode = parentNode.children[parentNode.children.indexOf(referenceNode) - 1];
            if (prevNode && isText(prevNode)) {
                prevNode.data += text;
            }
            else {
                adapter.insertBefore(parentNode, createTextNode(text), referenceNode);
            }
        },
        adoptAttributes(recipient, attrs) {
            for (let i = 0; i < attrs.length; i++) {
                const attrName = attrs[i].name;
                if (typeof recipient.attribs[attrName] === 'undefined') {
                    recipient.attribs[attrName] = attrs[i].value;
                    recipient['x-attribsNamespace'][attrName] = attrs[i].namespace;
                    recipient['x-attribsPrefix'][attrName] = attrs[i].prefix;
                }
            }
        },
        //Tree traversing
        getFirstChild(node) {
            return node.children[0];
        },
        getChildNodes(node) {
            return node.children;
        },
        getParentNode(node) {
            return node.parent;
        },
        getAttrList(element) {
            return element.attributes;
        },
        //Node data
        getTagName(element) {
            return element.name;
        },
        getNamespaceURI(element) {
            return element.namespace;
        },
        getTextNodeContent(textNode) {
            return textNode.data;
        },
        getCommentNodeContent(commentNode) {
            return commentNode.data;
        },
        getDocumentTypeNodeName(doctypeNode) {
            var _a;
            return (_a = doctypeNode['x-name']) !== null && _a !== void 0 ? _a : '';
        },
        getDocumentTypeNodePublicId(doctypeNode) {
            var _a;
            return (_a = doctypeNode['x-publicId']) !== null && _a !== void 0 ? _a : '';
        },
        getDocumentTypeNodeSystemId(doctypeNode) {
            var _a;
            return (_a = doctypeNode['x-systemId']) !== null && _a !== void 0 ? _a : '';
        },
        //Node types
        isDocumentTypeNode(node) {
            return isDirective(node) && node.name === '!doctype';
        },
        // Source code location
        setNodeSourceCodeLocation(node, location) {
            if (location) {
                node.startIndex = location.startOffset;
                node.endIndex = location.endOffset;
            }
            node.sourceCodeLocation = location;
        },
        getNodeSourceCodeLocation(node) {
            return node.sourceCodeLocation;
        },
        updateNodeSourceCodeLocation(node, endLocation) {
            if (endLocation.endOffset != null)
                node.endIndex = endLocation.endOffset;
            node.sourceCodeLocation = {
                ...node.sourceCodeLocation,
                ...endLocation,
            };
        },
    };

    /**
     * Parse the content with `parse5` in the context of the given `ParentNode`.
     *
     * @param content - The content to parse.
     * @param options - A set of options to use to parse.
     * @param isDocument - Whether to parse the content as a full HTML document.
     * @param context - The context in which to parse the content.
     * @returns The parsed content.
     */
    function parseWithParse5(content, options, isDocument, context) {
        const opts = {
            scriptingEnabled: typeof options.scriptingEnabled === 'boolean'
                ? options.scriptingEnabled
                : true,
            treeAdapter: adapter,
            sourceCodeLocationInfo: options.sourceCodeLocationInfo,
        };
        return isDocument
            ? parse$1(content, opts)
            : parseFragment(context, content, opts);
    }
    const renderOpts = { treeAdapter: adapter };
    /**
     * Renders the given DOM tree with `parse5` and returns the result as a string.
     *
     * @param dom - The DOM tree to render.
     * @returns The rendered document.
     */
    function renderWithParse5(dom) {
        /*
         * `dom-serializer` passes over the special "root" node and renders the
         * node's children in its place. To mimic this behavior with `parse5`, an
         * equivalent operation must be applied to the input array.
         */
        const nodes = 'length' in dom ? dom : [dom];
        for (let index = 0; index < nodes.length; index += 1) {
            const node = nodes[index];
            if (isDocument(node)) {
                Array.prototype.splice.call(nodes, index, 1, ...node.children);
            }
        }
        let result = '';
        for (let index = 0; index < nodes.length; index += 1) {
            const node = nodes[index];
            result += serializeOuter(node, renderOpts);
        }
        return result;
    }

    var CharCodes;
    (function (CharCodes) {
        CharCodes[CharCodes["Tab"] = 9] = "Tab";
        CharCodes[CharCodes["NewLine"] = 10] = "NewLine";
        CharCodes[CharCodes["FormFeed"] = 12] = "FormFeed";
        CharCodes[CharCodes["CarriageReturn"] = 13] = "CarriageReturn";
        CharCodes[CharCodes["Space"] = 32] = "Space";
        CharCodes[CharCodes["ExclamationMark"] = 33] = "ExclamationMark";
        CharCodes[CharCodes["Num"] = 35] = "Num";
        CharCodes[CharCodes["Amp"] = 38] = "Amp";
        CharCodes[CharCodes["SingleQuote"] = 39] = "SingleQuote";
        CharCodes[CharCodes["DoubleQuote"] = 34] = "DoubleQuote";
        CharCodes[CharCodes["Dash"] = 45] = "Dash";
        CharCodes[CharCodes["Slash"] = 47] = "Slash";
        CharCodes[CharCodes["Zero"] = 48] = "Zero";
        CharCodes[CharCodes["Nine"] = 57] = "Nine";
        CharCodes[CharCodes["Semi"] = 59] = "Semi";
        CharCodes[CharCodes["Lt"] = 60] = "Lt";
        CharCodes[CharCodes["Eq"] = 61] = "Eq";
        CharCodes[CharCodes["Gt"] = 62] = "Gt";
        CharCodes[CharCodes["Questionmark"] = 63] = "Questionmark";
        CharCodes[CharCodes["UpperA"] = 65] = "UpperA";
        CharCodes[CharCodes["LowerA"] = 97] = "LowerA";
        CharCodes[CharCodes["UpperF"] = 70] = "UpperF";
        CharCodes[CharCodes["LowerF"] = 102] = "LowerF";
        CharCodes[CharCodes["UpperZ"] = 90] = "UpperZ";
        CharCodes[CharCodes["LowerZ"] = 122] = "LowerZ";
        CharCodes[CharCodes["LowerX"] = 120] = "LowerX";
        CharCodes[CharCodes["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
    })(CharCodes || (CharCodes = {}));
    /** All the states the tokenizer can be in. */
    var State;
    (function (State) {
        State[State["Text"] = 1] = "Text";
        State[State["BeforeTagName"] = 2] = "BeforeTagName";
        State[State["InTagName"] = 3] = "InTagName";
        State[State["InSelfClosingTag"] = 4] = "InSelfClosingTag";
        State[State["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
        State[State["InClosingTagName"] = 6] = "InClosingTagName";
        State[State["AfterClosingTagName"] = 7] = "AfterClosingTagName";
        // Attributes
        State[State["BeforeAttributeName"] = 8] = "BeforeAttributeName";
        State[State["InAttributeName"] = 9] = "InAttributeName";
        State[State["AfterAttributeName"] = 10] = "AfterAttributeName";
        State[State["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
        State[State["InAttributeValueDq"] = 12] = "InAttributeValueDq";
        State[State["InAttributeValueSq"] = 13] = "InAttributeValueSq";
        State[State["InAttributeValueNq"] = 14] = "InAttributeValueNq";
        // Declarations
        State[State["BeforeDeclaration"] = 15] = "BeforeDeclaration";
        State[State["InDeclaration"] = 16] = "InDeclaration";
        // Processing instructions
        State[State["InProcessingInstruction"] = 17] = "InProcessingInstruction";
        // Comments & CDATA
        State[State["BeforeComment"] = 18] = "BeforeComment";
        State[State["CDATASequence"] = 19] = "CDATASequence";
        State[State["InSpecialComment"] = 20] = "InSpecialComment";
        State[State["InCommentLike"] = 21] = "InCommentLike";
        // Special tags
        State[State["BeforeSpecialS"] = 22] = "BeforeSpecialS";
        State[State["SpecialStartSequence"] = 23] = "SpecialStartSequence";
        State[State["InSpecialTag"] = 24] = "InSpecialTag";
        State[State["BeforeEntity"] = 25] = "BeforeEntity";
        State[State["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
        State[State["InNamedEntity"] = 27] = "InNamedEntity";
        State[State["InNumericEntity"] = 28] = "InNumericEntity";
        State[State["InHexEntity"] = 29] = "InHexEntity";
    })(State || (State = {}));
    function isWhitespace(c) {
        return (c === CharCodes.Space ||
            c === CharCodes.NewLine ||
            c === CharCodes.Tab ||
            c === CharCodes.FormFeed ||
            c === CharCodes.CarriageReturn);
    }
    function isEndOfTagSection(c) {
        return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
    }
    function isNumber(c) {
        return c >= CharCodes.Zero && c <= CharCodes.Nine;
    }
    function isASCIIAlpha(c) {
        return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||
            (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));
    }
    function isHexDigit(c) {
        return ((c >= CharCodes.UpperA && c <= CharCodes.UpperF) ||
            (c >= CharCodes.LowerA && c <= CharCodes.LowerF));
    }
    var QuoteType;
    (function (QuoteType) {
        QuoteType[QuoteType["NoValue"] = 0] = "NoValue";
        QuoteType[QuoteType["Unquoted"] = 1] = "Unquoted";
        QuoteType[QuoteType["Single"] = 2] = "Single";
        QuoteType[QuoteType["Double"] = 3] = "Double";
    })(QuoteType || (QuoteType = {}));
    /**
     * Sequences used to match longer strings.
     *
     * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End
     * sequences with an increased offset.
     */
    const Sequences = {
        Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),
        CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]),
        CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]),
        ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),
        StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),
        TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`
    };
    class Tokenizer {
        constructor({ xmlMode = false, decodeEntities = true, }, cbs) {
            this.cbs = cbs;
            /** The current state the tokenizer is in. */
            this.state = State.Text;
            /** The read buffer. */
            this.buffer = "";
            /** The beginning of the section that is currently being read. */
            this.sectionStart = 0;
            /** The index within the buffer that we are currently looking at. */
            this.index = 0;
            /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
            this.baseState = State.Text;
            /** For special parsing behavior inside of script and style tags. */
            this.isSpecial = false;
            /** Indicates whether the tokenizer has been paused. */
            this.running = true;
            /** The offset of the current buffer. */
            this.offset = 0;
            this.sequenceIndex = 0;
            this.trieIndex = 0;
            this.trieCurrent = 0;
            /** For named entities, the index of the value. For numeric entities, the code point. */
            this.entityResult = 0;
            this.entityExcess = 0;
            this.xmlMode = xmlMode;
            this.decodeEntities = decodeEntities;
            this.entityTrie = xmlMode ? xmlDecodeTree : htmlDecodeTree;
        }
        reset() {
            this.state = State.Text;
            this.buffer = "";
            this.sectionStart = 0;
            this.index = 0;
            this.baseState = State.Text;
            this.currentSequence = undefined;
            this.running = true;
            this.offset = 0;
        }
        write(chunk) {
            this.offset += this.buffer.length;
            this.buffer = chunk;
            this.parse();
        }
        end() {
            if (this.running)
                this.finish();
        }
        pause() {
            this.running = false;
        }
        resume() {
            this.running = true;
            if (this.index < this.buffer.length + this.offset) {
                this.parse();
            }
        }
        /**
         * The current index within all of the written data.
         */
        getIndex() {
            return this.index;
        }
        /**
         * The start of the current section.
         */
        getSectionStart() {
            return this.sectionStart;
        }
        stateText(c) {
            if (c === CharCodes.Lt ||
                (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {
                if (this.index > this.sectionStart) {
                    this.cbs.ontext(this.sectionStart, this.index);
                }
                this.state = State.BeforeTagName;
                this.sectionStart = this.index;
            }
            else if (this.decodeEntities && c === CharCodes.Amp) {
                this.state = State.BeforeEntity;
            }
        }
        stateSpecialStartSequence(c) {
            const isEnd = this.sequenceIndex === this.currentSequence.length;
            const isMatch = isEnd
                ? // If we are at the end of the sequence, make sure the tag name has ended
                    isEndOfTagSection(c)
                : // Otherwise, do a case-insensitive comparison
                    (c | 0x20) === this.currentSequence[this.sequenceIndex];
            if (!isMatch) {
                this.isSpecial = false;
            }
            else if (!isEnd) {
                this.sequenceIndex++;
                return;
            }
            this.sequenceIndex = 0;
            this.state = State.InTagName;
            this.stateInTagName(c);
        }
        /** Look for an end tag. For <title> tags, also decode entities. */
        stateInSpecialTag(c) {
            if (this.sequenceIndex === this.currentSequence.length) {
                if (c === CharCodes.Gt || isWhitespace(c)) {
                    const endOfText = this.index - this.currentSequence.length;
                    if (this.sectionStart < endOfText) {
                        // Spoof the index so that reported locations match up.
                        const actualIndex = this.index;
                        this.index = endOfText;
                        this.cbs.ontext(this.sectionStart, endOfText);
                        this.index = actualIndex;
                    }
                    this.isSpecial = false;
                    this.sectionStart = endOfText + 2; // Skip over the `</`
                    this.stateInClosingTagName(c);
                    return; // We are done; skip the rest of the function.
                }
                this.sequenceIndex = 0;
            }
            if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {
                this.sequenceIndex += 1;
            }
            else if (this.sequenceIndex === 0) {
                if (this.currentSequence === Sequences.TitleEnd) {
                    // We have to parse entities in <title> tags.
                    if (this.decodeEntities && c === CharCodes.Amp) {
                        this.state = State.BeforeEntity;
                    }
                }
                else if (this.fastForwardTo(CharCodes.Lt)) {
                    // Outside of <title> tags, we can fast-forward.
                    this.sequenceIndex = 1;
                }
            }
            else {
                // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.
                this.sequenceIndex = Number(c === CharCodes.Lt);
            }
        }
        stateCDATASequence(c) {
            if (c === Sequences.Cdata[this.sequenceIndex]) {
                if (++this.sequenceIndex === Sequences.Cdata.length) {
                    this.state = State.InCommentLike;
                    this.currentSequence = Sequences.CdataEnd;
                    this.sequenceIndex = 0;
                    this.sectionStart = this.index + 1;
                }
            }
            else {
                this.sequenceIndex = 0;
                this.state = State.InDeclaration;
                this.stateInDeclaration(c); // Reconsume the character
            }
        }
        /**
         * When we wait for one specific character, we can speed things up
         * by skipping through the buffer until we find it.
         *
         * @returns Whether the character was found.
         */
        fastForwardTo(c) {
            while (++this.index < this.buffer.length + this.offset) {
                if (this.buffer.charCodeAt(this.index - this.offset) === c) {
                    return true;
                }
            }
            /*
             * We increment the index at the end of the `parse` loop,
             * so set it to `buffer.length - 1` here.
             *
             * TODO: Refactor `parse` to increment index before calling states.
             */
            this.index = this.buffer.length + this.offset - 1;
            return false;
        }
        /**
         * Comments and CDATA end with `-->` and `]]>`.
         *
         * Their common qualities are:
         * - Their end sequences have a distinct character they start with.
         * - That character is then repeated, so we have to check multiple repeats.
         * - All characters but the start character of the sequence can be skipped.
         */
        stateInCommentLike(c) {
            if (c === this.currentSequence[this.sequenceIndex]) {
                if (++this.sequenceIndex === this.currentSequence.length) {
                    if (this.currentSequence === Sequences.CdataEnd) {
                        this.cbs.oncdata(this.sectionStart, this.index, 2);
                    }
                    else {
                        this.cbs.oncomment(this.sectionStart, this.index, 2);
                    }
                    this.sequenceIndex = 0;
                    this.sectionStart = this.index + 1;
                    this.state = State.Text;
                }
            }
            else if (this.sequenceIndex === 0) {
                // Fast-forward to the first character of the sequence
                if (this.fastForwardTo(this.currentSequence[0])) {
                    this.sequenceIndex = 1;
                }
            }
            else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
                // Allow long sequences, eg. --->, ]]]>
                this.sequenceIndex = 0;
            }
        }
        /**
         * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
         *
         * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
         * We allow anything that wouldn't end the tag.
         */
        isTagStartChar(c) {
            return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
        }
        startSpecial(sequence, offset) {
            this.isSpecial = true;
            this.currentSequence = sequence;
            this.sequenceIndex = offset;
            this.state = State.SpecialStartSequence;
        }
        stateBeforeTagName(c) {
            if (c === CharCodes.ExclamationMark) {
                this.state = State.BeforeDeclaration;
                this.sectionStart = this.index + 1;
            }
            else if (c === CharCodes.Questionmark) {
                this.state = State.InProcessingInstruction;
                this.sectionStart = this.index + 1;
            }
            else if (this.isTagStartChar(c)) {
                const lower = c | 0x20;
                this.sectionStart = this.index;
                if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
                    this.startSpecial(Sequences.TitleEnd, 3);
                }
                else {
                    this.state =
                        !this.xmlMode && lower === Sequences.ScriptEnd[2]
                            ? State.BeforeSpecialS
                            : State.InTagName;
                }
            }
            else if (c === CharCodes.Slash) {
                this.state = State.BeforeClosingTagName;
            }
            else {
                this.state = State.Text;
                this.stateText(c);
            }
        }
        stateInTagName(c) {
            if (isEndOfTagSection(c)) {
                this.cbs.onopentagname(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.state = State.BeforeAttributeName;
                this.stateBeforeAttributeName(c);
            }
        }
        stateBeforeClosingTagName(c) {
            if (isWhitespace(c)) ;
            else if (c === CharCodes.Gt) {
                this.state = State.Text;
            }
            else {
                this.state = this.isTagStartChar(c)
                    ? State.InClosingTagName
                    : State.InSpecialComment;
                this.sectionStart = this.index;
            }
        }
        stateInClosingTagName(c) {
            if (c === CharCodes.Gt || isWhitespace(c)) {
                this.cbs.onclosetag(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.state = State.AfterClosingTagName;
                this.stateAfterClosingTagName(c);
            }
        }
        stateAfterClosingTagName(c) {
            // Skip everything until ">"
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
                this.state = State.Text;
                this.sectionStart = this.index + 1;
            }
        }
        stateBeforeAttributeName(c) {
            if (c === CharCodes.Gt) {
                this.cbs.onopentagend(this.index);
                if (this.isSpecial) {
                    this.state = State.InSpecialTag;
                    this.sequenceIndex = 0;
                }
                else {
                    this.state = State.Text;
                }
                this.baseState = this.state;
                this.sectionStart = this.index + 1;
            }
            else if (c === CharCodes.Slash) {
                this.state = State.InSelfClosingTag;
            }
            else if (!isWhitespace(c)) {
                this.state = State.InAttributeName;
                this.sectionStart = this.index;
            }
        }
        stateInSelfClosingTag(c) {
            if (c === CharCodes.Gt) {
                this.cbs.onselfclosingtag(this.index);
                this.state = State.Text;
                this.baseState = State.Text;
                this.sectionStart = this.index + 1;
                this.isSpecial = false; // Reset special state, in case of self-closing special tags
            }
            else if (!isWhitespace(c)) {
                this.state = State.BeforeAttributeName;
                this.stateBeforeAttributeName(c);
            }
        }
        stateInAttributeName(c) {
            if (c === CharCodes.Eq || isEndOfTagSection(c)) {
                this.cbs.onattribname(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.state = State.AfterAttributeName;
                this.stateAfterAttributeName(c);
            }
        }
        stateAfterAttributeName(c) {
            if (c === CharCodes.Eq) {
                this.state = State.BeforeAttributeValue;
            }
            else if (c === CharCodes.Slash || c === CharCodes.Gt) {
                this.cbs.onattribend(QuoteType.NoValue, this.index);
                this.state = State.BeforeAttributeName;
                this.stateBeforeAttributeName(c);
            }
            else if (!isWhitespace(c)) {
                this.cbs.onattribend(QuoteType.NoValue, this.index);
                this.state = State.InAttributeName;
                this.sectionStart = this.index;
            }
        }
        stateBeforeAttributeValue(c) {
            if (c === CharCodes.DoubleQuote) {
                this.state = State.InAttributeValueDq;
                this.sectionStart = this.index + 1;
            }
            else if (c === CharCodes.SingleQuote) {
                this.state = State.InAttributeValueSq;
                this.sectionStart = this.index + 1;
            }
            else if (!isWhitespace(c)) {
                this.sectionStart = this.index;
                this.state = State.InAttributeValueNq;
                this.stateInAttributeValueNoQuotes(c); // Reconsume token
            }
        }
        handleInAttributeValue(c, quote) {
            if (c === quote ||
                (!this.decodeEntities && this.fastForwardTo(quote))) {
                this.cbs.onattribdata(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.cbs.onattribend(quote === CharCodes.DoubleQuote
                    ? QuoteType.Double
                    : QuoteType.Single, this.index);
                this.state = State.BeforeAttributeName;
            }
            else if (this.decodeEntities && c === CharCodes.Amp) {
                this.baseState = this.state;
                this.state = State.BeforeEntity;
            }
        }
        stateInAttributeValueDoubleQuotes(c) {
            this.handleInAttributeValue(c, CharCodes.DoubleQuote);
        }
        stateInAttributeValueSingleQuotes(c) {
            this.handleInAttributeValue(c, CharCodes.SingleQuote);
        }
        stateInAttributeValueNoQuotes(c) {
            if (isWhitespace(c) || c === CharCodes.Gt) {
                this.cbs.onattribdata(this.sectionStart, this.index);
                this.sectionStart = -1;
                this.cbs.onattribend(QuoteType.Unquoted, this.index);
                this.state = State.BeforeAttributeName;
                this.stateBeforeAttributeName(c);
            }
            else if (this.decodeEntities && c === CharCodes.Amp) {
                this.baseState = this.state;
                this.state = State.BeforeEntity;
            }
        }
        stateBeforeDeclaration(c) {
            if (c === CharCodes.OpeningSquareBracket) {
                this.state = State.CDATASequence;
                this.sequenceIndex = 0;
            }
            else {
                this.state =
                    c === CharCodes.Dash
                        ? State.BeforeComment
                        : State.InDeclaration;
            }
        }
        stateInDeclaration(c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
                this.cbs.ondeclaration(this.sectionStart, this.index);
                this.state = State.Text;
                this.sectionStart = this.index + 1;
            }
        }
        stateInProcessingInstruction(c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
                this.cbs.onprocessinginstruction(this.sectionStart, this.index);
                this.state = State.Text;
                this.sectionStart = this.index + 1;
            }
        }
        stateBeforeComment(c) {
            if (c === CharCodes.Dash) {
                this.state = State.InCommentLike;
                this.currentSequence = Sequences.CommentEnd;
                // Allow short comments (eg. <!-->)
                this.sequenceIndex = 2;
                this.sectionStart = this.index + 1;
            }
            else {
                this.state = State.InDeclaration;
            }
        }
        stateInSpecialComment(c) {
            if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
                this.cbs.oncomment(this.sectionStart, this.index, 0);
                this.state = State.Text;
                this.sectionStart = this.index + 1;
            }
        }
        stateBeforeSpecialS(c) {
            const lower = c | 0x20;
            if (lower === Sequences.ScriptEnd[3]) {
                this.startSpecial(Sequences.ScriptEnd, 4);
            }
            else if (lower === Sequences.StyleEnd[3]) {
                this.startSpecial(Sequences.StyleEnd, 4);
            }
            else {
                this.state = State.InTagName;
                this.stateInTagName(c); // Consume the token again
            }
        }
        stateBeforeEntity(c) {
            // Start excess with 1 to include the '&'
            this.entityExcess = 1;
            this.entityResult = 0;
            if (c === CharCodes.Num) {
                this.state = State.BeforeNumericEntity;
            }
            else if (c === CharCodes.Amp) ;
            else {
                this.trieIndex = 0;
                this.trieCurrent = this.entityTrie[0];
                this.state = State.InNamedEntity;
                this.stateInNamedEntity(c);
            }
        }
        stateInNamedEntity(c) {
            this.entityExcess += 1;
            this.trieIndex = determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
            if (this.trieIndex < 0) {
                this.emitNamedEntity();
                this.index--;
                return;
            }
            this.trieCurrent = this.entityTrie[this.trieIndex];
            const masked = this.trieCurrent & BinTrieFlags.VALUE_LENGTH;
            // If the branch is a value, store it and continue
            if (masked) {
                // The mask is the number of bytes of the value, including the current byte.
                const valueLength = (masked >> 14) - 1;
                // If we have a legacy entity while parsing strictly, just skip the number of bytes
                if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
                    this.trieIndex += valueLength;
                }
                else {
                    // Add 1 as we have already incremented the excess
                    const entityStart = this.index - this.entityExcess + 1;
                    if (entityStart > this.sectionStart) {
                        this.emitPartial(this.sectionStart, entityStart);
                    }
                    // If this is a surrogate pair, consume the next two bytes
                    this.entityResult = this.trieIndex;
                    this.trieIndex += valueLength;
                    this.entityExcess = 0;
                    this.sectionStart = this.index + 1;
                    if (valueLength === 0) {
                        this.emitNamedEntity();
                    }
                }
            }
        }
        emitNamedEntity() {
            this.state = this.baseState;
            if (this.entityResult === 0) {
                return;
            }
            const valueLength = (this.entityTrie[this.entityResult] & BinTrieFlags.VALUE_LENGTH) >>
                14;
            switch (valueLength) {
                case 1:
                    this.emitCodePoint(this.entityTrie[this.entityResult] &
                        ~BinTrieFlags.VALUE_LENGTH);
                    break;
                case 2:
                    this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                    break;
                case 3: {
                    this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
                    this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
                }
            }
        }
        stateBeforeNumericEntity(c) {
            if ((c | 0x20) === CharCodes.LowerX) {
                this.entityExcess++;
                this.state = State.InHexEntity;
            }
            else {
                this.state = State.InNumericEntity;
                this.stateInNumericEntity(c);
            }
        }
        emitNumericEntity(strict) {
            const entityStart = this.index - this.entityExcess - 1;
            const numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
            if (numberStart !== this.index) {
                // Emit leading data if any
                if (entityStart > this.sectionStart) {
                    this.emitPartial(this.sectionStart, entityStart);
                }
                this.sectionStart = this.index + Number(strict);
                this.emitCodePoint(replaceCodePoint(this.entityResult));
            }
            this.state = this.baseState;
        }
        stateInNumericEntity(c) {
            if (c === CharCodes.Semi) {
                this.emitNumericEntity(true);
            }
            else if (isNumber(c)) {
                this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
                this.entityExcess++;
            }
            else {
                if (this.allowLegacyEntity()) {
                    this.emitNumericEntity(false);
                }
                else {
                    this.state = this.baseState;
                }
                this.index--;
            }
        }
        stateInHexEntity(c) {
            if (c === CharCodes.Semi) {
                this.emitNumericEntity(true);
            }
            else if (isNumber(c)) {
                this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
                this.entityExcess++;
            }
            else if (isHexDigit(c)) {
                this.entityResult =
                    this.entityResult * 16 + ((c | 0x20) - CharCodes.LowerA + 10);
                this.entityExcess++;
            }
            else {
                if (this.allowLegacyEntity()) {
                    this.emitNumericEntity(false);
                }
                else {
                    this.state = this.baseState;
                }
                this.index--;
            }
        }
        allowLegacyEntity() {
            return (!this.xmlMode &&
                (this.baseState === State.Text ||
                    this.baseState === State.InSpecialTag));
        }
        /**
         * Remove data that has already been consumed from the buffer.
         */
        cleanup() {
            // If we are inside of text or attributes, emit what we already have.
            if (this.running && this.sectionStart !== this.index) {
                if (this.state === State.Text ||
                    (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {
                    this.cbs.ontext(this.sectionStart, this.index);
                    this.sectionStart = this.index;
                }
                else if (this.state === State.InAttributeValueDq ||
                    this.state === State.InAttributeValueSq ||
                    this.state === State.InAttributeValueNq) {
                    this.cbs.onattribdata(this.sectionStart, this.index);
                    this.sectionStart = this.index;
                }
            }
        }
        shouldContinue() {
            return this.index < this.buffer.length + this.offset && this.running;
        }
        /**
         * Iterates through the buffer, calling the function corresponding to the current state.
         *
         * States that are more likely to be hit are higher up, as a performance improvement.
         */
        parse() {
            while (this.shouldContinue()) {
                const c = this.buffer.charCodeAt(this.index - this.offset);
                if (this.state === State.Text) {
                    this.stateText(c);
                }
                else if (this.state === State.SpecialStartSequence) {
                    this.stateSpecialStartSequence(c);
                }
                else if (this.state === State.InSpecialTag) {
                    this.stateInSpecialTag(c);
                }
                else if (this.state === State.CDATASequence) {
                    this.stateCDATASequence(c);
                }
                else if (this.state === State.InAttributeValueDq) {
                    this.stateInAttributeValueDoubleQuotes(c);
                }
                else if (this.state === State.InAttributeName) {
                    this.stateInAttributeName(c);
                }
                else if (this.state === State.InCommentLike) {
                    this.stateInCommentLike(c);
                }
                else if (this.state === State.InSpecialComment) {
                    this.stateInSpecialComment(c);
                }
                else if (this.state === State.BeforeAttributeName) {
                    this.stateBeforeAttributeName(c);
                }
                else if (this.state === State.InTagName) {
                    this.stateInTagName(c);
                }
                else if (this.state === State.InClosingTagName) {
                    this.stateInClosingTagName(c);
                }
                else if (this.state === State.BeforeTagName) {
                    this.stateBeforeTagName(c);
                }
                else if (this.state === State.AfterAttributeName) {
                    this.stateAfterAttributeName(c);
                }
                else if (this.state === State.InAttributeValueSq) {
                    this.stateInAttributeValueSingleQuotes(c);
                }
                else if (this.state === State.BeforeAttributeValue) {
                    this.stateBeforeAttributeValue(c);
                }
                else if (this.state === State.BeforeClosingTagName) {
                    this.stateBeforeClosingTagName(c);
                }
                else if (this.state === State.AfterClosingTagName) {
                    this.stateAfterClosingTagName(c);
                }
                else if (this.state === State.BeforeSpecialS) {
                    this.stateBeforeSpecialS(c);
                }
                else if (this.state === State.InAttributeValueNq) {
                    this.stateInAttributeValueNoQuotes(c);
                }
                else if (this.state === State.InSelfClosingTag) {
                    this.stateInSelfClosingTag(c);
                }
                else if (this.state === State.InDeclaration) {
                    this.stateInDeclaration(c);
                }
                else if (this.state === State.BeforeDeclaration) {
                    this.stateBeforeDeclaration(c);
                }
                else if (this.state === State.BeforeComment) {
                    this.stateBeforeComment(c);
                }
                else if (this.state === State.InProcessingInstruction) {
                    this.stateInProcessingInstruction(c);
                }
                else if (this.state === State.InNamedEntity) {
                    this.stateInNamedEntity(c);
                }
                else if (this.state === State.BeforeEntity) {
                    this.stateBeforeEntity(c);
                }
                else if (this.state === State.InHexEntity) {
                    this.stateInHexEntity(c);
                }
                else if (this.state === State.InNumericEntity) {
                    this.stateInNumericEntity(c);
                }
                else {
                    // `this._state === State.BeforeNumericEntity`
                    this.stateBeforeNumericEntity(c);
                }
                this.index++;
            }
            this.cleanup();
        }
        finish() {
            if (this.state === State.InNamedEntity) {
                this.emitNamedEntity();
            }
            // If there is remaining data, emit it in a reasonable way
            if (this.sectionStart < this.index) {
                this.handleTrailingData();
            }
            this.cbs.onend();
        }
        /** Handle any trailing data. */
        handleTrailingData() {
            const endIndex = this.buffer.length + this.offset;
            if (this.state === State.InCommentLike) {
                if (this.currentSequence === Sequences.CdataEnd) {
                    this.cbs.oncdata(this.sectionStart, endIndex, 0);
                }
                else {
                    this.cbs.oncomment(this.sectionStart, endIndex, 0);
                }
            }
            else if (this.state === State.InNumericEntity &&
                this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
                // All trailing data will have been consumed
            }
            else if (this.state === State.InHexEntity &&
                this.allowLegacyEntity()) {
                this.emitNumericEntity(false);
                // All trailing data will have been consumed
            }
            else if (this.state === State.InTagName ||
                this.state === State.BeforeAttributeName ||
                this.state === State.BeforeAttributeValue ||
                this.state === State.AfterAttributeName ||
                this.state === State.InAttributeName ||
                this.state === State.InAttributeValueSq ||
                this.state === State.InAttributeValueDq ||
                this.state === State.InAttributeValueNq ||
                this.state === State.InClosingTagName) ;
            else {
                this.cbs.ontext(this.sectionStart, endIndex);
            }
        }
        emitPartial(start, endIndex) {
            if (this.baseState !== State.Text &&
                this.baseState !== State.InSpecialTag) {
                this.cbs.onattribdata(start, endIndex);
            }
            else {
                this.cbs.ontext(start, endIndex);
            }
        }
        emitCodePoint(cp) {
            if (this.baseState !== State.Text &&
                this.baseState !== State.InSpecialTag) {
                this.cbs.onattribentity(cp);
            }
            else {
                this.cbs.ontextentity(cp);
            }
        }
    }

    const formTags = new Set([
        "input",
        "option",
        "optgroup",
        "select",
        "button",
        "datalist",
        "textarea",
    ]);
    const pTag = new Set(["p"]);
    const tableSectionTags = new Set(["thead", "tbody"]);
    const ddtTags = new Set(["dd", "dt"]);
    const rtpTags = new Set(["rt", "rp"]);
    const openImpliesClose = new Map([
        ["tr", new Set(["tr", "th", "td"])],
        ["th", new Set(["th"])],
        ["td", new Set(["thead", "th", "td"])],
        ["body", new Set(["head", "link", "script"])],
        ["li", new Set(["li"])],
        ["p", pTag],
        ["h1", pTag],
        ["h2", pTag],
        ["h3", pTag],
        ["h4", pTag],
        ["h5", pTag],
        ["h6", pTag],
        ["select", formTags],
        ["input", formTags],
        ["output", formTags],
        ["button", formTags],
        ["datalist", formTags],
        ["textarea", formTags],
        ["option", new Set(["option"])],
        ["optgroup", new Set(["optgroup", "option"])],
        ["dd", ddtTags],
        ["dt", ddtTags],
        ["address", pTag],
        ["article", pTag],
        ["aside", pTag],
        ["blockquote", pTag],
        ["details", pTag],
        ["div", pTag],
        ["dl", pTag],
        ["fieldset", pTag],
        ["figcaption", pTag],
        ["figure", pTag],
        ["footer", pTag],
        ["form", pTag],
        ["header", pTag],
        ["hr", pTag],
        ["main", pTag],
        ["nav", pTag],
        ["ol", pTag],
        ["pre", pTag],
        ["section", pTag],
        ["table", pTag],
        ["ul", pTag],
        ["rt", rtpTags],
        ["rp", rtpTags],
        ["tbody", tableSectionTags],
        ["tfoot", tableSectionTags],
    ]);
    const voidElements = new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr",
    ]);
    const foreignContextElements = new Set(["math", "svg"]);
    const htmlIntegrationElements = new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignobject",
        "desc",
        "title",
    ]);
    const reNameEnd = /\s|\//;
    class Parser {
        constructor(cbs, options = {}) {
            var _a, _b, _c, _d, _e;
            this.options = options;
            /** The start index of the last event. */
            this.startIndex = 0;
            /** The end index of the last event. */
            this.endIndex = 0;
            /**
             * Store the start index of the current open tag,
             * so we can update the start index for attributes.
             */
            this.openTagStart = 0;
            this.tagname = "";
            this.attribname = "";
            this.attribvalue = "";
            this.attribs = null;
            this.stack = [];
            this.foreignContext = [];
            this.buffers = [];
            this.bufferOffset = 0;
            /** The index of the last written buffer. Used when resuming after a `pause()`. */
            this.writeIndex = 0;
            /** Indicates whether the parser has finished running / `.end` has been called. */
            this.ended = false;
            this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
            this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
            this.lowerCaseAttributeNames =
                (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
            this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer)(this.options, this);
            (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        }
        // Tokenizer event handlers
        /** @internal */
        ontext(start, endIndex) {
            var _a, _b;
            const data = this.getSlice(start, endIndex);
            this.endIndex = endIndex - 1;
            (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
            this.startIndex = endIndex;
        }
        /** @internal */
        ontextentity(cp) {
            var _a, _b;
            /*
             * Entities can be emitted on the character, or directly after.
             * We use the section start here to get accurate indices.
             */
            const idx = this.tokenizer.getSectionStart();
            this.endIndex = idx - 1;
            (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, fromCodePoint(cp));
            this.startIndex = idx;
        }
        isVoidElement(name) {
            return !this.options.xmlMode && voidElements.has(name);
        }
        /** @internal */
        onopentagname(start, endIndex) {
            this.endIndex = endIndex;
            let name = this.getSlice(start, endIndex);
            if (this.lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            this.emitOpenTag(name);
        }
        emitOpenTag(name) {
            var _a, _b, _c, _d;
            this.openTagStart = this.startIndex;
            this.tagname = name;
            const impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
            if (impliesClose) {
                while (this.stack.length > 0 &&
                    impliesClose.has(this.stack[this.stack.length - 1])) {
                    const el = this.stack.pop();
                    (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, el, true);
                }
            }
            if (!this.isVoidElement(name)) {
                this.stack.push(name);
                if (foreignContextElements.has(name)) {
                    this.foreignContext.push(true);
                }
                else if (htmlIntegrationElements.has(name)) {
                    this.foreignContext.push(false);
                }
            }
            (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
            if (this.cbs.onopentag)
                this.attribs = {};
        }
        endOpenTag(isImplied) {
            var _a, _b;
            this.startIndex = this.openTagStart;
            if (this.attribs) {
                (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
                this.attribs = null;
            }
            if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
                this.cbs.onclosetag(this.tagname, true);
            }
            this.tagname = "";
        }
        /** @internal */
        onopentagend(endIndex) {
            this.endIndex = endIndex;
            this.endOpenTag(false);
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        /** @internal */
        onclosetag(start, endIndex) {
            var _a, _b, _c, _d, _e, _f;
            this.endIndex = endIndex;
            let name = this.getSlice(start, endIndex);
            if (this.lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            if (foreignContextElements.has(name) ||
                htmlIntegrationElements.has(name)) {
                this.foreignContext.pop();
            }
            if (!this.isVoidElement(name)) {
                const pos = this.stack.lastIndexOf(name);
                if (pos !== -1) {
                    if (this.cbs.onclosetag) {
                        let count = this.stack.length - pos;
                        while (count--) {
                            // We know the stack has sufficient elements.
                            this.cbs.onclosetag(this.stack.pop(), count !== 0);
                        }
                    }
                    else
                        this.stack.length = pos;
                }
                else if (!this.options.xmlMode && name === "p") {
                    // Implicit open before close
                    this.emitOpenTag("p");
                    this.closeCurrentTag(true);
                }
            }
            else if (!this.options.xmlMode && name === "br") {
                // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.
                (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
                (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
                (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
            }
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        /** @internal */
        onselfclosingtag(endIndex) {
            this.endIndex = endIndex;
            if (this.options.xmlMode ||
                this.options.recognizeSelfClosing ||
                this.foreignContext[this.foreignContext.length - 1]) {
                this.closeCurrentTag(false);
                // Set `startIndex` for next node
                this.startIndex = endIndex + 1;
            }
            else {
                // Ignore the fact that the tag is self-closing.
                this.onopentagend(endIndex);
            }
        }
        closeCurrentTag(isOpenImplied) {
            var _a, _b;
            const name = this.tagname;
            this.endOpenTag(isOpenImplied);
            // Self-closing tags will be on the top of the stack
            if (this.stack[this.stack.length - 1] === name) {
                // If the opening tag isn't implied, the closing tag has to be implied.
                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
                this.stack.pop();
            }
        }
        /** @internal */
        onattribname(start, endIndex) {
            this.startIndex = start;
            const name = this.getSlice(start, endIndex);
            this.attribname = this.lowerCaseAttributeNames
                ? name.toLowerCase()
                : name;
        }
        /** @internal */
        onattribdata(start, endIndex) {
            this.attribvalue += this.getSlice(start, endIndex);
        }
        /** @internal */
        onattribentity(cp) {
            this.attribvalue += fromCodePoint(cp);
        }
        /** @internal */
        onattribend(quote, endIndex) {
            var _a, _b;
            this.endIndex = endIndex;
            (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === QuoteType.Double
                ? '"'
                : quote === QuoteType.Single
                    ? "'"
                    : quote === QuoteType.NoValue
                        ? undefined
                        : null);
            if (this.attribs &&
                !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
                this.attribs[this.attribname] = this.attribvalue;
            }
            this.attribvalue = "";
        }
        getInstructionName(value) {
            const idx = value.search(reNameEnd);
            let name = idx < 0 ? value : value.substr(0, idx);
            if (this.lowerCaseTagNames) {
                name = name.toLowerCase();
            }
            return name;
        }
        /** @internal */
        ondeclaration(start, endIndex) {
            this.endIndex = endIndex;
            const value = this.getSlice(start, endIndex);
            if (this.cbs.onprocessinginstruction) {
                const name = this.getInstructionName(value);
                this.cbs.onprocessinginstruction(`!${name}`, `!${value}`);
            }
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        /** @internal */
        onprocessinginstruction(start, endIndex) {
            this.endIndex = endIndex;
            const value = this.getSlice(start, endIndex);
            if (this.cbs.onprocessinginstruction) {
                const name = this.getInstructionName(value);
                this.cbs.onprocessinginstruction(`?${name}`, `?${value}`);
            }
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        /** @internal */
        oncomment(start, endIndex, offset) {
            var _a, _b, _c, _d;
            this.endIndex = endIndex;
            (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));
            (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        /** @internal */
        oncdata(start, endIndex, offset) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            this.endIndex = endIndex;
            const value = this.getSlice(start, endIndex - offset);
            if (this.options.xmlMode || this.options.recognizeCDATA) {
                (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
                (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
                (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
            }
            else {
                (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, `[CDATA[${value}]]`);
                (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
            }
            // Set `startIndex` for next node
            this.startIndex = endIndex + 1;
        }
        /** @internal */
        onend() {
            var _a, _b;
            if (this.cbs.onclosetag) {
                // Set the end index for all remaining tags
                this.endIndex = this.startIndex;
                for (let i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i], true))
                    ;
            }
            (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
        /**
         * Resets the parser to a blank state, ready to parse a new HTML document
         */
        reset() {
            var _a, _b, _c, _d;
            (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
            this.tokenizer.reset();
            this.tagname = "";
            this.attribname = "";
            this.attribs = null;
            this.stack.length = 0;
            this.startIndex = 0;
            this.endIndex = 0;
            (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
            this.buffers.length = 0;
            this.bufferOffset = 0;
            this.writeIndex = 0;
            this.ended = false;
        }
        /**
         * Resets the parser, then parses a complete document and
         * pushes it to the handler.
         *
         * @param data Document to parse.
         */
        parseComplete(data) {
            this.reset();
            this.end(data);
        }
        getSlice(start, end) {
            while (start - this.bufferOffset >= this.buffers[0].length) {
                this.shiftBuffer();
            }
            let str = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
            while (end - this.bufferOffset > this.buffers[0].length) {
                this.shiftBuffer();
                str += this.buffers[0].slice(0, end - this.bufferOffset);
            }
            return str;
        }
        shiftBuffer() {
            this.bufferOffset += this.buffers[0].length;
            this.writeIndex--;
            this.buffers.shift();
        }
        /**
         * Parses a chunk of data and calls the corresponding callbacks.
         *
         * @param chunk Chunk to parse.
         */
        write(chunk) {
            var _a, _b;
            if (this.ended) {
                (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
                return;
            }
            this.buffers.push(chunk);
            if (this.tokenizer.running) {
                this.tokenizer.write(chunk);
                this.writeIndex++;
            }
        }
        /**
         * Parses the end of the buffer and clears the stack, calls onend.
         *
         * @param chunk Optional final chunk to parse.
         */
        end(chunk) {
            var _a, _b;
            if (this.ended) {
                (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, Error(".end() after done!"));
                return;
            }
            if (chunk)
                this.write(chunk);
            this.ended = true;
            this.tokenizer.end();
        }
        /**
         * Pauses parsing. The parser won't emit events until `resume` is called.
         */
        pause() {
            this.tokenizer.pause();
        }
        /**
         * Resumes parsing after `pause` was called.
         */
        resume() {
            this.tokenizer.resume();
            while (this.tokenizer.running &&
                this.writeIndex < this.buffers.length) {
                this.tokenizer.write(this.buffers[this.writeIndex++]);
            }
            if (this.ended)
                this.tokenizer.end();
        }
        /**
         * Alias of `write`, for backwards compatibility.
         *
         * @param chunk Chunk to parse.
         * @deprecated
         */
        parseChunk(chunk) {
            this.write(chunk);
        }
        /**
         * Alias of `end`, for backwards compatibility.
         *
         * @param chunk Optional final chunk to parse.
         * @deprecated
         */
        done(chunk) {
            this.end(chunk);
        }
    }

    // Helper methods
    /**
     * Parses the data, returns the resulting document.
     *
     * @param data The data that should be parsed.
     * @param options Optional options for the parser and DOM builder.
     */
    function parseDocument(data, options) {
        const handler = new DomHandler(undefined, options);
        new Parser(handler, options).end(data);
        return handler.root;
    }

    /**
     * Types used in signatures of Cheerio methods.
     *
     * @category Cheerio
     */
    const parse = getParse((content, options, isDocument, context) => options.xmlMode || options._useHtmlParser2
        ? parseDocument(content, options)
        : parseWithParse5(content, options, isDocument, context));
    // Duplicate docs due to https://github.com/TypeStrong/typedoc/issues/1616
    /**
     * Create a querying function, bound to a document created from the provided markup.
     *
     * Note that similar to web browser contexts, this operation may introduce
     * `<html>`, `<head>`, and `<body>` elements; set `isDocument` to `false` to
     * switch to fragment mode and disable this.
     *
     * @param content - Markup to be loaded.
     * @param options - Options for the created instance.
     * @param isDocument - Allows parser to be switched to fragment mode.
     * @returns The loaded document.
     * @see {@link https://cheerio.js.org#loading} for additional usage information.
     */
    const load = getLoad(parse, (dom, options) => options.xmlMode || options._useHtmlParser2
        ? render$1(dom, options)
        : renderWithParse5(dom));
    /**
     * The default cheerio instance.
     *
     * @deprecated Use the function returned by `load` instead.
     */
    var cheerio = load([]);

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    var lodash = createCommonjsModule(function (module, exports) {
    (function() {

      /** Used as a safe reference for `undefined` in pre-ES5 environments. */
      var undefined$1;

      /** Used as the semantic version number. */
      var VERSION = '4.17.21';

      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200;

      /** Error message constants. */
      var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
          FUNC_ERROR_TEXT = 'Expected a function',
          INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__';

      /** Used as the maximum memoize cache size. */
      var MAX_MEMOIZE_SIZE = 500;

      /** Used as the internal argument placeholder. */
      var PLACEHOLDER = '__lodash_placeholder__';

      /** Used to compose bitmasks for cloning. */
      var CLONE_DEEP_FLAG = 1,
          CLONE_FLAT_FLAG = 2,
          CLONE_SYMBOLS_FLAG = 4;

      /** Used to compose bitmasks for value comparisons. */
      var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2;

      /** Used to compose bitmasks for function metadata. */
      var WRAP_BIND_FLAG = 1,
          WRAP_BIND_KEY_FLAG = 2,
          WRAP_CURRY_BOUND_FLAG = 4,
          WRAP_CURRY_FLAG = 8,
          WRAP_CURRY_RIGHT_FLAG = 16,
          WRAP_PARTIAL_FLAG = 32,
          WRAP_PARTIAL_RIGHT_FLAG = 64,
          WRAP_ARY_FLAG = 128,
          WRAP_REARG_FLAG = 256,
          WRAP_FLIP_FLAG = 512;

      /** Used as default options for `_.truncate`. */
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';

      /** Used to detect hot functions by number of calls within a span of milliseconds. */
      var HOT_COUNT = 800,
          HOT_SPAN = 16;

      /** Used to indicate the type of lazy iteratees. */
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2,
          LAZY_WHILE_FLAG = 3;

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0,
          MAX_SAFE_INTEGER = 9007199254740991,
          MAX_INTEGER = 1.7976931348623157e+308,
          NAN = 0 / 0;

      /** Used as references for the maximum length and index of an array. */
      var MAX_ARRAY_LENGTH = 4294967295,
          MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
          HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

      /** Used to associate wrap methods with their bit flags. */
      var wrapFlags = [
        ['ary', WRAP_ARY_FLAG],
        ['bind', WRAP_BIND_FLAG],
        ['bindKey', WRAP_BIND_KEY_FLAG],
        ['curry', WRAP_CURRY_FLAG],
        ['curryRight', WRAP_CURRY_RIGHT_FLAG],
        ['flip', WRAP_FLIP_FLAG],
        ['partial', WRAP_PARTIAL_FLAG],
        ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
        ['rearg', WRAP_REARG_FLAG]
      ];

      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          asyncTag = '[object AsyncFunction]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          domExcTag = '[object DOMException]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          genTag = '[object GeneratorFunction]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          nullTag = '[object Null]',
          objectTag = '[object Object]',
          promiseTag = '[object Promise]',
          proxyTag = '[object Proxy]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          symbolTag = '[object Symbol]',
          undefinedTag = '[object Undefined]',
          weakMapTag = '[object WeakMap]',
          weakSetTag = '[object WeakSet]';

      var arrayBufferTag = '[object ArrayBuffer]',
          dataViewTag = '[object DataView]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';

      /** Used to match empty string literals in compiled template source. */
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

      /** Used to match HTML entities and HTML characters. */
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
          reUnescapedHtml = /[&<>"']/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

      /** Used to match template delimiters. */
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;

      /** Used to match property names within property paths. */
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

      /**
       * Used to match `RegExp`
       * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
       */
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
          reHasRegExpChar = RegExp(reRegExpChar.source);

      /** Used to match leading whitespace. */
      var reTrimStart = /^\s+/;

      /** Used to match a single whitespace character. */
      var reWhitespace = /\s/;

      /** Used to match wrap detail comments. */
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
          reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
          reSplitDetails = /,? & /;

      /** Used to match words composed of alphanumeric characters. */
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

      /**
       * Used to validate the `validate` option in `_.template` variable.
       *
       * Forbids characters which could potentially change the meaning of the function argument definition:
       * - "()," (modification of function parameters)
       * - "=" (default value)
       * - "[]{}" (destructuring of function parameters)
       * - "/" (beginning of a comment)
       * - whitespace
       */
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

      /** Used to match backslashes in property paths. */
      var reEscapeChar = /\\(\\)?/g;

      /**
       * Used to match
       * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
       */
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

      /** Used to match `RegExp` flags from their coerced string values. */
      var reFlags = /\w*$/;

      /** Used to detect bad signed hexadecimal string values. */
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

      /** Used to detect binary string values. */
      var reIsBinary = /^0b[01]+$/i;

      /** Used to detect host constructors (Safari). */
      var reIsHostCtor = /^\[object .+?Constructor\]$/;

      /** Used to detect octal string values. */
      var reIsOctal = /^0o[0-7]+$/i;

      /** Used to detect unsigned integer values. */
      var reIsUint = /^(?:0|[1-9]\d*)$/;

      /** Used to match Latin Unicode letters (excluding mathematical operators). */
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

      /** Used to ensure capturing order of template delimiters. */
      var reNoMatch = /($^)/;

      /** Used to match unescaped characters in compiled string literals. */
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

      /** Used to compose unicode character classes. */
      var rsAstralRange = '\\ud800-\\udfff',
          rsComboMarksRange = '\\u0300-\\u036f',
          reComboHalfMarksRange = '\\ufe20-\\ufe2f',
          rsComboSymbolsRange = '\\u20d0-\\u20ff',
          rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
          rsDingbatRange = '\\u2700-\\u27bf',
          rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
          rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
          rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
          rsPunctuationRange = '\\u2000-\\u206f',
          rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
          rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
          rsVarRange = '\\ufe0e\\ufe0f',
          rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

      /** Used to compose unicode capture groups. */
      var rsApos = "['\u2019]",
          rsAstral = '[' + rsAstralRange + ']',
          rsBreak = '[' + rsBreakRange + ']',
          rsCombo = '[' + rsComboRange + ']',
          rsDigits = '\\d+',
          rsDingbat = '[' + rsDingbatRange + ']',
          rsLower = '[' + rsLowerRange + ']',
          rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
          rsFitz = '\\ud83c[\\udffb-\\udfff]',
          rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
          rsNonAstral = '[^' + rsAstralRange + ']',
          rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
          rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
          rsUpper = '[' + rsUpperRange + ']',
          rsZWJ = '\\u200d';

      /** Used to compose unicode regexes. */
      var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
          rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
          rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
          rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
          reOptMod = rsModifier + '?',
          rsOptVar = '[' + rsVarRange + ']?',
          rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
          rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
          rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
          rsSeq = rsOptVar + reOptMod + rsOptJoin,
          rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
          rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

      /** Used to match apostrophes. */
      var reApos = RegExp(rsApos, 'g');

      /**
       * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
       * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
       */
      var reComboMark = RegExp(rsCombo, 'g');

      /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
      var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

      /** Used to match complex or compound words. */
      var reUnicodeWord = RegExp([
        rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
        rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
        rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
        rsUpper + '+' + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join('|'), 'g');

      /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
      var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

      /** Used to detect strings that need a more robust regexp to match words. */
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

      /** Used to assign default `context` object properties. */
      var contextProps = [
        'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
        'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
        '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
      ];

      /** Used to make template sourceURLs easier to identify. */
      var templateCounter = -1;

      /** Used to identify `toStringTag` values of typed arrays. */
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
      typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
      typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
      typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
      typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
      typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
      typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
      typedArrayTags[errorTag] = typedArrayTags[funcTag] =
      typedArrayTags[mapTag] = typedArrayTags[numberTag] =
      typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
      typedArrayTags[setTag] = typedArrayTags[stringTag] =
      typedArrayTags[weakMapTag] = false;

      /** Used to identify `toStringTag` values supported by `_.clone`. */
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] =
      cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
      cloneableTags[boolTag] = cloneableTags[dateTag] =
      cloneableTags[float32Tag] = cloneableTags[float64Tag] =
      cloneableTags[int8Tag] = cloneableTags[int16Tag] =
      cloneableTags[int32Tag] = cloneableTags[mapTag] =
      cloneableTags[numberTag] = cloneableTags[objectTag] =
      cloneableTags[regexpTag] = cloneableTags[setTag] =
      cloneableTags[stringTag] = cloneableTags[symbolTag] =
      cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
      cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] =
      cloneableTags[weakMapTag] = false;

      /** Used to map Latin Unicode letters to basic Latin letters. */
      var deburredLetters = {
        // Latin-1 Supplement block.
        '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
        '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
        '\xc7': 'C',  '\xe7': 'c',
        '\xd0': 'D',  '\xf0': 'd',
        '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
        '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
        '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
        '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
        '\xd1': 'N',  '\xf1': 'n',
        '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
        '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
        '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
        '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
        '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
        '\xc6': 'Ae', '\xe6': 'ae',
        '\xde': 'Th', '\xfe': 'th',
        '\xdf': 'ss',
        // Latin Extended-A block.
        '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
        '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
        '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
        '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
        '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
        '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
        '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
        '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
        '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
        '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
        '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
        '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
        '\u0134': 'J',  '\u0135': 'j',
        '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
        '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
        '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
        '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
        '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
        '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
        '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
        '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
        '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
        '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
        '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
        '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
        '\u0163': 't',  '\u0165': 't', '\u0167': 't',
        '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
        '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
        '\u0174': 'W',  '\u0175': 'w',
        '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
        '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
        '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
        '\u0132': 'IJ', '\u0133': 'ij',
        '\u0152': 'Oe', '\u0153': 'oe',
        '\u0149': "'n", '\u017f': 's'
      };

      /** Used to map characters to HTML entities. */
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      };

      /** Used to map HTML entities to characters. */
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'"
      };

      /** Used to escape characters for inclusion in compiled string literals. */
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };

      /** Built-in method references without a dependency on `root`. */
      var freeParseFloat = parseFloat,
          freeParseInt = parseInt;

      /** Detect free variable `global` from Node.js. */
      var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

      /** Detect free variable `self`. */
      var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')();

      /** Detect free variable `exports`. */
      var freeExports = exports && !exports.nodeType && exports;

      /** Detect free variable `module`. */
      var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

      /** Detect the popular CommonJS extension `module.exports`. */
      var moduleExports = freeModule && freeModule.exports === freeExports;

      /** Detect free variable `process` from Node.js. */
      var freeProcess = moduleExports && freeGlobal.process;

      /** Used to access faster Node.js helpers. */
      var nodeUtil = (function() {
        try {
          // Use `util.types` for Node.js 10+.
          var types = freeModule && freeModule.require && freeModule.require('util').types;

          if (types) {
            return types;
          }

          // Legacy `process.binding('util')` for Node.js < 10.
          return freeProcess && freeProcess.binding && freeProcess.binding('util');
        } catch (e) {}
      }());

      /* Node.js helper references. */
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
          nodeIsDate = nodeUtil && nodeUtil.isDate,
          nodeIsMap = nodeUtil && nodeUtil.isMap,
          nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
          nodeIsSet = nodeUtil && nodeUtil.isSet,
          nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

      /*--------------------------------------------------------------------------*/

      /**
       * A faster alternative to `Function#apply`, this function invokes `func`
       * with the `this` binding of `thisArg` and the arguments of `args`.
       *
       * @private
       * @param {Function} func The function to invoke.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} args The arguments to invoke `func` with.
       * @returns {*} Returns the result of `func`.
       */
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0: return func.call(thisArg);
          case 1: return func.call(thisArg, args[0]);
          case 2: return func.call(thisArg, args[0], args[1]);
          case 3: return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }

      /**
       * A specialized version of `baseAggregator` for arrays.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.forEach` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEach(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.forEachRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;

        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.every` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       */
      function arrayEvery(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }

      /**
       * A specialized version of `_.filter` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */
      function arrayFilter(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }

      /**
       * A specialized version of `_.includes` for arrays without support for
       * specifying an index to search from.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }

      /**
       * This function is like `arrayIncludes` except that it accepts a comparator.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludesWith(array, value, comparator) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }

      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function arrayMap(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);

        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }

      /**
       * Appends the elements of `values` to `array`.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to append.
       * @returns {Array} Returns `array`.
       */
      function arrayPush(array, values) {
        var index = -1,
            length = values.length,
            offset = array.length;

        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }

      /**
       * A specialized version of `_.reduce` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the first element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1,
            length = array == null ? 0 : array.length;

        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.reduceRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the last element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.some` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */
      function arraySome(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }

      /**
       * Gets the size of an ASCII `string`.
       *
       * @private
       * @param {string} string The string inspect.
       * @returns {number} Returns the string size.
       */
      var asciiSize = baseProperty('length');

      /**
       * Converts an ASCII `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function asciiToArray(string) {
        return string.split('');
      }

      /**
       * Splits an ASCII `string` into an array of its words.
       *
       * @private
       * @param {string} The string to inspect.
       * @returns {Array} Returns the words of `string`.
       */
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }

      /**
       * The base implementation of methods like `_.findKey` and `_.findLastKey`,
       * without support for iteratee shorthands, which iterates over `collection`
       * using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the found element or its key, else `undefined`.
       */
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection) {
          if (predicate(value, key, collection)) {
            result = key;
            return false;
          }
        });
        return result;
      }

      /**
       * The base implementation of `_.findIndex` and `_.findLastIndex` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {number} fromIndex The index to search from.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1);

        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOf(array, value, fromIndex) {
        return value === value
          ? strictIndexOf(array, value, fromIndex)
          : baseFindIndex(array, baseIsNaN, fromIndex);
      }

      /**
       * This function is like `baseIndexOf` except that it accepts a comparator.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1,
            length = array.length;

        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * The base implementation of `_.isNaN` without support for number objects.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       */
      function baseIsNaN(value) {
        return value !== value;
      }

      /**
       * The base implementation of `_.mean` and `_.meanBy` without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the mean.
       */
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? (baseSum(array, iteratee) / length) : NAN;
      }

      /**
       * The base implementation of `_.property` without support for deep paths.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @returns {Function} Returns the new accessor function.
       */
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined$1 : object[key];
        };
      }

      /**
       * The base implementation of `_.propertyOf` without support for deep paths.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       */
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined$1 : object[key];
        };
      }

      /**
       * The base implementation of `_.reduce` and `_.reduceRight`, without support
       * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} accumulator The initial value.
       * @param {boolean} initAccum Specify using the first or last element of
       *  `collection` as the initial value.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the accumulated value.
       */
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection) {
          accumulator = initAccum
            ? (initAccum = false, value)
            : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
      }

      /**
       * The base implementation of `_.sortBy` which uses `comparer` to define the
       * sort order of `array` and replaces criteria objects with their corresponding
       * values.
       *
       * @private
       * @param {Array} array The array to sort.
       * @param {Function} comparer The function to define sort order.
       * @returns {Array} Returns `array`.
       */
      function baseSortBy(array, comparer) {
        var length = array.length;

        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }

      /**
       * The base implementation of `_.sum` and `_.sumBy` without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the sum.
       */
      function baseSum(array, iteratee) {
        var result,
            index = -1,
            length = array.length;

        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : (result + current);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.times` without support for iteratee shorthands
       * or max array length checks.
       *
       * @private
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       */
      function baseTimes(n, iteratee) {
        var index = -1,
            result = Array(n);

        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }

      /**
       * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
       * of key-value pairs for `object` corresponding to the property names of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the key-value pairs.
       */
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }

      /**
       * The base implementation of `_.trim`.
       *
       * @private
       * @param {string} string The string to trim.
       * @returns {string} Returns the trimmed string.
       */
      function baseTrim(string) {
        return string
          ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
          : string;
      }

      /**
       * The base implementation of `_.unary` without support for storing metadata.
       *
       * @private
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       */
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }

      /**
       * The base implementation of `_.values` and `_.valuesIn` which creates an
       * array of `object` property values corresponding to the property names
       * of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the array of property values.
       */
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }

      /**
       * Checks if a `cache` value for `key` exists.
       *
       * @private
       * @param {Object} cache The cache to query.
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function cacheHas(cache, key) {
        return cache.has(key);
      }

      /**
       * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the first unmatched string symbol.
       */
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1,
            length = strSymbols.length;

        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }

      /**
       * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the last unmatched string symbol.
       */
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;

        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }

      /**
       * Gets the number of `placeholder` occurrences in `array`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} placeholder The placeholder to search for.
       * @returns {number} Returns the placeholder count.
       */
      function countHolders(array, placeholder) {
        var length = array.length,
            result = 0;

        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }

      /**
       * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
       * letters to basic Latin letters.
       *
       * @private
       * @param {string} letter The matched letter to deburr.
       * @returns {string} Returns the deburred letter.
       */
      var deburrLetter = basePropertyOf(deburredLetters);

      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      var escapeHtmlChar = basePropertyOf(htmlEscapes);

      /**
       * Used by `_.template` to escape characters for inclusion in compiled string literals.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }

      /**
       * Gets the value at `key` of `object`.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function getValue(object, key) {
        return object == null ? undefined$1 : object[key];
      }

      /**
       * Checks if `string` contains Unicode symbols.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {boolean} Returns `true` if a symbol is found, else `false`.
       */
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }

      /**
       * Checks if `string` contains a word composed of Unicode symbols.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {boolean} Returns `true` if a word is found, else `false`.
       */
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }

      /**
       * Converts `iterator` to an array.
       *
       * @private
       * @param {Object} iterator The iterator to convert.
       * @returns {Array} Returns the converted array.
       */
      function iteratorToArray(iterator) {
        var data,
            result = [];

        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }

      /**
       * Converts `map` to its key-value pairs.
       *
       * @private
       * @param {Object} map The map to convert.
       * @returns {Array} Returns the key-value pairs.
       */
      function mapToArray(map) {
        var index = -1,
            result = Array(map.size);

        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }

      /**
       * Creates a unary function that invokes `func` with its argument transformed.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {Function} transform The argument transform.
       * @returns {Function} Returns the new function.
       */
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }

      /**
       * Replaces all `placeholder` elements in `array` with an internal placeholder
       * and returns an array of their indexes.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {*} placeholder The placeholder to replace.
       * @returns {Array} Returns the new array of placeholder indexes.
       */
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }

      /**
       * Converts `set` to an array of its values.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the values.
       */
      function setToArray(set) {
        var index = -1,
            result = Array(set.size);

        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }

      /**
       * Converts `set` to its value-value pairs.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the value-value pairs.
       */
      function setToPairs(set) {
        var index = -1,
            result = Array(set.size);

        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }

      /**
       * A specialized version of `_.indexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1,
            length = array.length;

        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }

      /**
       * A specialized version of `_.lastIndexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }

      /**
       * Gets the number of symbols in `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the string size.
       */
      function stringSize(string) {
        return hasUnicode(string)
          ? unicodeSize(string)
          : asciiSize(string);
      }

      /**
       * Converts `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function stringToArray(string) {
        return hasUnicode(string)
          ? unicodeToArray(string)
          : asciiToArray(string);
      }

      /**
       * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
       * character of `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the index of the last non-whitespace character.
       */
      function trimmedEndIndex(string) {
        var index = string.length;

        while (index-- && reWhitespace.test(string.charAt(index))) {}
        return index;
      }

      /**
       * Used by `_.unescape` to convert HTML entities to characters.
       *
       * @private
       * @param {string} chr The matched character to unescape.
       * @returns {string} Returns the unescaped character.
       */
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

      /**
       * Gets the size of a Unicode `string`.
       *
       * @private
       * @param {string} string The string inspect.
       * @returns {number} Returns the string size.
       */
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }

      /**
       * Converts a Unicode `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }

      /**
       * Splits a Unicode `string` into an array of its words.
       *
       * @private
       * @param {string} The string to inspect.
       * @returns {Array} Returns the words of `string`.
       */
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }

      /*--------------------------------------------------------------------------*/

      /**
       * Create a new pristine `lodash` function using the `context` object.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Util
       * @param {Object} [context=root] The context object.
       * @returns {Function} Returns a new `lodash` function.
       * @example
       *
       * _.mixin({ 'foo': _.constant('foo') });
       *
       * var lodash = _.runInContext();
       * lodash.mixin({ 'bar': lodash.constant('bar') });
       *
       * _.isFunction(_.foo);
       * // => true
       * _.isFunction(_.bar);
       * // => false
       *
       * lodash.isFunction(lodash.foo);
       * // => false
       * lodash.isFunction(lodash.bar);
       * // => true
       *
       * // Create a suped-up `defer` in Node.js.
       * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
       */
      var runInContext = (function runInContext(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

        /** Built-in constructor references. */
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;

        /** Used for built-in method references. */
        var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;

        /** Used to detect overreaching core-js shims. */
        var coreJsData = context['__core-js_shared__'];

        /** Used to resolve the decompiled source of functions. */
        var funcToString = funcProto.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /** Used to generate unique IDs. */
        var idCounter = 0;

        /** Used to detect methods masquerading as native. */
        var maskSrcKey = (function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
          return uid ? ('Symbol(src)_1.' + uid) : '';
        }());

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString = objectProto.toString;

        /** Used to infer the `Object` constructor. */
        var objectCtorString = funcToString.call(Object);

        /** Used to restore the original `_` reference in `_.noConflict`. */
        var oldDash = root._;

        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' +
          funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
          .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
        );

        /** Built-in value references. */
        var Buffer = moduleExports ? context.Buffer : undefined$1,
            Symbol = context.Symbol,
            Uint8Array = context.Uint8Array,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
            getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice,
            spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
            symIterator = Symbol ? Symbol.iterator : undefined$1,
            symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

        var defineProperty = (function() {
          try {
            var func = getNative(Object, 'defineProperty');
            func({}, '', {});
            return func;
          } catch (e) {}
        }());

        /** Mocked built-ins. */
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
            ctxNow = Date && Date.now !== root.Date.now && Date.now,
            ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeCeil = Math.ceil,
            nativeFloor = Math.floor,
            nativeGetSymbols = Object.getOwnPropertySymbols,
            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
            nativeIsFinite = context.isFinite,
            nativeJoin = arrayProto.join,
            nativeKeys = overArg(Object.keys, Object),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = Date.now,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random,
            nativeReverse = arrayProto.reverse;

        /* Built-in method references that are verified to be native. */
        var DataView = getNative(context, 'DataView'),
            Map = getNative(context, 'Map'),
            Promise = getNative(context, 'Promise'),
            Set = getNative(context, 'Set'),
            WeakMap = getNative(context, 'WeakMap'),
            nativeCreate = getNative(Object, 'create');

        /** Used to store function metadata. */
        var metaMap = WeakMap && new WeakMap;

        /** Used to lookup unminified function names. */
        var realNames = {};

        /** Used to detect maps, sets, and weakmaps. */
        var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap);

        /** Used to convert symbols to primitives and strings. */
        var symbolProto = Symbol ? Symbol.prototype : undefined$1,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
            symbolToString = symbolProto ? symbolProto.toString : undefined$1;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a `lodash` object which wraps `value` to enable implicit method
         * chain sequences. Methods that operate on and return arrays, collections,
         * and functions can be chained together. Methods that retrieve a single value
         * or may return a primitive value will automatically end the chain sequence
         * and return the unwrapped value. Otherwise, the value must be unwrapped
         * with `_#value`.
         *
         * Explicit chain sequences, which must be unwrapped with `_#value`, may be
         * enabled using `_.chain`.
         *
         * The execution of chained methods is lazy, that is, it's deferred until
         * `_#value` is implicitly or explicitly called.
         *
         * Lazy evaluation allows several methods to support shortcut fusion.
         * Shortcut fusion is an optimization to merge iteratee calls; this avoids
         * the creation of intermediate arrays and can greatly reduce the number of
         * iteratee executions. Sections of a chain sequence qualify for shortcut
         * fusion if the section is applied to an array and iteratees accept only
         * one argument. The heuristic for whether a section qualifies for shortcut
         * fusion is subject to change.
         *
         * Chaining is supported in custom builds as long as the `_#value` method is
         * directly or indirectly included in the build.
         *
         * In addition to lodash methods, wrappers have `Array` and `String` methods.
         *
         * The wrapper `Array` methods are:
         * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
         *
         * The wrapper `String` methods are:
         * `replace` and `split`
         *
         * The wrapper methods that support shortcut fusion are:
         * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
         * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
         * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
         *
         * The chainable wrapper methods are:
         * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
         * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
         * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
         * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
         * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
         * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
         * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
         * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
         * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
         * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
         * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
         * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
         * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
         * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
         * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
         * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
         * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
         * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
         * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
         * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
         * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
         * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
         * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
         * `zipObject`, `zipObjectDeep`, and `zipWith`
         *
         * The wrapper methods that are **not** chainable by default are:
         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
         * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
         * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
         * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
         * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
         * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
         * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
         * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
         * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
         * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
         * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
         * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
         * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
         * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
         * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
         * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
         * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
         * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
         * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
         * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
         * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
         * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
         * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
         * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
         * `upperFirst`, `value`, and `words`
         *
         * @name _
         * @constructor
         * @category Seq
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // Returns an unwrapped value.
         * wrapped.reduce(_.add);
         * // => 6
         *
         * // Returns a wrapped value.
         * var squares = wrapped.map(square);
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = (function() {
          function object() {}
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result = new object;
            object.prototype = undefined$1;
            return result;
          };
        }());

        /**
         * The function whose prototype chain sequence wrappers inherit from.
         *
         * @private
         */
        function baseLodash() {
          // No operation performed.
        }

        /**
         * The base constructor for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap.
         * @param {boolean} [chainAll] Enable explicit method chain sequences.
         */
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }

        /**
         * By default, the template delimiters used by lodash are like those in
         * embedded Ruby (ERB) as well as ES2015 template strings. Change the
         * following template settings to use alternative delimiters.
         *
         * @static
         * @memberOf _
         * @type {Object}
         */
        lodash.templateSettings = {

          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'escape': reEscape,

          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'evaluate': reEvaluate,

          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'interpolate': reInterpolate,

          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          'variable': '',

          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          'imports': {

            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            '_': lodash
          }
        };

        // Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;

        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
         *
         * @private
         * @constructor
         * @param {*} value The value to wrap.
         */
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }

        /**
         * Creates a clone of the lazy wrapper object.
         *
         * @private
         * @name clone
         * @memberOf LazyWrapper
         * @returns {Object} Returns the cloned `LazyWrapper` object.
         */
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = copyArray(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = copyArray(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = copyArray(this.__views__);
          return result;
        }

        /**
         * Reverses the direction of lazy iteration.
         *
         * @private
         * @name reverse
         * @memberOf LazyWrapper
         * @returns {Object} Returns the new reversed `LazyWrapper` object.
         */
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }

        /**
         * Extracts the unwrapped value from its lazy wrapper.
         *
         * @private
         * @name value
         * @memberOf LazyWrapper
         * @returns {*} Returns the unwrapped value.
         */
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);

          if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result = [];

          outer:
          while (length-- && resIndex < takeCount) {
            index += dir;

            var iterIndex = -1,
                value = array[index];

            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);

              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }

        // Ensure `LazyWrapper` is an instance of `baseLodash`.
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Hash(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function hashDelete(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined$1 : result;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
        }

        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
        }

        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
          return this;
        }

        // Add methods to `Hash`.
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function ListCache(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function listCacheDelete(key) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }

        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function listCacheGet(key) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          return index < 0 ? undefined$1 : data[index][1];
        }

        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }

        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */
        function listCacheSet(key, value) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }

        // Add methods to `ListCache`.
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function MapCache(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            'hash': new Hash,
            'map': new (Map || ListCache),
            'string': new Hash
          };
        }

        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function mapCacheDelete(key) {
          var result = getMapData(this, key)['delete'](key);
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }

        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }

        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */
        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
              size = data.size;

          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }

        // Add methods to `MapCache`.
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;

        /*------------------------------------------------------------------------*/

        /**
         *
         * Creates an array cache object to store unique values.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function SetCache(values) {
          var index = -1,
              length = values == null ? 0 : values.length;

          this.__data__ = new MapCache;
          while (++index < length) {
            this.add(values[index]);
          }
        }

        /**
         * Adds `value` to the array cache.
         *
         * @private
         * @name add
         * @memberOf SetCache
         * @alias push
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache instance.
         */
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }

        /**
         * Checks if `value` is in the array cache.
         *
         * @private
         * @name has
         * @memberOf SetCache
         * @param {*} value The value to search for.
         * @returns {number} Returns `true` if `value` is found, else `false`.
         */
        function setCacheHas(value) {
          return this.__data__.has(value);
        }

        // Add methods to `SetCache`.
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }

        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */
        function stackClear() {
          this.__data__ = new ListCache;
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function stackDelete(key) {
          var data = this.__data__,
              result = data['delete'](key);

          this.size = data.size;
          return result;
        }

        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function stackGet(key) {
          return this.__data__.get(key);
        }

        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function stackHas(key) {
          return this.__data__.has(key);
        }

        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }

        // Add methods to `Stack`.
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length;

          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) &&
                !(skipIndexes && (
                   // Safari 9 has enumerable `arguments.length` in strict mode.
                   key == 'length' ||
                   // Node.js 0.10 has enumerable non-index properties on buffers.
                   (isBuff && (key == 'offset' || key == 'parent')) ||
                   // PhantomJS 2 has enumerable non-index properties on typed arrays.
                   (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                   // Skip index properties.
                   isIndex(key, length)
                ))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * A specialized version of `_.sample` for arrays.
         *
         * @private
         * @param {Array} array The array to sample.
         * @returns {*} Returns the random element.
         */
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }

        /**
         * A specialized version of `_.sampleSize` for arrays.
         *
         * @private
         * @param {Array} array The array to sample.
         * @param {number} n The number of elements to sample.
         * @returns {Array} Returns the random elements.
         */
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }

        /**
         * A specialized version of `_.shuffle` for arrays.
         *
         * @private
         * @param {Array} array The array to shuffle.
         * @returns {Array} Returns the new shuffled array.
         */
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }

        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignMergeValue(object, key, value) {
          if ((value !== undefined$1 && !eq(object[key], value)) ||
              (value === undefined$1 && !(key in object))) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
              (value === undefined$1 && !(key in object))) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }

        /**
         * Aggregates elements of `collection` on `accumulator` with keys transformed
         * by `iteratee` and values set by `setter`.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform keys.
         * @param {Object} accumulator The initial aggregated object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseAggregator(collection, setter, iteratee, accumulator) {
          baseEach(collection, function(value, key, collection) {
            setter(accumulator, value, iteratee(value), collection);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.assign` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }

        /**
         * The base implementation of `_.assignIn` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }

        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function baseAssignValue(object, key, value) {
          if (key == '__proto__' && defineProperty) {
            defineProperty(object, key, {
              'configurable': true,
              'enumerable': true,
              'value': value,
              'writable': true
            });
          } else {
            object[key] = value;
          }
        }

        /**
         * The base implementation of `_.at` without support for individual paths.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {string[]} paths The property paths to pick.
         * @returns {Array} Returns the picked elements.
         */
        function baseAt(object, paths) {
          var index = -1,
              length = paths.length,
              result = Array(length),
              skip = object == null;

          while (++index < length) {
            result[index] = skip ? undefined$1 : get(object, paths[index]);
          }
          return result;
        }

        /**
         * The base implementation of `_.clamp` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         */
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }

        /**
         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
         * traversed objects.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Deep clone
         *  2 - Flatten inherited properties
         *  4 - Clone symbols
         * @param {Function} [customizer] The function to customize cloning.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The parent object of `value`.
         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result,
              isDeep = bitmask & CLONE_DEEP_FLAG,
              isFlat = bitmask & CLONE_FLAT_FLAG,
              isFull = bitmask & CLONE_SYMBOLS_FLAG;

          if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result !== undefined$1) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result);
            }
          } else {
            var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag;

            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = (isFlat || isFunc) ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat
                  ? copySymbolsIn(value, baseAssignIn(result, value))
                  : copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result = initCloneByTag(value, tag, isDeep);
            }
          }
          // Check for circular references and return its corresponding clone.
          stack || (stack = new Stack);
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);

          if (isSet(value)) {
            value.forEach(function(subValue) {
              result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key) {
              result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
          }

          var keysFunc = isFull
            ? (isFlat ? getAllKeysIn : getAllKeys)
            : (isFlat ? keysIn : keys);

          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key) {
            if (props) {
              key = subValue;
              subValue = value[key];
            }
            // Recursively populate clone (susceptible to call stack limits).
            assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
          });
          return result;
        }

        /**
         * The base implementation of `_.conforms` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new spec function.
         */
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }

        /**
         * The base implementation of `_.conformsTo` which accepts `props` to check.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property predicates to conform to.
         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
         */
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (length--) {
            var key = props[length],
                predicate = source[key],
                value = object[key];

            if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }

        /**
         * The base implementation of `_.delay` and `_.defer` which accepts `args`
         * to provide to `func`.
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {Array} args The arguments to provide to `func`.
         * @returns {number|Object} Returns the timer id or timeout object.
         */
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() { func.apply(undefined$1, args); }, wait);
        }

        /**
         * The base implementation of methods like `_.difference` without support
         * for excluding multiple arrays or iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Array} values The values to exclude.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         */
        function baseDifference(array, values, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              isCommon = true,
              length = array.length,
              result = [],
              valuesLength = values.length;

          if (!length) {
            return result;
          }
          if (iteratee) {
            values = arrayMap(values, baseUnary(iteratee));
          }
          if (comparator) {
            includes = arrayIncludesWith;
            isCommon = false;
          }
          else if (values.length >= LARGE_ARRAY_SIZE) {
            includes = cacheHas;
            isCommon = false;
            values = new SetCache(values);
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee == null ? value : iteratee(value);

            value = (comparator || value !== 0) ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result.push(value);
            }
            else if (!includes(values, computed, comparator)) {
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.forEach` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);

        /**
         * The base implementation of `_.forEachRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEachRight = createBaseEach(baseForOwnRight, true);

        /**
         * The base implementation of `_.every` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`
         */
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }

        /**
         * The base implementation of methods like `_.max` and `_.min` which accepts a
         * `comparator` to determine the extremum value.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The iteratee invoked per iteration.
         * @param {Function} comparator The comparator used to compare values.
         * @returns {*} Returns the extremum value.
         */
        function baseExtremum(array, iteratee, comparator) {
          var index = -1,
              length = array.length;

          while (++index < length) {
            var value = array[index],
                current = iteratee(value);

            if (current != null && (computed === undefined$1
                  ? (current === current && !isSymbol(current))
                  : comparator(current, computed)
                )) {
              var computed = current,
                  result = value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.fill` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         */
        function baseFill(array, value, start, end) {
          var length = array.length;

          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined$1 || end > length) ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }

        /**
         * The base implementation of `_.filter` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }

        /**
         * The base implementation of `_.flatten` with support for restricting flattening.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {number} depth The maximum recursion depth.
         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten(array, depth, predicate, isStrict, result) {
          var index = -1,
              length = array.length;

          predicate || (predicate = isFlattenable);
          result || (result = []);

          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor = createBaseFor();

        /**
         * This function is like `baseFor` except that it iterates over properties
         * in the opposite order.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseForRight = createBaseFor(true);

        /**
         * The base implementation of `_.forOwn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
          return object && baseFor(object, iteratee, keys);
        }

        /**
         * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwnRight(object, iteratee) {
          return object && baseForRight(object, iteratee, keys);
        }

        /**
         * The base implementation of `_.functions` which creates an array of
         * `object` function property names filtered from `props`.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} props The property names to filter.
         * @returns {Array} Returns the function names.
         */
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }

        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path) {
          path = castPath(path, object);

          var index = 0,
              length = path.length;

          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return (index && index == length) ? object : undefined$1;
        }

        /**
         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @param {Function} symbolsFunc The function to get the symbols of `object`.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }

        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return (symToStringTag && symToStringTag in Object(value))
            ? getRawTag(value)
            : objectToString(value);
        }

        /**
         * The base implementation of `_.gt` which doesn't coerce arguments.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`,
         *  else `false`.
         */
        function baseGt(value, other) {
          return value > other;
        }

        /**
         * The base implementation of `_.has` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }

        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }

        /**
         * The base implementation of `_.inRange` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to check.
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         */
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }

        /**
         * The base implementation of methods like `_.intersection`, without support
         * for iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of shared values.
         */
        function baseIntersection(arrays, iteratee, comparator) {
          var includes = comparator ? arrayIncludesWith : arrayIncludes,
              length = arrays[0].length,
              othLength = arrays.length,
              othIndex = othLength,
              caches = Array(othLength),
              maxLength = Infinity,
              result = [];

          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee) {
              array = arrayMap(array, baseUnary(iteratee));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
              ? new SetCache(othIndex && array)
              : undefined$1;
          }
          array = arrays[0];

          var index = -1,
              seen = caches[0];

          outer:
          while (++index < length && result.length < maxLength) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            value = (comparator || value !== 0) ? value : 0;
            if (!(seen
                  ? cacheHas(seen, computed)
                  : includes(result, computed, comparator)
                )) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache
                      ? cacheHas(cache, computed)
                      : includes(arrays[othIndex], computed, comparator))
                    ) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.invert` and `_.invertBy` which inverts
         * `object` with values transformed by `iteratee` and set by `setter`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform values.
         * @param {Object} accumulator The initial inverted object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseInverter(object, setter, iteratee, accumulator) {
          baseForOwn(object, function(value, key, object) {
            setter(accumulator, iteratee(value), key, object);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.invoke` without support for individual
         * method arguments.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {Array} args The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         */
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined$1 : apply(func, object, args);
        }

        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }

        /**
         * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
         */
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }

        /**
         * The base implementation of `_.isDate` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
         */
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }

        /**
         * The base implementation of `_.isEqual` which supports partial comparisons
         * and tracks traversed objects.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Unordered comparison
         *  2 - Partial comparison
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }

        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = objIsArr ? arrayTag : getTag(object),
              othTag = othIsArr ? arrayTag : getTag(other);

          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;

          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;

          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack);
            return (objIsArr || isTypedArray(object))
              ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
              : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                  othUnwrapped = othIsWrapped ? other.value() : other;

              stack || (stack = new Stack);
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack);
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }

        /**
         * The base implementation of `_.isMap` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         */
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }

        /**
         * The base implementation of `_.isMatch` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Array} matchData The property names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;

          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2])
                  ? data[1] !== object[data[0]]
                  : !(data[0] in object)
                ) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];

            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack;
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result === undefined$1
                    ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                    : result
                  )) {
                return false;
              }
            }
          }
          return true;
        }

        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }

        /**
         * The base implementation of `_.isRegExp` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
         */
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }

        /**
         * The base implementation of `_.isSet` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         */
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }

        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */
        function baseIsTypedArray(value) {
          return isObjectLike(value) &&
            isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }

        /**
         * The base implementation of `_.iteratee`.
         *
         * @private
         * @param {*} [value=_.identity] The value to convert to an iteratee.
         * @returns {Function} Returns the iteratee.
         */
        function baseIteratee(value) {
          // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
          // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
          if (typeof value == 'function') {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == 'object') {
            return isArray(value)
              ? baseMatchesProperty(value[0], value[1])
              : baseMatches(value);
          }
          return property(value);
        }

        /**
         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty.call(object, key) && key != 'constructor') {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object),
              result = [];

          for (var key in object) {
            if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.lt` which doesn't coerce arguments.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`,
         *  else `false`.
         */
        function baseLt(value, other) {
          return value < other;
        }

        /**
         * The base implementation of `_.map` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];

          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }

        /**
         * The base implementation of `_.matches` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }

        /**
         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return (objValue === undefined$1 && objValue === srcValue)
              ? hasIn(object, path)
              : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }

        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack);
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            }
            else {
              var newValue = customizer
                ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
                : undefined$1;

              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }

        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key),
              srcValue = safeGet(source, key),
              stacked = stack.get(srcValue);

          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer
            ? customizer(objValue, srcValue, (key + ''), object, source, stack)
            : undefined$1;

          var isCommon = newValue === undefined$1;

          if (isCommon) {
            var isArr = isArray(srcValue),
                isBuff = !isArr && isBuffer(srcValue),
                isTyped = !isArr && !isBuff && isTypedArray(srcValue);

            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              }
              else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              }
              else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              }
              else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              }
              else {
                newValue = [];
              }
            }
            else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              }
              else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            }
            else {
              isCommon = false;
            }
          }
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack['delete'](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }

        /**
         * The base implementation of `_.nth` which doesn't coerce arguments.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {number} n The index of the element to return.
         * @returns {*} Returns the nth element of `array`.
         */
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined$1;
        }

        /**
         * The base implementation of `_.orderBy` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {string[]} orders The sort orders of `iteratees`.
         * @returns {Array} Returns the new sorted array.
         */
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee) {
              if (isArray(iteratee)) {
                return function(value) {
                  return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                }
              }
              return iteratee;
            });
          } else {
            iteratees = [identity];
          }

          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

          var result = baseMap(collection, function(value, key, collection) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return { 'criteria': criteria, 'index': ++index, 'value': value };
          });

          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }

        /**
         * The base implementation of `_.pick` without support for individual
         * property identifiers.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @returns {Object} Returns the new object.
         */
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }

        /**
         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @param {Function} predicate The function invoked per property.
         * @returns {Object} Returns the new object.
         */
        function basePickBy(object, paths, predicate) {
          var index = -1,
              length = paths.length,
              result = {};

          while (++index < length) {
            var path = paths[index],
                value = baseGet(object, path);

            if (predicate(value, path)) {
              baseSet(result, castPath(path, object), value);
            }
          }
          return result;
        }

        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }

        /**
         * The base implementation of `_.pullAllBy` without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         */
        function basePullAll(array, values, iteratee, comparator) {
          var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
              index = -1,
              length = values.length,
              seen = array;

          if (array === values) {
            values = copyArray(values);
          }
          if (iteratee) {
            seen = arrayMap(array, baseUnary(iteratee));
          }
          while (++index < length) {
            var fromIndex = 0,
                value = values[index],
                computed = iteratee ? iteratee(value) : value;

            while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }

        /**
         * The base implementation of `_.pullAt` without support for individual
         * indexes or capturing the removed elements.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {number[]} indexes The indexes of elements to remove.
         * @returns {Array} Returns `array`.
         */
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0,
              lastIndex = length - 1;

          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }

        /**
         * The base implementation of `_.random` without support for returning
         * floating-point numbers.
         *
         * @private
         * @param {number} lower The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the random number.
         */
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }

        /**
         * The base implementation of `_.range` and `_.rangeRight` which doesn't
         * coerce arguments.
         *
         * @private
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @param {number} step The value to increment or decrement by.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the range of numbers.
         */
        function baseRange(start, end, step, fromRight) {
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);

          while (length--) {
            result[fromRight ? length : ++index] = start;
            start += step;
          }
          return result;
        }

        /**
         * The base implementation of `_.repeat` which doesn't coerce arguments.
         *
         * @private
         * @param {string} string The string to repeat.
         * @param {number} n The number of times to repeat the string.
         * @returns {string} Returns the repeated string.
         */
        function baseRepeat(string, n) {
          var result = '';
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result;
          }
          // Leverage the exponentiation by squaring algorithm for a faster repeat.
          // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);

          return result;
        }

        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + '');
        }

        /**
         * The base implementation of `_.sample`.
         *
         * @private
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         */
        function baseSample(collection) {
          return arraySample(values(collection));
        }

        /**
         * The base implementation of `_.sampleSize` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to sample.
         * @param {number} n The number of elements to sample.
         * @returns {Array} Returns the random elements.
         */
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }

        /**
         * The base implementation of `_.set`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);

          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;

          while (nested != null && ++index < length) {
            var key = toKey(path[index]),
                newValue = value;

            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
              return object;
            }

            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject(objValue)
                  ? objValue
                  : (isIndex(path[index + 1]) ? [] : {});
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }

        /**
         * The base implementation of `setData` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };

        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, 'toString', {
            'configurable': true,
            'enumerable': false,
            'value': constant(string),
            'writable': true
          });
        };

        /**
         * The base implementation of `_.shuffle`.
         *
         * @private
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         */
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }

        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;

          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;

          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }

        /**
         * The base implementation of `_.some` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function baseSome(collection, predicate) {
          var result;

          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }

        /**
         * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
         * performs a binary search of `array` to determine the index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndex(array, value, retHighest) {
          var low = 0,
              high = array == null ? low : array.length;

          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];

              if (computed !== null && !isSymbol(computed) &&
                  (retHighest ? (computed <= value) : (computed < value))) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }

        /**
         * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
         * which invokes `iteratee` for `value` and each element of `array` to compute
         * their sort ranking. The iteratee is invoked with one argument; (value).
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} iteratee The iteratee invoked per element.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndexBy(array, value, iteratee, retHighest) {
          var low = 0,
              high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }

          value = iteratee(value);
          var valIsNaN = value !== value,
              valIsNull = value === null,
              valIsSymbol = isSymbol(value),
              valIsUndefined = value === undefined$1;

          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                othIsDefined = computed !== undefined$1,
                othIsNull = computed === null,
                othIsReflexive = computed === computed,
                othIsSymbol = isSymbol(computed);

            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }

        /**
         * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
         * support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseSortedUniq(array, iteratee) {
          var index = -1,
              length = array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.toNumber` which doesn't ensure correct
         * conversions of binary, hexadecimal, or octal string values.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         */
        function baseToNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }

        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == 'string') {
            return value;
          }
          if (isArray(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + '';
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }

        /**
         * The base implementation of `_.uniqBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseUniq(array, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              length = array.length,
              isCommon = true,
              result = [],
              seen = result;

          if (comparator) {
            isCommon = false;
            includes = arrayIncludesWith;
          }
          else if (length >= LARGE_ARRAY_SIZE) {
            var set = iteratee ? null : createSet(array);
            if (set) {
              return setToArray(set);
            }
            isCommon = false;
            includes = cacheHas;
            seen = new SetCache;
          }
          else {
            seen = iteratee ? [] : result;
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            value = (comparator || value !== 0) ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            }
            else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.unset`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The property path to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         */
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }

        /**
         * The base implementation of `_.update`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to update.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }

        /**
         * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
         * without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;

          while ((fromRight ? index-- : ++index < length) &&
            predicate(array[index], index, array)) {}

          return isDrop
            ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
            : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }

        /**
         * The base implementation of `wrapperValue` which returns the result of
         * performing a sequence of actions on the unwrapped `value`, where each
         * successive action is supplied the return value of the previous.
         *
         * @private
         * @param {*} value The unwrapped value.
         * @param {Array} actions Actions to perform to resolve the unwrapped value.
         * @returns {*} Returns the resolved value.
         */
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          return arrayReduce(actions, function(result, action) {
            return action.func.apply(action.thisArg, arrayPush([result], action.args));
          }, result);
        }

        /**
         * The base implementation of methods like `_.xor`, without support for
         * iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of values.
         */
        function baseXor(arrays, iteratee, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1,
              result = Array(length);

          while (++index < length) {
            var array = arrays[index],
                othIndex = -1;

            while (++othIndex < length) {
              if (othIndex != index) {
                result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result, 1), iteratee, comparator);
        }

        /**
         * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
         *
         * @private
         * @param {Array} props The property identifiers.
         * @param {Array} values The property values.
         * @param {Function} assignFunc The function to assign values.
         * @returns {Object} Returns the new object.
         */
        function baseZipObject(props, values, assignFunc) {
          var index = -1,
              length = props.length,
              valsLength = values.length,
              result = {};

          while (++index < length) {
            var value = index < valsLength ? values[index] : undefined$1;
            assignFunc(result, props[index], value);
          }
          return result;
        }

        /**
         * Casts `value` to an empty array if it's not an array like object.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Array|Object} Returns the cast array-like object.
         */
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }

        /**
         * Casts `value` to `identity` if it's not a function.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Function} Returns cast function.
         */
        function castFunction(value) {
          return typeof value == 'function' ? value : identity;
        }

        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }

        /**
         * A `baseRest` alias which can be replaced with `identity` by module
         * replacement plugins.
         *
         * @private
         * @type {Function}
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        var castRest = baseRest;

        /**
         * Casts `array` to a slice if it's needed.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {number} start The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the cast slice.
         */
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined$1 ? length : end;
          return (!start && end >= length) ? array : baseSlice(array, start, end);
        }

        /**
         * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
         *
         * @private
         * @param {number|Object} id The timer id or timeout object of the timer to clear.
         */
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };

        /**
         * Creates a clone of  `buffer`.
         *
         * @private
         * @param {Buffer} buffer The buffer to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Buffer} Returns the cloned buffer.
         */
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length,
              result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

          buffer.copy(result);
          return result;
        }

        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result).set(new Uint8Array(arrayBuffer));
          return result;
        }

        /**
         * Creates a clone of `dataView`.
         *
         * @private
         * @param {Object} dataView The data view to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned data view.
         */
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }

        /**
         * Creates a clone of `regexp`.
         *
         * @private
         * @param {Object} regexp The regexp to clone.
         * @returns {Object} Returns the cloned regexp.
         */
        function cloneRegExp(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }

        /**
         * Creates a clone of the `symbol` object.
         *
         * @private
         * @param {Object} symbol The symbol object to clone.
         * @returns {Object} Returns the cloned symbol object.
         */
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }

        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }

        /**
         * Compares values to sort them in ascending order.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {number} Returns the sort order indicator for `value`.
         */
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1,
                valIsNull = value === null,
                valIsReflexive = value === value,
                valIsSymbol = isSymbol(value);

            var othIsDefined = other !== undefined$1,
                othIsNull = other === null,
                othIsReflexive = other === other,
                othIsSymbol = isSymbol(other);

            if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
                (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
                (valIsNull && othIsDefined && othIsReflexive) ||
                (!valIsDefined && othIsReflexive) ||
                !valIsReflexive) {
              return 1;
            }
            if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
                (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
                (othIsNull && valIsDefined && valIsReflexive) ||
                (!othIsDefined && valIsReflexive) ||
                !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }

        /**
         * Used by `_.orderBy` to compare multiple properties of a value to another
         * and stable sort them.
         *
         * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
         * specify an order of "desc" for descending or "asc" for ascending sort order
         * of corresponding values.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {boolean[]|string[]} orders The order to sort by for each property.
         * @returns {number} Returns the sort order indicator for `object`.
         */
        function compareMultiple(object, other, orders) {
          var index = -1,
              objCriteria = object.criteria,
              othCriteria = other.criteria,
              length = objCriteria.length,
              ordersLength = orders.length;

          while (++index < length) {
            var result = compareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
              if (index >= ordersLength) {
                return result;
              }
              var order = orders[index];
              return result * (order == 'desc' ? -1 : 1);
            }
          }
          // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to provide the same value for
          // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
          // for more details.
          //
          // This also ensures a stable sort in V8 and other engines.
          // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
          return object.index - other.index;
        }

        /**
         * Creates an array that is the composition of partially applied arguments,
         * placeholders, and provided arguments into a single array of arguments.
         *
         * @private
         * @param {Array} args The provided arguments.
         * @param {Array} partials The arguments to prepend to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersLength = holders.length,
              leftIndex = -1,
              leftLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(leftLength + rangeLength),
              isUncurried = !isCurried;

          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }

        /**
         * This function is like `composeArgs` except that the arguments composition
         * is tailored for `_.partialRight`.
         *
         * @private
         * @param {Array} args The provided arguments.
         * @param {Array} partials The arguments to append to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersIndex = -1,
              holdersLength = holders.length,
              rightIndex = -1,
              rightLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(rangeLength + rightLength),
              isUncurried = !isCurried;

          while (++argsIndex < rangeLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result;
        }

        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function copyArray(source, array) {
          var index = -1,
              length = source.length;

          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }

        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});

          var index = -1,
              length = props.length;

          while (++index < length) {
            var key = props[index];

            var newValue = customizer
              ? customizer(object[key], source[key], key, object, source)
              : undefined$1;

            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }

        /**
         * Copies own symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }

        /**
         * Copies own and inherited symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }

        /**
         * Creates a function like `_.groupBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} [initializer] The accumulator object initializer.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter, initializer) {
          return function(collection, iteratee) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator,
                accumulator = initializer ? initializer() : {};

            return func(collection, setter, getIteratee(iteratee, 2), accumulator);
          };
        }

        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined$1,
                guard = length > 2 ? sources[2] : undefined$1;

            customizer = (assigner.length > 3 && typeof customizer == 'function')
              ? (length--, customizer)
              : undefined$1;

            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }

        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee);
            }
            var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection);

            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }

        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;

            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }

        /**
         * Creates a function that wraps `func` to invoke it with the optional `this`
         * binding of `thisArg`.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func);

          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }

        /**
         * Creates a function like `_.lowerFirst`.
         *
         * @private
         * @param {string} methodName The name of the `String` case method to use.
         * @returns {Function} Returns the new case function.
         */
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);

            var strSymbols = hasUnicode(string)
              ? stringToArray(string)
              : undefined$1;

            var chr = strSymbols
              ? strSymbols[0]
              : string.charAt(0);

            var trailing = strSymbols
              ? castSlice(strSymbols, 1).join('')
              : string.slice(1);

            return chr[methodName]() + trailing;
          };
        }

        /**
         * Creates a function like `_.camelCase`.
         *
         * @private
         * @param {Function} callback The function to combine each word.
         * @returns {Function} Returns the new compounder function.
         */
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
          };
        }

        /**
         * Creates a function that produces an instance of `Ctor` regardless of
         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
         *
         * @private
         * @param {Function} Ctor The constructor to wrap.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCtor(Ctor) {
          return function() {
            // Use a `switch` statement to work with class constructors. See
            // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
            // for more details.
            var args = arguments;
            switch (args.length) {
              case 0: return new Ctor;
              case 1: return new Ctor(args[0]);
              case 2: return new Ctor(args[0], args[1]);
              case 3: return new Ctor(args[0], args[1], args[2]);
              case 4: return new Ctor(args[0], args[1], args[2], args[3]);
              case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);

            // Mimic the constructor's `return` behavior.
            // See https://es5.github.io/#x13.2.2 for more details.
            return isObject(result) ? result : thisBinding;
          };
        }

        /**
         * Creates a function that wraps `func` to enable currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {number} arity The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);

          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length,
                placeholder = getHolder(wrapper);

            while (index--) {
              args[index] = arguments[index];
            }
            var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
              ? []
              : replaceHolders(args, placeholder);

            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
                args, holders, undefined$1, undefined$1, arity - length);
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }

        /**
         * Creates a `_.find` or `_.findLast` function.
         *
         * @private
         * @param {Function} findIndexFunc The function to find the collection index.
         * @returns {Function} Returns the new find function.
         */
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object(collection);
            if (!isArrayLike(collection)) {
              var iteratee = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) { return iteratee(iterable[key], key, iterable); };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
          };
        }

        /**
         * Creates a `_.flow` or `_.flowRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new flow function.
         */
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length,
                index = length,
                prereq = LodashWrapper.prototype.thru;

            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];

              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined$1;

              if (data && isLaziable(data[0]) &&
                    data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                    !data[4].length && data[9] == 1
                  ) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func))
                  ? wrapper[funcName]()
                  : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];

              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;

              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          });
        }

        /**
         * Creates a function that wraps `func` to invoke it with optional `this`
         * binding of `thisArg`, partial application, and currying.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to
         *  the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [partialsRight] The arguments to append to those provided
         *  to the new function.
         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG,
              isBind = bitmask & WRAP_BIND_FLAG,
              isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
              isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
              isFlip = bitmask & WRAP_FLIP_FLAG,
              Ctor = isBindKey ? undefined$1 : createCtor(func);

          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length;

            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper),
                  holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func, bitmask, createHybrid, wrapper.placeholder, thisArg,
                args, newHolders, argPos, ary, arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;

            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary < length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }

        /**
         * Creates a function like `_.invertBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} toIteratee The function to resolve iteratees.
         * @returns {Function} Returns the new inverter function.
         */
        function createInverter(setter, toIteratee) {
          return function(object, iteratee) {
            return baseInverter(object, setter, toIteratee(iteratee), {});
          };
        }

        /**
         * Creates a function that performs a mathematical operation on two values.
         *
         * @private
         * @param {Function} operator The function to perform the operation.
         * @param {number} [defaultValue] The value used for `undefined` arguments.
         * @returns {Function} Returns the new mathematical operation function.
         */
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result = value;
            }
            if (other !== undefined$1) {
              if (result === undefined$1) {
                return other;
              }
              if (typeof value == 'string' || typeof other == 'string') {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result = operator(value, other);
            }
            return result;
          };
        }

        /**
         * Creates a function like `_.over`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over iteratees.
         * @returns {Function} Returns the new over function.
         */
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee) {
                return apply(iteratee, thisArg, args);
              });
            });
          });
        }

        /**
         * Creates the padding for `string` based on `length`. The `chars` string
         * is truncated if the number of characters exceeds `length`.
         *
         * @private
         * @param {number} length The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padding for `string`.
         */
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? ' ' : baseToString(chars);

          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars)
            ? castSlice(stringToArray(result), 0, length).join('')
            : result.slice(0, length);
        }

        /**
         * Creates a function that wraps `func` to invoke it with the `this` binding
         * of `thisArg` and `partials` prepended to the arguments it receives.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} partials The arguments to prepend to those provided to
         *  the new function.
         * @returns {Function} Returns the new wrapped function.
         */
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func);

          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength),
                fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }

        /**
         * Creates a `_.range` or `_.rangeRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new range function.
         */
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            // Ensure the sign of `-0` is preserved.
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }

        /**
         * Creates a function that performs a relational operation on two values.
         *
         * @private
         * @param {Function} operator The function to perform the operation.
         * @returns {Function} Returns the new relational operation function.
         */
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == 'string' && typeof other == 'string')) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }

        /**
         * Creates a function that wraps `func` to continue currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {Function} wrapFunc The function to create the `func` wrapper.
         * @param {*} placeholder The placeholder value.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to
         *  the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG,
              newHolders = isCurry ? holders : undefined$1,
              newHoldersRight = isCurry ? undefined$1 : holders,
              newPartials = isCurry ? partials : undefined$1,
              newPartialsRight = isCurry ? undefined$1 : partials;

          bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
            newHoldersRight, argPos, ary, arity
          ];

          var result = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result, newData);
          }
          result.placeholder = placeholder;
          return setWrapToString(result, func, bitmask);
        }

        /**
         * Creates a function like `_.round`.
         *
         * @private
         * @param {string} methodName The name of the `Math` method to use when rounding.
         * @returns {Function} Returns the new round function.
         */
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              // Shift with exponential notation to avoid floating-point issues.
              // See [MDN](https://mdn.io/round#Examples) for more details.
              var pair = (toString(number) + 'e').split('e'),
                  value = func(pair[0] + 'e' + (+pair[1] + precision));

              pair = (toString(value) + 'e').split('e');
              return +(pair[0] + 'e' + (+pair[1] - precision));
            }
            return func(number);
          };
        }

        /**
         * Creates a set object of `values`.
         *
         * @private
         * @param {Array} values The values to add to the set.
         * @returns {Object} Returns the new set.
         */
        var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
          return new Set(values);
        };

        /**
         * Creates a `_.toPairs` or `_.toPairsIn` function.
         *
         * @private
         * @param {Function} keysFunc The function to get the keys of a given object.
         * @returns {Function} Returns the new pairs function.
         */
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }

        /**
         * Creates a function that either curries or invokes `func` with optional
         * `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask flags.
         *    1 - `_.bind`
         *    2 - `_.bindKey`
         *    4 - `_.curry` or `_.curryRight` of a bound function
         *    8 - `_.curry`
         *   16 - `_.curryRight`
         *   32 - `_.partial`
         *   64 - `_.partialRight`
         *  128 - `_.rearg`
         *  256 - `_.ary`
         *  512 - `_.flip`
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to be partially applied.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;

          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;

            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);

          var newData = [
            func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
            argPos, ary, arity
          ];

          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1
            ? (isBindKey ? 0 : func.length)
            : nativeMax(newData[9] - length, 0);

          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result = createPartial(func, bitmask, thisArg, partials);
          } else {
            result = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result, newData), func, bitmask);
        }

        /**
         * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
         * of source objects to the destination object for all destination properties
         * that resolve to `undefined`.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to assign.
         * @param {Object} object The parent object of `objValue`.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined$1 ||
              (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            return srcValue;
          }
          return objValue;
        }

        /**
         * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
         * objects into destination objects that are passed thru.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to merge.
         * @param {Object} object The parent object of `objValue`.
         * @param {Object} source The parent object of `srcValue`.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack['delete'](srcValue);
          }
          return objValue;
        }

        /**
         * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
         * objects.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {string} key The key of the property to inspect.
         * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
         */
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined$1 : value;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `array` and `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              arrLength = array.length,
              othLength = other.length;

          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          // Check that cyclic values are equal.
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1,
              result = true,
              seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

          stack.set(array, other);
          stack.set(other, array);

          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, arrValue, index, other, array, stack)
                : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
              if (!arraySome(other, function(othValue, othIndex) {
                    if (!cacheHas(seen, othIndex) &&
                        (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                      return seen.push(othIndex);
                    }
                  })) {
                result = false;
                break;
              }
            } else if (!(
                  arrValue === othValue ||
                    equalFunc(arrValue, othValue, bitmask, customizer, stack)
                )) {
              result = false;
              break;
            }
          }
          stack['delete'](array);
          stack['delete'](other);
          return result;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if ((object.byteLength != other.byteLength) ||
                  (object.byteOffset != other.byteOffset)) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;

            case arrayBufferTag:
              if ((object.byteLength != other.byteLength) ||
                  !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;

            case boolTag:
            case dateTag:
            case numberTag:
              // Coerce booleans to `1` or `0` and dates to milliseconds.
              // Invalid dates are coerced to `NaN`.
              return eq(+object, +other);

            case errorTag:
              return object.name == other.name && object.message == other.message;

            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings, primitives and objects,
              // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
              // for more details.
              return object == (other + '');

            case mapTag:
              var convert = mapToArray;

            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);

              if (object.size != other.size && !isPartial) {
                return false;
              }
              // Assume cyclic values are equal.
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;

              // Recursively compare objects (susceptible to call stack limits).
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack['delete'](object);
              return result;

            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              objProps = getAllKeys(object),
              objLength = objProps.length,
              othProps = getAllKeys(other),
              othLength = othProps.length;

          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          // Check that cyclic values are equal.
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);

          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, objValue, key, other, object, stack)
                : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined$1
                  ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
                  : compared
                )) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;

            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                  typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack['delete'](object);
          stack['delete'](other);
          return result;
        }

        /**
         * A specialized version of `baseRest` which flattens the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + '');
        }

        /**
         * Creates an array of own enumerable property names and symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }

        /**
         * Creates an array of own and inherited enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }

        /**
         * Gets metadata for `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {*} Returns the metadata for `func`.
         */
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };

        /**
         * Gets the name of `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {string} Returns the function name.
         */
        function getFuncName(func) {
          var result = (func.name + ''),
              array = realNames[result],
              length = hasOwnProperty.call(realNames, result) ? array.length : 0;

          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }

        /**
         * Gets the argument placeholder value for `func`.
         *
         * @private
         * @param {Function} func The function to inspect.
         * @returns {*} Returns the placeholder value.
         */
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
          return object.placeholder;
        }

        /**
         * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
         * this function returns the custom method, otherwise it returns `baseIteratee`.
         * If arguments are provided, the chosen function is invoked with them and
         * its result is returned.
         *
         * @private
         * @param {*} [value] The value to convert to an iteratee.
         * @param {number} [arity] The arity of the created iteratee.
         * @returns {Function} Returns the chosen function or its result.
         */
        function getIteratee() {
          var result = lodash.iteratee || iteratee;
          result = result === iteratee ? baseIteratee : result;
          return arguments.length ? result(arguments[0], arguments[1]) : result;
        }

        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key)
            ? data[typeof key == 'string' ? 'string' : 'hash']
            : data.map;
        }

        /**
         * Gets the property names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
          var result = keys(object),
              length = result.length;

          while (length--) {
            var key = result[length],
                value = object[key];

            result[length] = [key, value, isStrictComparable(value)];
          }
          return result;
        }

        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined$1;
        }

        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag),
              tag = value[symToStringTag];

          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e) {}

          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result;
        }

        /**
         * Creates an array of the own enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };

        /**
         * Creates an array of the own and inherited enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result = [];
          while (object) {
            arrayPush(result, getSymbols(object));
            object = getPrototype(object);
          }
          return result;
        };

        /**
         * Gets the `toStringTag` of `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        var getTag = baseGetTag;

        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
        if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
            (Map && getTag(new Map) != mapTag) ||
            (Promise && getTag(Promise.resolve()) != promiseTag) ||
            (Set && getTag(new Set) != setTag) ||
            (WeakMap && getTag(new WeakMap) != weakMapTag)) {
          getTag = function(value) {
            var result = baseGetTag(value),
                Ctor = result == objectTag ? value.constructor : undefined$1,
                ctorString = Ctor ? toSource(Ctor) : '';

            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString: return dataViewTag;
                case mapCtorString: return mapTag;
                case promiseCtorString: return promiseTag;
                case setCtorString: return setTag;
                case weakMapCtorString: return weakMapTag;
              }
            }
            return result;
          };
        }

        /**
         * Gets the view, applying any `transforms` to the `start` and `end` positions.
         *
         * @private
         * @param {number} start The start of the view.
         * @param {number} end The end of the view.
         * @param {Array} transforms The transformations to apply to the view.
         * @returns {Object} Returns an object containing the `start` and `end`
         *  positions of the view.
         */
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;

          while (++index < length) {
            var data = transforms[index],
                size = data.size;

            switch (data.type) {
              case 'drop':      start += size; break;
              case 'dropRight': end -= size; break;
              case 'take':      end = nativeMin(end, start + size); break;
              case 'takeRight': start = nativeMax(start, end - size); break;
            }
          }
          return { 'start': start, 'end': end };
        }

        /**
         * Extracts wrapper details from the `source` body comment.
         *
         * @private
         * @param {string} source The source to inspect.
         * @returns {Array} Returns the wrapper details.
         */
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }

        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);

          var index = -1,
              length = path.length,
              result = false;

          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result || ++index != length) {
            return result;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) &&
            (isArray(object) || isArguments(object));
        }

        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);

          // Add properties assigned by `RegExp#exec`.
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }

        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject(object) {
          return (typeof object.constructor == 'function' && !isPrototype(object))
            ? baseCreate(getPrototype(object))
            : {};
        }

        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);

            case boolTag:
            case dateTag:
              return new Ctor(+object);

            case dataViewTag:
              return cloneDataView(object, isDeep);

            case float32Tag: case float64Tag:
            case int8Tag: case int16Tag: case int32Tag:
            case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
              return cloneTypedArray(object, isDeep);

            case mapTag:
              return new Ctor;

            case numberTag:
            case stringTag:
              return new Ctor(object);

            case regexpTag:
              return cloneRegExp(object);

            case setTag:
              return new Ctor;

            case symbolTag:
              return cloneSymbol(object);
          }
        }

        /**
         * Inserts wrapper `details` in a comment at the top of the `source` body.
         *
         * @private
         * @param {string} source The source to modify.
         * @returns {Array} details The details to insert.
         * @returns {string} Returns the modified source.
         */
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
          details = details.join(length > 2 ? ', ' : ' ');
          return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
        }

        /**
         * Checks if `value` is a flattenable `arguments` object or array.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
         */
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) ||
            !!(spreadableSymbol && value && value[spreadableSymbol]);
        }

        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;

          return !!length &&
            (type == 'number' ||
              (type != 'symbol' && reIsUint.test(value))) &&
                (value > -1 && value % 1 == 0 && value < length);
        }

        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number'
                ? (isArrayLike(object) && isIndex(index, object.length))
                : (type == 'string' && index in object)
              ) {
            return eq(object[index], value);
          }
          return false;
        }

        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == 'number' || type == 'symbol' || type == 'boolean' ||
              value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
            (object != null && value in Object(object));
        }

        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */
        function isKeyable(value) {
          var type = typeof value;
          return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
            ? (value !== '__proto__')
            : (value === null);
        }

        /**
         * Checks if `func` has a lazy counterpart.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
         *  else `false`.
         */
        function isLaziable(func) {
          var funcName = getFuncName(func),
              other = lodash[funcName];

          if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }

        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */
        function isMasked(func) {
          return !!maskSrcKey && (maskSrcKey in func);
        }

        /**
         * Checks if `func` is capable of being masked.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
         */
        var isMaskable = coreJsData ? isFunction : stubFalse;

        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */
        function isPrototype(value) {
          var Ctor = value && value.constructor,
              proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

          return value === proto;
        }

        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }

        /**
         * A specialized version of `matchesProperty` for source values suitable
         * for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue &&
              (srcValue !== undefined$1 || (key in Object(object)));
          };
        }

        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */
        function memoizeCapped(func) {
          var result = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });

          var cache = result.cache;
          return result;
        }

        /**
         * Merges the function metadata of `source` into `data`.
         *
         * Merging metadata reduces the number of wrappers used to invoke a function.
         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
         * may be applied regardless of execution order. Methods like `_.ary` and
         * `_.rearg` modify function arguments, making the order in which they are
         * executed important, preventing the merging of metadata. However, we make
         * an exception for a safe combined case where curried functions have `_.ary`
         * and or `_.rearg` applied.
         *
         * @private
         * @param {Array} data The destination metadata.
         * @param {Array} source The source metadata.
         * @returns {Array} Returns `data`.
         */
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

          var isCombo =
            ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
            ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
            ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

          // Exit early if metadata can't be merged.
          if (!(isCommon || isCombo)) {
            return data;
          }
          // Use source `thisArg` if available.
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            // Set when currying a bound function.
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          // Compose partial arguments.
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          // Compose partial right arguments.
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          // Use source `argPos` if available.
          value = source[7];
          if (value) {
            data[7] = value;
          }
          // Use source `ary` if it's smaller.
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          // Use source `arity` if one is not provided.
          if (data[9] == null) {
            data[9] = source[9];
          }
          // Use source `func` and merge bitmasks.
          data[0] = source[0];
          data[1] = newBitmask;

          return data;
        }

        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function nativeKeysIn(object) {
          var result = [];
          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }

        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */
        function overRest(func, start, transform) {
          start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);

            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform(array);
            return apply(func, this, otherArgs);
          };
        }

        /**
         * Gets the parent value at `path` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path to get the parent value of.
         * @returns {*} Returns the parent value.
         */
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }

        /**
         * Reorder `array` according to the specified indexes where the element at
         * the first index is assigned as the first element, the element at
         * the second index is assigned as the second element, and so on.
         *
         * @private
         * @param {Array} array The array to reorder.
         * @param {Array} indexes The arranged array indexes.
         * @returns {Array} Returns `array`.
         */
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = copyArray(array);

          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array;
        }

        /**
         * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function safeGet(object, key) {
          if (key === 'constructor' && typeof object[key] === 'function') {
            return;
          }

          if (key == '__proto__') {
            return;
          }

          return object[key];
        }

        /**
         * Sets metadata for `func`.
         *
         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
         * period of time, it will trip its breaker and transition to an identity
         * function to avoid garbage collection pauses in V8. See
         * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
         * for more details.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var setData = shortOut(baseSetData);

        /**
         * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @returns {number|Object} Returns the timer id or timeout object.
         */
        var setTimeout = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };

        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var setToString = shortOut(baseSetToString);

        /**
         * Sets the `toString` method of `wrapper` to mimic the source of `reference`
         * with wrapper details in a comment at the top of the source body.
         *
         * @private
         * @param {Function} wrapper The function to modify.
         * @param {Function} reference The reference function.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @returns {Function} Returns `wrapper`.
         */
        function setWrapToString(wrapper, reference, bitmask) {
          var source = (reference + '');
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }

        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */
        function shortOut(func) {
          var count = 0,
              lastCalled = 0;

          return function() {
            var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled);

            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }

        /**
         * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
         *
         * @private
         * @param {Array} array The array to shuffle.
         * @param {number} [size=array.length] The size of `array`.
         * @returns {Array} Returns `array`.
         */
        function shuffleSelf(array, size) {
          var index = -1,
              length = array.length,
              lastIndex = length - 1;

          size = size === undefined$1 ? length : size;
          while (++index < size) {
            var rand = baseRandom(index, lastIndex),
                value = array[rand];

            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size;
          return array;
        }

        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */
        var stringToPath = memoizeCapped(function(string) {
          var result = [];
          if (string.charCodeAt(0) === 46 /* . */) {
            result.push('');
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        });

        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */
        function toKey(value) {
          if (typeof value == 'string' || isSymbol(value)) {
            return value;
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }

        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {}
            try {
              return (func + '');
            } catch (e) {}
          }
          return '';
        }

        /**
         * Updates wrapper `details` based on `bitmask` flags.
         *
         * @private
         * @returns {Array} details The details to modify.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @returns {Array} Returns `details`.
         */
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = '_.' + pair[0];
            if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }

        /**
         * Creates a clone of `wrapper`.
         *
         * @private
         * @param {Object} wrapper The wrapper to clone.
         * @returns {Object} Returns the cloned wrapper.
         */
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result.__actions__ = copyArray(wrapper.__actions__);
          result.__index__  = wrapper.__index__;
          result.__values__ = wrapper.__values__;
          return result;
        }

        /*------------------------------------------------------------------------*/

        /**
         * Creates an array of elements split into groups the length of `size`.
         * If `array` can't be split evenly, the final chunk will be the remaining
         * elements.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to process.
         * @param {number} [size=1] The length of each chunk
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the new array of chunks.
         * @example
         *
         * _.chunk(['a', 'b', 'c', 'd'], 2);
         * // => [['a', 'b'], ['c', 'd']]
         *
         * _.chunk(['a', 'b', 'c', 'd'], 3);
         * // => [['a', 'b', 'c'], ['d']]
         */
        function chunk(array, size, guard) {
          if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
            size = 1;
          } else {
            size = nativeMax(toInteger(size), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size < 1) {
            return [];
          }
          var index = 0,
              resIndex = 0,
              result = Array(nativeCeil(length / size));

          while (index < length) {
            result[resIndex++] = baseSlice(array, index, (index += size));
          }
          return result;
        }

        /**
         * Creates an array with all falsey values removed. The values `false`, `null`,
         * `0`, `""`, `undefined`, and `NaN` are falsey.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to compact.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.compact([0, 1, false, 2, '', 3]);
         * // => [1, 2, 3]
         */
        function compact(array) {
          var index = -1,
              length = array == null ? 0 : array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index];
            if (value) {
              result[resIndex++] = value;
            }
          }
          return result;
        }

        /**
         * Creates a new array concatenating `array` with any additional arrays
         * and/or values.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to concatenate.
         * @param {...*} [values] The values to concatenate.
         * @returns {Array} Returns the new concatenated array.
         * @example
         *
         * var array = [1];
         * var other = _.concat(array, 2, [3], [[4]]);
         *
         * console.log(other);
         * // => [1, 2, 3, [4]]
         *
         * console.log(array);
         * // => [1]
         */
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array(length - 1),
              array = arguments[0],
              index = length;

          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }

        /**
         * Creates an array of `array` values not included in the other given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. The order and references of result values are
         * determined by the first array.
         *
         * **Note:** Unlike `_.pullAll`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.without, _.xor
         * @example
         *
         * _.difference([2, 1], [2, 3]);
         * // => [1]
         */
        var difference = baseRest(function(array, values) {
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
            : [];
        });

        /**
         * This method is like `_.difference` except that it accepts `iteratee` which
         * is invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The order and references of result values are
         * determined by the first array. The iteratee is invoked with one argument:
         * (value).
         *
         * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        var differenceBy = baseRest(function(array, values) {
          var iteratee = last(values);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined$1;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
            : [];
        });

        /**
         * This method is like `_.difference` except that it accepts `comparator`
         * which is invoked to compare elements of `array` to `values`. The order and
         * references of result values are determined by the first array. The comparator
         * is invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         *
         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }]
         */
        var differenceWith = baseRest(function(array, values) {
          var comparator = last(values);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
            : [];
        });

        /**
         * Creates a slice of `array` with `n` elements dropped from the beginning.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.drop([1, 2, 3]);
         * // => [2, 3]
         *
         * _.drop([1, 2, 3], 2);
         * // => [3]
         *
         * _.drop([1, 2, 3], 5);
         * // => []
         *
         * _.drop([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }

        /**
         * Creates a slice of `array` with `n` elements dropped from the end.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRight([1, 2, 3]);
         * // => [1, 2]
         *
         * _.dropRight([1, 2, 3], 2);
         * // => [1]
         *
         * _.dropRight([1, 2, 3], 5);
         * // => []
         *
         * _.dropRight([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }

        /**
         * Creates a slice of `array` excluding elements dropped from the end.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.dropRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropRightWhile(users, ['active', false]);
         * // => objects for ['barney']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropRightWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropRightWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), true, true)
            : [];
        }

        /**
         * Creates a slice of `array` excluding elements dropped from the beginning.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.dropWhile(users, function(o) { return !o.active; });
         * // => objects for ['pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropWhile(users, ['active', false]);
         * // => objects for ['pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), true)
            : [];
        }

        /**
         * Fills elements of `array` with `value` from `start` up to, but not
         * including, `end`.
         *
         * **Note:** This method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Array
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.fill(array, 'a');
         * console.log(array);
         * // => ['a', 'a', 'a']
         *
         * _.fill(Array(3), 2);
         * // => [2, 2, 2]
         *
         * _.fill([4, 6, 8, 10], '*', 1, 3);
         * // => [4, '*', '*', 10]
         */
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }

        /**
         * This method is like `_.find` except that it returns the index of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.findIndex(users, function(o) { return o.user == 'barney'; });
         * // => 0
         *
         * // The `_.matches` iteratee shorthand.
         * _.findIndex(users, { 'user': 'fred', 'active': false });
         * // => 1
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findIndex(users, ['active', false]);
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.findIndex(users, 'active');
         * // => 2
         */
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }

        /**
         * This method is like `_.findIndex` except that it iterates over elements
         * of `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
         * // => 2
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastIndex(users, { 'user': 'barney', 'active': true });
         * // => 0
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastIndex(users, ['active', false]);
         * // => 2
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastIndex(users, 'active');
         * // => 0
         */
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = fromIndex < 0
              ? nativeMax(length + index, 0)
              : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }

        /**
         * Flattens `array` a single level deep.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, [3, [4]], 5]]);
         * // => [1, 2, [3, [4]], 5]
         */
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }

        /**
         * Recursively flattens `array`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flattenDeep([1, [2, [3, [4]], 5]]);
         * // => [1, 2, 3, 4, 5]
         */
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }

        /**
         * Recursively flatten `array` up to `depth` times.
         *
         * @static
         * @memberOf _
         * @since 4.4.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * var array = [1, [2, [3, [4]], 5]];
         *
         * _.flattenDepth(array, 1);
         * // => [1, 2, [3, [4]], 5]
         *
         * _.flattenDepth(array, 2);
         * // => [1, 2, 3, [4], 5]
         */
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }

        /**
         * The inverse of `_.toPairs`; this method returns an object composed
         * from key-value `pairs`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} pairs The key-value pairs.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.fromPairs([['a', 1], ['b', 2]]);
         * // => { 'a': 1, 'b': 2 }
         */
        function fromPairs(pairs) {
          var index = -1,
              length = pairs == null ? 0 : pairs.length,
              result = {};

          while (++index < length) {
            var pair = pairs[index];
            result[pair[0]] = pair[1];
          }
          return result;
        }

        /**
         * Gets the first element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias first
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the first element of `array`.
         * @example
         *
         * _.head([1, 2, 3]);
         * // => 1
         *
         * _.head([]);
         * // => undefined
         */
        function head(array) {
          return (array && array.length) ? array[0] : undefined$1;
        }

        /**
         * Gets the index at which the first occurrence of `value` is found in `array`
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it's used as the
         * offset from the end of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.indexOf([1, 2, 1, 2], 2);
         * // => 1
         *
         * // Search from the `fromIndex`.
         * _.indexOf([1, 2, 1, 2], 2, 2);
         * // => 3
         */
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }

        /**
         * Gets all but the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.initial([1, 2, 3]);
         * // => [1, 2]
         */
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }

        /**
         * Creates an array of unique values that are included in all given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. The order and references of result values are
         * determined by the first array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersection([2, 1], [2, 3]);
         * // => [2]
         */
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped)
            : [];
        });

        /**
         * This method is like `_.intersection` except that it accepts `iteratee`
         * which is invoked for each element of each `arrays` to generate the criterion
         * by which they're compared. The order and references of result values are
         * determined by the first array. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [2.1]
         *
         * // The `_.property` iteratee shorthand.
         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }]
         */
        var intersectionBy = baseRest(function(arrays) {
          var iteratee = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);

          if (iteratee === last(mapped)) {
            iteratee = undefined$1;
          } else {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped, getIteratee(iteratee, 2))
            : [];
        });

        /**
         * This method is like `_.intersection` except that it accepts `comparator`
         * which is invoked to compare elements of `arrays`. The order and references
         * of result values are determined by the first array. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.intersectionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }]
         */
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);

          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped, undefined$1, comparator)
            : [];
        });

        /**
         * Converts all elements in `array` into a string separated by `separator`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to convert.
         * @param {string} [separator=','] The element separator.
         * @returns {string} Returns the joined string.
         * @example
         *
         * _.join(['a', 'b', 'c'], '~');
         * // => 'a~b~c'
         */
        function join(array, separator) {
          return array == null ? '' : nativeJoin.call(array, separator);
        }

        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }

        /**
         * This method is like `_.indexOf` except that it iterates over elements of
         * `array` from right to left.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.lastIndexOf([1, 2, 1, 2], 2);
         * // => 3
         *
         * // Search from the `fromIndex`.
         * _.lastIndexOf([1, 2, 1, 2], 2, 2);
         * // => 1
         */
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value
            ? strictLastIndexOf(array, value, index)
            : baseFindIndex(array, baseIsNaN, index, true);
        }

        /**
         * Gets the element at index `n` of `array`. If `n` is negative, the nth
         * element from the end is returned.
         *
         * @static
         * @memberOf _
         * @since 4.11.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=0] The index of the element to return.
         * @returns {*} Returns the nth element of `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'd'];
         *
         * _.nth(array, 1);
         * // => 'b'
         *
         * _.nth(array, -2);
         * // => 'c';
         */
        function nth(array, n) {
          return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
        }

        /**
         * Removes all given values from `array` using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
         * to remove elements from an array by predicate.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...*} [values] The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
         *
         * _.pull(array, 'a', 'c');
         * console.log(array);
         * // => ['b', 'b']
         */
        var pull = baseRest(pullAll);

        /**
         * This method is like `_.pull` except that it accepts an array of values to remove.
         *
         * **Note:** Unlike `_.difference`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
         *
         * _.pullAll(array, ['a', 'c']);
         * console.log(array);
         * // => ['b', 'b']
         */
        function pullAll(array, values) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values)
            : array;
        }

        /**
         * This method is like `_.pullAll` except that it accepts `iteratee` which is
         * invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The iteratee is invoked with one argument: (value).
         *
         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
         *
         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
         * console.log(array);
         * // => [{ 'x': 2 }]
         */
        function pullAllBy(array, values, iteratee) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values, getIteratee(iteratee, 2))
            : array;
        }

        /**
         * This method is like `_.pullAll` except that it accepts `comparator` which
         * is invoked to compare elements of `array` to `values`. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
         *
         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
         * console.log(array);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
         */
        function pullAllWith(array, values, comparator) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values, undefined$1, comparator)
            : array;
        }

        /**
         * Removes elements from `array` corresponding to `indexes` and returns an
         * array of removed elements.
         *
         * **Note:** Unlike `_.at`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...(number|number[])} [indexes] The indexes of elements to remove.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = ['a', 'b', 'c', 'd'];
         * var pulled = _.pullAt(array, [1, 3]);
         *
         * console.log(array);
         * // => ['a', 'c']
         *
         * console.log(pulled);
         * // => ['b', 'd']
         */
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length,
              result = baseAt(array, indexes);

          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));

          return result;
        });

        /**
         * Removes all elements from `array` that `predicate` returns truthy for
         * and returns an array of the removed elements. The predicate is invoked
         * with three arguments: (value, index, array).
         *
         * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
         * to pull elements from an array by value.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [1, 2, 3, 4];
         * var evens = _.remove(array, function(n) {
         *   return n % 2 == 0;
         * });
         *
         * console.log(array);
         * // => [1, 3]
         *
         * console.log(evens);
         * // => [2, 4]
         */
        function remove(array, predicate) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;

          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }

        /**
         * Reverses `array` so that the first element becomes the last, the second
         * element becomes the second to last, and so on.
         *
         * **Note:** This method mutates `array` and is based on
         * [`Array#reverse`](https://mdn.io/Array/reverse).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.reverse(array);
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }

        /**
         * Creates a slice of `array` from `start` up to, but not including, `end`.
         *
         * **Note:** This method is used instead of
         * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
         * returned.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }

        /**
         * Uses a binary search to determine the lowest index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedIndex([30, 50], 40);
         * // => 1
         */
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }

        /**
         * This method is like `_.sortedIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * var objects = [{ 'x': 4 }, { 'x': 5 }];
         *
         * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
         * // => 0
         */
        function sortedIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
        }

        /**
         * This method is like `_.indexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
         * // => 1
         */
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * This method is like `_.sortedIndex` except that it returns the highest
         * index at which `value` should be inserted into `array` in order to
         * maintain its sort order.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
         * // => 4
         */
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }

        /**
         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * var objects = [{ 'x': 4 }, { 'x': 5 }];
         *
         * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
         * // => 1
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
         * // => 1
         */
        function sortedLastIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
        }

        /**
         * This method is like `_.lastIndexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
         * // => 3
         */
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * This method is like `_.uniq` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniq([1, 1, 2]);
         * // => [1, 2]
         */
        function sortedUniq(array) {
          return (array && array.length)
            ? baseSortedUniq(array)
            : [];
        }

        /**
         * This method is like `_.uniqBy` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
         * // => [1.1, 2.3]
         */
        function sortedUniqBy(array, iteratee) {
          return (array && array.length)
            ? baseSortedUniq(array, getIteratee(iteratee, 2))
            : [];
        }

        /**
         * Gets all but the first element of `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.tail([1, 2, 3]);
         * // => [2, 3]
         */
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }

        /**
         * Creates a slice of `array` with `n` elements taken from the beginning.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.take([1, 2, 3]);
         * // => [1]
         *
         * _.take([1, 2, 3], 2);
         * // => [1, 2]
         *
         * _.take([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.take([1, 2, 3], 0);
         * // => []
         */
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }

        /**
         * Creates a slice of `array` with `n` elements taken from the end.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRight([1, 2, 3]);
         * // => [3]
         *
         * _.takeRight([1, 2, 3], 2);
         * // => [2, 3]
         *
         * _.takeRight([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.takeRight([1, 2, 3], 0);
         * // => []
         */
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }

        /**
         * Creates a slice of `array` with elements taken from the end. Elements are
         * taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.takeRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeRightWhile(users, ['active', false]);
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeRightWhile(users, 'active');
         * // => []
         */
        function takeRightWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), false, true)
            : [];
        }

        /**
         * Creates a slice of `array` with elements taken from the beginning. Elements
         * are taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.takeWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeWhile(users, ['active', false]);
         * // => objects for ['barney', 'fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeWhile(users, 'active');
         * // => []
         */
        function takeWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3))
            : [];
        }

        /**
         * Creates an array of unique values, in order, from all given arrays using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.union([2], [1, 2]);
         * // => [2, 1]
         */
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });

        /**
         * This method is like `_.union` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by
         * which uniqueness is computed. Result values are chosen from the first
         * array in which the value occurs. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.unionBy([2.1], [1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        var unionBy = baseRest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
        });

        /**
         * This method is like `_.union` except that it accepts `comparator` which
         * is invoked to compare elements of `arrays`. Result values are chosen from
         * the first array in which the value occurs. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.unionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });

        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons, in which only the first occurrence of each element
         * is kept. The order of result values is determined by the order they occur
         * in the array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         */
        function uniq(array) {
          return (array && array.length) ? baseUniq(array) : [];
        }

        /**
         * This method is like `_.uniq` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * uniqueness is computed. The order of result values is determined by the
         * order they occur in the array. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniqBy(array, iteratee) {
          return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
        }

        /**
         * This method is like `_.uniq` except that it accepts `comparator` which
         * is invoked to compare elements of `array`. The order of result values is
         * determined by the order they occur in the array.The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.uniqWith(objects, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
         */
        function uniqWith(array, comparator) {
          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
        }

        /**
         * This method is like `_.zip` except that it accepts an array of grouped
         * elements and creates an array regrouping the elements to their pre-zip
         * configuration.
         *
         * @static
         * @memberOf _
         * @since 1.2.0
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
         * // => [['a', 1, true], ['b', 2, false]]
         *
         * _.unzip(zipped);
         * // => [['a', 'b'], [1, 2], [true, false]]
         */
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }

        /**
         * This method is like `_.unzip` except that it accepts `iteratee` to specify
         * how regrouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @param {Function} [iteratee=_.identity] The function to combine
         *  regrouped values.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
         * // => [[1, 10, 100], [2, 20, 200]]
         *
         * _.unzipWith(zipped, _.add);
         * // => [3, 30, 300]
         */
        function unzipWith(array, iteratee) {
          if (!(array && array.length)) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          return arrayMap(result, function(group) {
            return apply(iteratee, undefined$1, group);
          });
        }

        /**
         * Creates an array excluding all given values using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.pull`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...*} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.difference, _.xor
         * @example
         *
         * _.without([2, 1, 2, 3], 1, 2);
         * // => [3]
         */
        var without = baseRest(function(array, values) {
          return isArrayLikeObject(array)
            ? baseDifference(array, values)
            : [];
        });

        /**
         * Creates an array of unique values that is the
         * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
         * of the given arrays. The order of result values is determined by the order
         * they occur in the arrays.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.difference, _.without
         * @example
         *
         * _.xor([2, 1], [2, 3]);
         * // => [1, 3]
         */
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });

        /**
         * This method is like `_.xor` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by
         * which by which they're compared. The order of result values is determined
         * by the order they occur in the arrays. The iteratee is invoked with one
         * argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [1.2, 3.4]
         *
         * // The `_.property` iteratee shorthand.
         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        var xorBy = baseRest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
        });

        /**
         * This method is like `_.xor` except that it accepts `comparator` which is
         * invoked to compare elements of `arrays`. The order of result values is
         * determined by the order they occur in the arrays. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.xorWith(objects, others, _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });

        /**
         * Creates an array of grouped elements, the first of which contains the
         * first elements of the given arrays, the second of which contains the
         * second elements of the given arrays, and so on.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zip(['a', 'b'], [1, 2], [true, false]);
         * // => [['a', 1, true], ['b', 2, false]]
         */
        var zip = baseRest(unzip);

        /**
         * This method is like `_.fromPairs` except that it accepts two arrays,
         * one of property identifiers and one of corresponding values.
         *
         * @static
         * @memberOf _
         * @since 0.4.0
         * @category Array
         * @param {Array} [props=[]] The property identifiers.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObject(['a', 'b'], [1, 2]);
         * // => { 'a': 1, 'b': 2 }
         */
        function zipObject(props, values) {
          return baseZipObject(props || [], values || [], assignValue);
        }

        /**
         * This method is like `_.zipObject` except that it supports property paths.
         *
         * @static
         * @memberOf _
         * @since 4.1.0
         * @category Array
         * @param {Array} [props=[]] The property identifiers.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
         * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
         */
        function zipObjectDeep(props, values) {
          return baseZipObject(props || [], values || [], baseSet);
        }

        /**
         * This method is like `_.zip` except that it accepts `iteratee` to specify
         * how grouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @param {Function} [iteratee=_.identity] The function to combine
         *  grouped values.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
         *   return a + b + c;
         * });
         * // => [111, 222]
         */
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length,
              iteratee = length > 1 ? arrays[length - 1] : undefined$1;

          iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
          return unzipWith(arrays, iteratee);
        });

        /*------------------------------------------------------------------------*/

        /**
         * Creates a `lodash` wrapper instance that wraps `value` with explicit method
         * chain sequences enabled. The result of such sequences must be unwrapped
         * with `_#value`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Seq
         * @param {*} value The value to wrap.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36 },
         *   { 'user': 'fred',    'age': 40 },
         *   { 'user': 'pebbles', 'age': 1 }
         * ];
         *
         * var youngest = _
         *   .chain(users)
         *   .sortBy('age')
         *   .map(function(o) {
         *     return o.user + ' is ' + o.age;
         *   })
         *   .head()
         *   .value();
         * // => 'pebbles is 1'
         */
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }

        /**
         * This method invokes `interceptor` and returns `value`. The interceptor
         * is invoked with one argument; (value). The purpose of this method is to
         * "tap into" a method chain sequence in order to modify intermediate results.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns `value`.
         * @example
         *
         * _([1, 2, 3])
         *  .tap(function(array) {
         *    // Mutate input array.
         *    array.pop();
         *  })
         *  .reverse()
         *  .value();
         * // => [2, 1]
         */
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }

        /**
         * This method is like `_.tap` except that it returns the result of `interceptor`.
         * The purpose of this method is to "pass thru" values replacing intermediate
         * results in a method chain sequence.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns the result of `interceptor`.
         * @example
         *
         * _('  abc  ')
         *  .chain()
         *  .trim()
         *  .thru(function(value) {
         *    return [value];
         *  })
         *  .value();
         * // => ['abc']
         */
        function thru(value, interceptor) {
          return interceptor(value);
        }

        /**
         * This method is the wrapper version of `_.at`.
         *
         * @name at
         * @memberOf _
         * @since 1.0.0
         * @category Seq
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _(object).at(['a[0].b.c', 'a[1]']).value();
         * // => [3, 4]
         */
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length,
              start = length ? paths[0] : 0,
              value = this.__wrapped__,
              interceptor = function(object) { return baseAt(object, paths); };

          if (length > 1 || this.__actions__.length ||
              !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            'func': thru,
            'args': [interceptor],
            'thisArg': undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined$1);
            }
            return array;
          });
        });

        /**
         * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
         *
         * @name chain
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // A sequence without explicit chaining.
         * _(users).head();
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // A sequence with explicit chaining.
         * _(users)
         *   .chain()
         *   .head()
         *   .pick('user')
         *   .value();
         * // => { 'user': 'barney' }
         */
        function wrapperChain() {
          return chain(this);
        }

        /**
         * Executes the chain sequence and returns the wrapped result.
         *
         * @name commit
         * @memberOf _
         * @since 3.2.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapped = _(array).push(3);
         *
         * console.log(array);
         * // => [1, 2]
         *
         * wrapped = wrapped.commit();
         * console.log(array);
         * // => [1, 2, 3]
         *
         * wrapped.last();
         * // => 3
         *
         * console.log(array);
         * // => [1, 2, 3]
         */
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }

        /**
         * Gets the next value on a wrapped object following the
         * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
         *
         * @name next
         * @memberOf _
         * @since 4.0.0
         * @category Seq
         * @returns {Object} Returns the next iterator value.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 1 }
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 2 }
         *
         * wrapped.next();
         * // => { 'done': true, 'value': undefined }
         */
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length,
              value = done ? undefined$1 : this.__values__[this.__index__++];

          return { 'done': done, 'value': value };
        }

        /**
         * Enables the wrapper to be iterable.
         *
         * @name Symbol.iterator
         * @memberOf _
         * @since 4.0.0
         * @category Seq
         * @returns {Object} Returns the wrapper object.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped[Symbol.iterator]() === wrapped;
         * // => true
         *
         * Array.from(wrapped);
         * // => [1, 2]
         */
        function wrapperToIterator() {
          return this;
        }

        /**
         * Creates a clone of the chain sequence planting `value` as the wrapped value.
         *
         * @name plant
         * @memberOf _
         * @since 3.2.0
         * @category Seq
         * @param {*} value The value to plant.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2]).map(square);
         * var other = wrapped.plant([3, 4]);
         *
         * other.value();
         * // => [9, 16]
         *
         * wrapped.value();
         * // => [1, 4]
         */
        function wrapperPlant(value) {
          var result,
              parent = this;

          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            clone.__index__ = 0;
            clone.__values__ = undefined$1;
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }

        /**
         * This method is the wrapper version of `_.reverse`.
         *
         * **Note:** This method mutates the wrapped array.
         *
         * @name reverse
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _(array).reverse().value()
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [reverse],
              'thisArg': undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }

        /**
         * Executes the chain sequence to resolve the unwrapped value.
         *
         * @name value
         * @memberOf _
         * @since 0.1.0
         * @alias toJSON, valueOf
         * @category Seq
         * @returns {*} Returns the resolved unwrapped value.
         * @example
         *
         * _([1, 2, 3]).value();
         * // => [1, 2, 3]
         */
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The corresponding value of
         * each key is the number of times the key was returned by `iteratee`. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.countBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': 1, '6': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.countBy(['one', 'two', 'three'], 'length');
         * // => { '3': 2, '5': 1 }
         */
        var countBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            ++result[key];
          } else {
            baseAssignValue(result, key, 1);
          }
        });

        /**
         * Checks if `predicate` returns truthy for **all** elements of `collection`.
         * Iteration is stopped once `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * **Note:** This method returns `true` for
         * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
         * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
         * elements of empty collections.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes'], Boolean);
         * // => false
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.every(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.every(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.every(users, 'active');
         * // => false
         */
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Iterates over elements of `collection`, returning an array of all elements
         * `predicate` returns truthy for. The predicate is invoked with three
         * arguments: (value, index|key, collection).
         *
         * **Note:** Unlike `_.remove`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @see _.reject
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.filter(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, { 'age': 36, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.filter(users, 'active');
         * // => objects for ['barney']
         *
         * // Combining several predicates using `_.overEvery` or `_.overSome`.
         * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
         * // => objects for ['fred', 'barney']
         */
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Iterates over elements of `collection`, returning the first element
         * `predicate` returns truthy for. The predicate is invoked with three
         * arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': true },
         *   { 'user': 'fred',    'age': 40, 'active': false },
         *   { 'user': 'pebbles', 'age': 1,  'active': true }
         * ];
         *
         * _.find(users, function(o) { return o.age < 40; });
         * // => object for 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.find(users, { 'age': 1, 'active': true });
         * // => object for 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.find(users, ['active', false]);
         * // => object for 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.find(users, 'active');
         * // => object for 'barney'
         */
        var find = createFind(findIndex);

        /**
         * This method is like `_.find` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=collection.length-1] The index to search from.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * _.findLast([1, 2, 3, 4], function(n) {
         *   return n % 2 == 1;
         * });
         * // => 3
         */
        var findLast = createFind(findLastIndex);

        /**
         * Creates a flattened array of values by running each element in `collection`
         * thru `iteratee` and flattening the mapped results. The iteratee is invoked
         * with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [n, n];
         * }
         *
         * _.flatMap([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMap(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), 1);
        }

        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDeep([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMapDeep(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), INFINITY);
        }

        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results up to `depth` times.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDepth([1, 2], duplicate, 2);
         * // => [[1, 1], [2, 2]]
         */
        function flatMapDepth(collection, iteratee, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee), depth);
        }

        /**
         * Iterates over elements of `collection` and invokes `iteratee` for each element.
         * The iteratee is invoked with three arguments: (value, index|key, collection).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length"
         * property are iterated like arrays. To avoid this behavior use `_.forIn`
         * or `_.forOwn` for object iteration.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias each
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEachRight
         * @example
         *
         * _.forEach([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `1` then `2`.
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forEach(collection, iteratee) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.forEach` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @alias eachRight
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEach
         * @example
         *
         * _.forEachRight([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `2` then `1`.
         */
        function forEachRight(collection, iteratee) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The order of grouped values
         * is determined by the order they occur in `collection`. The corresponding
         * value of each key is an array of elements responsible for generating the
         * key. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': [4.2], '6': [6.1, 6.3] }
         *
         * // The `_.property` iteratee shorthand.
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            baseAssignValue(result, key, [value]);
          }
        });

        /**
         * Checks if `value` is in `collection`. If `collection` is a string, it's
         * checked for a substring of `value`, otherwise
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * is used for equality comparisons. If `fromIndex` is negative, it's used as
         * the offset from the end of `collection`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
         * @returns {boolean} Returns `true` if `value` is found, else `false`.
         * @example
         *
         * _.includes([1, 2, 3], 1);
         * // => true
         *
         * _.includes([1, 2, 3], 1, 2);
         * // => false
         *
         * _.includes({ 'a': 1, 'b': 2 }, 1);
         * // => true
         *
         * _.includes('abcd', 'bc');
         * // => true
         */
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection)
            ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
            : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
        }

        /**
         * Invokes the method at `path` of each element in `collection`, returning
         * an array of the results of each invoked method. Any additional arguments
         * are provided to each invoked method. If `path` is a function, it's invoked
         * for, and `this` bound to, each element in `collection`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array|Function|string} path The path of the method to invoke or
         *  the function invoked per iteration.
         * @param {...*} [args] The arguments to invoke each method with.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
         * // => [[1, 5, 7], [1, 2, 3]]
         *
         * _.invokeMap([123, 456], String.prototype.split, '');
         * // => [['1', '2', '3'], ['4', '5', '6']]
         */
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              result = isArrayLike(collection) ? Array(collection.length) : [];

          baseEach(collection, function(value) {
            result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result;
        });

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The corresponding value of
         * each key is the last element responsible for generating the key. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * var array = [
         *   { 'dir': 'left', 'code': 97 },
         *   { 'dir': 'right', 'code': 100 }
         * ];
         *
         * _.keyBy(array, function(o) {
         *   return String.fromCharCode(o.code);
         * });
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         *
         * _.keyBy(array, 'dir');
         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
         */
        var keyBy = createAggregator(function(result, value, key) {
          baseAssignValue(result, key, value);
        });

        /**
         * Creates an array of values by running each element in `collection` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * _.map([4, 8], square);
         * // => [16, 64]
         *
         * _.map({ 'a': 4, 'b': 8 }, square);
         * // => [16, 64] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.sortBy` except that it allows specifying the sort
         * orders of the iteratees to sort by. If `orders` is unspecified, all values
         * are sorted in ascending order. Otherwise, specify an order of "desc" for
         * descending or "asc" for ascending sort order of corresponding values.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @param {string[]} [orders] The sort orders of `iteratees`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 34 },
         *   { 'user': 'fred',   'age': 40 },
         *   { 'user': 'barney', 'age': 36 }
         * ];
         *
         * // Sort by `user` in ascending order and by `age` in descending order.
         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
         */
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }

        /**
         * Creates an array of elements split into two groups, the first of which
         * contains elements `predicate` returns truthy for, the second of which
         * contains elements `predicate` returns falsey for. The predicate is
         * invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of grouped elements.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': false },
         *   { 'user': 'fred',    'age': 40, 'active': true },
         *   { 'user': 'pebbles', 'age': 1,  'active': false }
         * ];
         *
         * _.partition(users, function(o) { return o.active; });
         * // => objects for [['fred'], ['barney', 'pebbles']]
         *
         * // The `_.matches` iteratee shorthand.
         * _.partition(users, { 'age': 1, 'active': false });
         * // => objects for [['pebbles'], ['barney', 'fred']]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.partition(users, ['active', false]);
         * // => objects for [['barney', 'pebbles'], ['fred']]
         *
         * // The `_.property` iteratee shorthand.
         * _.partition(users, 'active');
         * // => objects for [['fred'], ['barney', 'pebbles']]
         */
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() { return [[], []]; });

        /**
         * Reduces `collection` to a value which is the accumulated result of running
         * each element in `collection` thru `iteratee`, where each successive
         * invocation is supplied the return value of the previous. If `accumulator`
         * is not given, the first element of `collection` is used as the initial
         * value. The iteratee is invoked with four arguments:
         * (accumulator, value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.reduce`, `_.reduceRight`, and `_.transform`.
         *
         * The guarded methods are:
         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
         * and `sortBy`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @see _.reduceRight
         * @example
         *
         * _.reduce([1, 2], function(sum, n) {
         *   return sum + n;
         * }, 0);
         * // => 3
         *
         * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         *   return result;
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
         */
        function reduce(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce,
              initAccum = arguments.length < 3;

          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }

        /**
         * This method is like `_.reduce` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @see _.reduce
         * @example
         *
         * var array = [[0, 1], [2, 3], [4, 5]];
         *
         * _.reduceRight(array, function(flattened, other) {
         *   return flattened.concat(other);
         * }, []);
         * // => [4, 5, 2, 3, 0, 1]
         */
        function reduceRight(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce,
              initAccum = arguments.length < 3;

          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }

        /**
         * The opposite of `_.filter`; this method returns the elements of `collection`
         * that `predicate` does **not** return truthy for.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @see _.filter
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': true }
         * ];
         *
         * _.reject(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.reject(users, { 'age': 40, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.reject(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.reject(users, 'active');
         * // => objects for ['barney']
         */
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }

        /**
         * Gets a random element from `collection`.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         * @example
         *
         * _.sample([1, 2, 3, 4]);
         * // => 2
         */
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }

        /**
         * Gets `n` random elements at unique keys from `collection` up to the
         * size of `collection`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @param {number} [n=1] The number of elements to sample.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the random elements.
         * @example
         *
         * _.sampleSize([1, 2, 3], 2);
         * // => [3, 1]
         *
         * _.sampleSize([1, 2, 3], 4);
         * // => [2, 3, 1]
         */
        function sampleSize(collection, n, guard) {
          if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }

        /**
         * Creates an array of shuffled values, using a version of the
         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         * @example
         *
         * _.shuffle([1, 2, 3, 4]);
         * // => [4, 1, 3, 2]
         */
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }

        /**
         * Gets the size of `collection` by returning its length for array-like
         * values or the number of own enumerable string keyed properties for objects.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @returns {number} Returns the collection size.
         * @example
         *
         * _.size([1, 2, 3]);
         * // => 3
         *
         * _.size({ 'a': 1, 'b': 2 });
         * // => 2
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }

        /**
         * Checks if `predicate` returns truthy for **any** element of `collection`.
         * Iteration is stopped once `predicate` returns truthy. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var users = [
         *   { 'user': 'barney', 'active': true },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.some(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.some(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.some(users, 'active');
         * // => true
         */
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection thru each iteratee. This method
         * performs a stable sort, that is, it preserves the original sort order of
         * equal elements. The iteratees are invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 30 },
         *   { 'user': 'barney', 'age': 34 }
         * ];
         *
         * _.sortBy(users, [function(o) { return o.user; }]);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
         *
         * _.sortBy(users, ['user', 'age']);
         * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
         */
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });

        /*------------------------------------------------------------------------*/

        /**
         * Gets the timestamp of the number of milliseconds that have elapsed since
         * the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Date
         * @returns {number} Returns the timestamp.
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => Logs the number of milliseconds it took for the deferred invocation.
         */
        var now = ctxNow || function() {
          return root.Date.now();
        };

        /*------------------------------------------------------------------------*/

        /**
         * The opposite of `_.before`; this method creates a function that invokes
         * `func` once it's called `n` or more times.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {number} n The number of calls before `func` is invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var saves = ['profile', 'settings'];
         *
         * var done = _.after(saves.length, function() {
         *   console.log('done saving!');
         * });
         *
         * _.forEach(saves, function(type) {
         *   asyncSave({ 'type': type, 'complete': done });
         * });
         * // => Logs 'done saving!' after the two async saves have completed.
         */
        function after(n, func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }

        /**
         * Creates a function that invokes `func`, with up to `n` arguments,
         * ignoring any additional arguments.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @param {number} [n=func.length] The arity cap.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new capped function.
         * @example
         *
         * _.map(['6', '8', '10'], _.ary(parseInt, 1));
         * // => [6, 8, 10]
         */
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n;
          n = (func && n == null) ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }

        /**
         * Creates a function that invokes `func`, with the `this` binding and arguments
         * of the created function, while it's called less than `n` times. Subsequent
         * calls to the created function return the result of the last `func` invocation.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {number} n The number of calls at which `func` is no longer invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * jQuery(element).on('click', _.before(5, addContactToList));
         * // => Allows adding up to 4 contacts to the list.
         */
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined$1;
            }
            return result;
          };
        }

        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and `partials` prepended to the arguments it receives.
         *
         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for partially applied arguments.
         *
         * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
         * property of bound functions.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * function greet(greeting, punctuation) {
         *   return greeting + ' ' + this.user + punctuation;
         * }
         *
         * var object = { 'user': 'fred' };
         *
         * var bound = _.bind(greet, object, 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bind(greet, object, _, '!');
         * bound('hi');
         * // => 'hi fred!'
         */
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });

        /**
         * Creates a function that invokes the method at `object[key]` with `partials`
         * prepended to the arguments it receives.
         *
         * This method differs from `_.bind` by allowing bound functions to reference
         * methods that may be redefined or don't yet exist. See
         * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
         * for more details.
         *
         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * @static
         * @memberOf _
         * @since 0.10.0
         * @category Function
         * @param {Object} object The object to invoke the method on.
         * @param {string} key The key of the method.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var object = {
         *   'user': 'fred',
         *   'greet': function(greeting, punctuation) {
         *     return greeting + ' ' + this.user + punctuation;
         *   }
         * };
         *
         * var bound = _.bindKey(object, 'greet', 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * object.greet = function(greeting, punctuation) {
         *   return greeting + 'ya ' + this.user + punctuation;
         * };
         *
         * bound('!');
         * // => 'hiya fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bindKey(object, 'greet', _, '!');
         * bound('hi');
         * // => 'hiya fred!'
         */
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });

        /**
         * Creates a function that accepts arguments of `func` and either invokes
         * `func` returning its result, if at least `arity` number of arguments have
         * been provided, or returns a function that accepts the remaining `func`
         * arguments, and so on. The arity of `func` may be specified if `func.length`
         * is not sufficient.
         *
         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curry(abc);
         *
         * curried(1)(2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(1)(_, 3)(2);
         * // => [1, 2, 3]
         */
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result.placeholder = curry.placeholder;
          return result;
        }

        /**
         * This method is like `_.curry` except that arguments are applied to `func`
         * in the manner of `_.partialRight` instead of `_.partial`.
         *
         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curryRight(abc);
         *
         * curried(3)(2)(1);
         * // => [1, 2, 3]
         *
         * curried(2, 3)(1);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(3)(1, _)(2);
         * // => [1, 2, 3]
         */
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result.placeholder = curryRight.placeholder;
          return result;
        }

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed `func` invocations and a `flush` method to immediately invoke them.
         * Provide `options` to indicate whether `func` should be invoked on the
         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
         * with the last arguments provided to the debounced function. Subsequent
         * calls to the debounced function return the result of the last `func`
         * invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the debounced function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=false]
         *  Specify invoking on the leading edge of the timeout.
         * @param {number} [options.maxWait]
         *  The maximum time `func` is allowed to be delayed before it's invoked.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // Avoid costly calculations while the window size is in flux.
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
         * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', debounced);
         *
         * // Cancel the trailing debounced invocation.
         * jQuery(window).on('popstate', debounced.cancel);
         */
        function debounce(func, wait, options) {
          var lastArgs,
              lastThis,
              maxWait,
              result,
              timerId,
              lastCallTime,
              lastInvokeTime = 0,
              leading = false,
              maxing = false,
              trailing = true;

          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }

          function invokeFunc(time) {
            var args = lastArgs,
                thisArg = lastThis;

            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
          }

          function leadingEdge(time) {
            // Reset any `maxWait` timer.
            lastInvokeTime = time;
            // Start the timer for the trailing edge.
            timerId = setTimeout(timerExpired, wait);
            // Invoke the leading edge.
            return leading ? invokeFunc(time) : result;
          }

          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime,
                timeWaiting = wait - timeSinceLastCall;

            return maxing
              ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
              : timeWaiting;
          }

          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime;

            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
              (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
          }

          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            // Restart the timer.
            timerId = setTimeout(timerExpired, remainingWait(time));
          }

          function trailingEdge(time) {
            timerId = undefined$1;

            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result;
          }

          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }

          function flush() {
            return timerId === undefined$1 ? result : trailingEdge(now());
          }

          function debounced() {
            var time = now(),
                isInvoking = shouldInvoke(time);

            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;

            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                // Handle invocations in a tight loop.
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }

        /**
         * Defers invoking the `func` until the current call stack has cleared. Any
         * additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to defer.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) {
         *   console.log(text);
         * }, 'deferred');
         * // => Logs 'deferred' after one millisecond.
         */
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });

        /**
         * Invokes `func` after `wait` milliseconds. Any additional arguments are
         * provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.delay(function(text) {
         *   console.log(text);
         * }, 1000, 'later');
         * // => Logs 'later' after one second.
         */
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });

        /**
         * Creates a function that invokes `func` with arguments reversed.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to flip arguments for.
         * @returns {Function} Returns the new flipped function.
         * @example
         *
         * var flipped = _.flip(function() {
         *   return _.toArray(arguments);
         * });
         *
         * flipped('a', 'b', 'c', 'd');
         * // => ['d', 'c', 'b', 'a']
         */
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }

        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;

            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache);
          return memoized;
        }

        // Expose `MapCache`.
        memoize.Cache = MapCache;

        /**
         * Creates a function that negates the result of the predicate `func`. The
         * `func` predicate is invoked with the `this` binding and arguments of the
         * created function.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} predicate The predicate to negate.
         * @returns {Function} Returns the new negated function.
         * @example
         *
         * function isEven(n) {
         *   return n % 2 == 0;
         * }
         *
         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
         * // => [1, 3, 5]
         */
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0: return !predicate.call(this);
              case 1: return !predicate.call(this, args[0]);
              case 2: return !predicate.call(this, args[0], args[1]);
              case 3: return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }

        /**
         * Creates a function that is restricted to invoking `func` once. Repeat calls
         * to the function return the value of the first invocation. The `func` is
         * invoked with the `this` binding and arguments of the created function.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var initialize = _.once(createApplication);
         * initialize();
         * initialize();
         * // => `createApplication` is invoked once
         */
        function once(func) {
          return before(2, func);
        }

        /**
         * Creates a function that invokes `func` with its arguments transformed.
         *
         * @static
         * @since 4.0.0
         * @memberOf _
         * @category Function
         * @param {Function} func The function to wrap.
         * @param {...(Function|Function[])} [transforms=[_.identity]]
         *  The argument transforms.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function doubled(n) {
         *   return n * 2;
         * }
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var func = _.overArgs(function(x, y) {
         *   return [x, y];
         * }, [square, doubled]);
         *
         * func(9, 3);
         * // => [81, 6]
         *
         * func(10, 5);
         * // => [100, 10]
         */
        var overArgs = castRest(function(func, transforms) {
          transforms = (transforms.length == 1 && isArray(transforms[0]))
            ? arrayMap(transforms[0], baseUnary(getIteratee()))
            : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1,
                length = nativeMin(args.length, funcsLength);

            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });

        /**
         * Creates a function that invokes `func` with `partials` prepended to the
         * arguments it receives. This method is like `_.bind` except it does **not**
         * alter the `this` binding.
         *
         * The `_.partial.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @since 0.2.0
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * function greet(greeting, name) {
         *   return greeting + ' ' + name;
         * }
         *
         * var sayHelloTo = _.partial(greet, 'hello');
         * sayHelloTo('fred');
         * // => 'hello fred'
         *
         * // Partially applied with placeholders.
         * var greetFred = _.partial(greet, _, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         */
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });

        /**
         * This method is like `_.partial` except that partially applied arguments
         * are appended to the arguments it receives.
         *
         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * function greet(greeting, name) {
         *   return greeting + ' ' + name;
         * }
         *
         * var greetFred = _.partialRight(greet, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         *
         * // Partially applied with placeholders.
         * var sayHelloTo = _.partialRight(greet, 'hello', _);
         * sayHelloTo('fred');
         * // => 'hello fred'
         */
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });

        /**
         * Creates a function that invokes `func` with arguments arranged according
         * to the specified `indexes` where the argument value at the first index is
         * provided as the first argument, the argument value at the second index is
         * provided as the second argument, and so on.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to rearrange arguments for.
         * @param {...(number|number[])} indexes The arranged argument indexes.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var rearged = _.rearg(function(a, b, c) {
         *   return [a, b, c];
         * }, [2, 0, 1]);
         *
         * rearged('b', 'c', 'a')
         * // => ['a', 'b', 'c']
         */
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * created function and arguments from `start` and beyond provided as
         * an array.
         *
         * **Note:** This method is based on the
         * [rest parameter](https://mdn.io/rest_parameters).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.rest(function(what, names) {
         *   return what + ' ' + _.initial(names).join(', ') +
         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
         * });
         *
         * say('hello', 'fred', 'barney', 'pebbles');
         * // => 'hello fred, barney, & pebbles'
         */
        function rest(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * create function and an array of arguments much like
         * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
         *
         * **Note:** This method is based on the
         * [spread operator](https://mdn.io/spread_operator).
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Function
         * @param {Function} func The function to spread arguments over.
         * @param {number} [start=0] The start position of the spread.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.spread(function(who, what) {
         *   return who + ' says ' + what;
         * });
         *
         * say(['fred', 'hello']);
         * // => 'fred says hello'
         *
         * var numbers = Promise.all([
         *   Promise.resolve(40),
         *   Promise.resolve(36)
         * ]);
         *
         * numbers.then(_.spread(function(x, y) {
         *   return x + y;
         * }));
         * // => a Promise of 76
         */
        function spread(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start],
                otherArgs = castSlice(args, 0, start);

            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }

        /**
         * Creates a throttled function that only invokes `func` at most once per
         * every `wait` milliseconds. The throttled function comes with a `cancel`
         * method to cancel delayed `func` invocations and a `flush` method to
         * immediately invoke them. Provide `options` to indicate whether `func`
         * should be invoked on the leading and/or trailing edge of the `wait`
         * timeout. The `func` is invoked with the last arguments provided to the
         * throttled function. Subsequent calls to the throttled function return the
         * result of the last `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the throttled function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.throttle` and `_.debounce`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to throttle.
         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=true]
         *  Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // Avoid excessively updating the position while scrolling.
         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
         *
         * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
         * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
         * jQuery(element).on('click', throttled);
         *
         * // Cancel the trailing throttled invocation.
         * jQuery(window).on('popstate', throttled.cancel);
         */
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;

          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': wait,
            'trailing': trailing
          });
        }

        /**
         * Creates a function that accepts up to one argument, ignoring any
         * additional arguments.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         * @example
         *
         * _.map(['6', '8', '10'], _.unary(parseInt));
         * // => [6, 8, 10]
         */
        function unary(func) {
          return ary(func, 1);
        }

        /**
         * Creates a function that provides `value` to `wrapper` as its first
         * argument. Any additional arguments provided to the function are appended
         * to those provided to the `wrapper`. The wrapper is invoked with the `this`
         * binding of the created function.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {*} value The value to wrap.
         * @param {Function} [wrapper=identity] The wrapper function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var p = _.wrap(_.escape, function(func, text) {
         *   return '<p>' + func(text) + '</p>';
         * });
         *
         * p('fred, barney, & pebbles');
         * // => '<p>fred, barney, &amp; pebbles</p>'
         */
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Casts `value` as an array if it's not one.
         *
         * @static
         * @memberOf _
         * @since 4.4.0
         * @category Lang
         * @param {*} value The value to inspect.
         * @returns {Array} Returns the cast array.
         * @example
         *
         * _.castArray(1);
         * // => [1]
         *
         * _.castArray({ 'a': 1 });
         * // => [{ 'a': 1 }]
         *
         * _.castArray('abc');
         * // => ['abc']
         *
         * _.castArray(null);
         * // => [null]
         *
         * _.castArray(undefined);
         * // => [undefined]
         *
         * _.castArray();
         * // => []
         *
         * var array = [1, 2, 3];
         * console.log(_.castArray(array) === array);
         * // => true
         */
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }

        /**
         * Creates a shallow clone of `value`.
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
         * and supports cloning arrays, array buffers, booleans, date objects, maps,
         * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
         * arrays. The own enumerable properties of `arguments` objects are cloned
         * as plain objects. An empty object is returned for uncloneable values such
         * as error objects, functions, DOM nodes, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to clone.
         * @returns {*} Returns the cloned value.
         * @see _.cloneDeep
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var shallow = _.clone(objects);
         * console.log(shallow[0] === objects[0]);
         * // => true
         */
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }

        /**
         * This method is like `_.clone` except that it accepts `customizer` which
         * is invoked to produce the cloned value. If `customizer` returns `undefined`,
         * cloning is handled by the method instead. The `customizer` is invoked with
         * up to four arguments; (value [, index|key, object, stack]).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the cloned value.
         * @see _.cloneDeepWith
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(false);
         *   }
         * }
         *
         * var el = _.cloneWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 0
         */
        function cloneWith(value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }

        /**
         * This method is like `_.clone` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @returns {*} Returns the deep cloned value.
         * @see _.clone
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var deep = _.cloneDeep(objects);
         * console.log(deep[0] === objects[0]);
         * // => false
         */
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }

        /**
         * This method is like `_.cloneWith` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the deep cloned value.
         * @see _.cloneWith
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(true);
         *   }
         * }
         *
         * var el = _.cloneDeepWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 20
         */
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }

        /**
         * Checks if `object` conforms to `source` by invoking the predicate
         * properties of `source` with the corresponding property values of `object`.
         *
         * **Note:** This method is equivalent to `_.conforms` when `source` is
         * partially applied.
         *
         * @static
         * @memberOf _
         * @since 4.14.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property predicates to conform to.
         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         *
         * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
         * // => true
         *
         * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
         * // => false
         */
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }

        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq(value, other) {
          return value === other || (value !== value && other !== other);
        }

        /**
         * Checks if `value` is greater than `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`,
         *  else `false`.
         * @see _.lt
         * @example
         *
         * _.gt(3, 1);
         * // => true
         *
         * _.gt(3, 3);
         * // => false
         *
         * _.gt(1, 3);
         * // => false
         */
        var gt = createRelationalOperation(baseGt);

        /**
         * Checks if `value` is greater than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than or equal to
         *  `other`, else `false`.
         * @see _.lte
         * @example
         *
         * _.gte(3, 1);
         * // => true
         *
         * _.gte(3, 3);
         * // => true
         *
         * _.gte(1, 3);
         * // => false
         */
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });

        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
            !propertyIsEnumerable.call(value, 'callee');
        };

        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;

        /**
         * Checks if `value` is classified as an `ArrayBuffer` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
         * @example
         *
         * _.isArrayBuffer(new ArrayBuffer(2));
         * // => true
         *
         * _.isArrayBuffer(new Array(2));
         * // => false
         */
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }

        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object,
         *  else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }

        /**
         * Checks if `value` is classified as a boolean primitive or object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
         * @example
         *
         * _.isBoolean(false);
         * // => true
         *
         * _.isBoolean(null);
         * // => false
         */
        function isBoolean(value) {
          return value === true || value === false ||
            (isObjectLike(value) && baseGetTag(value) == boolTag);
        }

        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */
        var isBuffer = nativeIsBuffer || stubFalse;

        /**
         * Checks if `value` is classified as a `Date` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
         * @example
         *
         * _.isDate(new Date);
         * // => true
         *
         * _.isDate('Mon April 23 2012');
         * // => false
         */
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

        /**
         * Checks if `value` is likely a DOM element.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
         * @example
         *
         * _.isElement(document.body);
         * // => true
         *
         * _.isElement('<body>');
         * // => false
         */
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }

        /**
         * Checks if `value` is an empty object, collection, map, or set.
         *
         * Objects are considered empty if they have no own enumerable string keyed
         * properties.
         *
         * Array-like values such as `arguments` objects, arrays, buffers, strings, or
         * jQuery-like collections are considered empty if they have a `length` of `0`.
         * Similarly, maps and sets are considered empty if they have a `size` of `0`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
         * @example
         *
         * _.isEmpty(null);
         * // => true
         *
         * _.isEmpty(true);
         * // => true
         *
         * _.isEmpty(1);
         * // => true
         *
         * _.isEmpty([1, 2, 3]);
         * // => false
         *
         * _.isEmpty({ 'a': 1 });
         * // => false
         */
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) &&
              (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
                isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }

        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent.
         *
         * **Note:** This method supports comparing arrays, array buffers, booleans,
         * date objects, error objects, maps, numbers, `Object` objects, regexes,
         * sets, strings, symbols, and typed arrays. `Object` objects are compared
         * by their own, not inherited, enumerable properties. Functions and DOM
         * nodes are compared by strict equality, i.e. `===`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.isEqual(object, other);
         * // => true
         *
         * object === other;
         * // => false
         */
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }

        /**
         * This method is like `_.isEqual` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
         * are handled by the method instead. The `customizer` is invoked with up to
         * six arguments: (objValue, othValue [, index|key, object, other, stack]).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, othValue) {
         *   if (isGreeting(objValue) && isGreeting(othValue)) {
         *     return true;
         *   }
         * }
         *
         * var array = ['hello', 'goodbye'];
         * var other = ['hi', 'goodbye'];
         *
         * _.isEqualWith(array, other, customizer);
         * // => true
         */
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          var result = customizer ? customizer(value, other) : undefined$1;
          return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
        }

        /**
         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
         * `SyntaxError`, `TypeError`, or `URIError` object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
         * @example
         *
         * _.isError(new Error);
         * // => true
         *
         * _.isError(Error);
         * // => false
         */
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag ||
            (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
        }

        /**
         * Checks if `value` is a finite primitive number.
         *
         * **Note:** This method is based on
         * [`Number.isFinite`](https://mdn.io/Number/isFinite).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
         * @example
         *
         * _.isFinite(3);
         * // => true
         *
         * _.isFinite(Number.MIN_VALUE);
         * // => true
         *
         * _.isFinite(Infinity);
         * // => false
         *
         * _.isFinite('3');
         * // => false
         */
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }

        /**
         * Checks if `value` is an integer.
         *
         * **Note:** This method is based on
         * [`Number.isInteger`](https://mdn.io/Number/isInteger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
         * @example
         *
         * _.isInteger(3);
         * // => true
         *
         * _.isInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isInteger(Infinity);
         * // => false
         *
         * _.isInteger('3');
         * // => false
         */
        function isInteger(value) {
          return typeof value == 'number' && value == toInteger(value);
        }

        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        function isLength(value) {
          return typeof value == 'number' &&
            value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }

        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == 'object' || type == 'function');
        }

        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
          return value != null && typeof value == 'object';
        }

        /**
         * Checks if `value` is classified as a `Map` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         * @example
         *
         * _.isMap(new Map);
         * // => true
         *
         * _.isMap(new WeakMap);
         * // => false
         */
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

        /**
         * Performs a partial deep comparison between `object` and `source` to
         * determine if `object` contains equivalent property values.
         *
         * **Note:** This method is equivalent to `_.matches` when `source` is
         * partially applied.
         *
         * Partial comparisons will match empty array and empty object `source`
         * values against any array or object value, respectively. See `_.isEqual`
         * for a list of supported value comparisons.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         *
         * _.isMatch(object, { 'b': 2 });
         * // => true
         *
         * _.isMatch(object, { 'b': 1 });
         * // => false
         */
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }

        /**
         * This method is like `_.isMatch` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
         * are handled by the method instead. The `customizer` is invoked with five
         * arguments: (objValue, srcValue, index|key, object, source).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, srcValue) {
         *   if (isGreeting(objValue) && isGreeting(srcValue)) {
         *     return true;
         *   }
         * }
         *
         * var object = { 'greeting': 'hello' };
         * var source = { 'greeting': 'hi' };
         *
         * _.isMatchWith(object, source, customizer);
         * // => true
         */
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }

        /**
         * Checks if `value` is `NaN`.
         *
         * **Note:** This method is based on
         * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
         * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
         * `undefined` and other non-number values.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         * @example
         *
         * _.isNaN(NaN);
         * // => true
         *
         * _.isNaN(new Number(NaN));
         * // => true
         *
         * isNaN(undefined);
         * // => true
         *
         * _.isNaN(undefined);
         * // => false
         */
        function isNaN(value) {
          // An `NaN` primitive is the only value that is not equal to itself.
          // Perform the `toStringTag` check first to avoid errors with some
          // ActiveX objects in IE.
          return isNumber(value) && value != +value;
        }

        /**
         * Checks if `value` is a pristine native function.
         *
         * **Note:** This method can't reliably detect native functions in the presence
         * of the core-js package because core-js circumvents this kind of detection.
         * Despite multiple requests, the core-js maintainer has made it clear: any
         * attempt to fix the detection will be obstructed. As a result, we're left
         * with little choice but to throw an error. Unfortunately, this also affects
         * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
         * which rely on core-js.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         * @example
         *
         * _.isNative(Array.prototype.push);
         * // => true
         *
         * _.isNative(_);
         * // => false
         */
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }

        /**
         * Checks if `value` is `null`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
         * @example
         *
         * _.isNull(null);
         * // => true
         *
         * _.isNull(void 0);
         * // => false
         */
        function isNull(value) {
          return value === null;
        }

        /**
         * Checks if `value` is `null` or `undefined`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
         * @example
         *
         * _.isNil(null);
         * // => true
         *
         * _.isNil(void 0);
         * // => true
         *
         * _.isNil(NaN);
         * // => false
         */
        function isNil(value) {
          return value == null;
        }

        /**
         * Checks if `value` is classified as a `Number` primitive or object.
         *
         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
         * classified as numbers, use the `_.isFinite` method.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a number, else `false`.
         * @example
         *
         * _.isNumber(3);
         * // => true
         *
         * _.isNumber(Number.MIN_VALUE);
         * // => true
         *
         * _.isNumber(Infinity);
         * // => true
         *
         * _.isNumber('3');
         * // => false
         */
        function isNumber(value) {
          return typeof value == 'number' ||
            (isObjectLike(value) && baseGetTag(value) == numberTag);
        }

        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
          return typeof Ctor == 'function' && Ctor instanceof Ctor &&
            funcToString.call(Ctor) == objectCtorString;
        }

        /**
         * Checks if `value` is classified as a `RegExp` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
         * @example
         *
         * _.isRegExp(/abc/);
         * // => true
         *
         * _.isRegExp('/abc/');
         * // => false
         */
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

        /**
         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
         * double precision number which isn't the result of a rounded unsafe integer.
         *
         * **Note:** This method is based on
         * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
         * @example
         *
         * _.isSafeInteger(3);
         * // => true
         *
         * _.isSafeInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isSafeInteger(Infinity);
         * // => false
         *
         * _.isSafeInteger('3');
         * // => false
         */
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }

        /**
         * Checks if `value` is classified as a `Set` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         * @example
         *
         * _.isSet(new Set);
         * // => true
         *
         * _.isSet(new WeakSet);
         * // => false
         */
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a string, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
          return typeof value == 'string' ||
            (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
        }

        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol(value) {
          return typeof value == 'symbol' ||
            (isObjectLike(value) && baseGetTag(value) == symbolTag);
        }

        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         *
         * _.isUndefined(null);
         * // => false
         */
        function isUndefined(value) {
          return value === undefined$1;
        }

        /**
         * Checks if `value` is classified as a `WeakMap` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
         * @example
         *
         * _.isWeakMap(new WeakMap);
         * // => true
         *
         * _.isWeakMap(new Map);
         * // => false
         */
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }

        /**
         * Checks if `value` is classified as a `WeakSet` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
         * @example
         *
         * _.isWeakSet(new WeakSet);
         * // => true
         *
         * _.isWeakSet(new Set);
         * // => false
         */
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }

        /**
         * Checks if `value` is less than `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`,
         *  else `false`.
         * @see _.gt
         * @example
         *
         * _.lt(1, 3);
         * // => true
         *
         * _.lt(3, 3);
         * // => false
         *
         * _.lt(3, 1);
         * // => false
         */
        var lt = createRelationalOperation(baseLt);

        /**
         * Checks if `value` is less than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than or equal to
         *  `other`, else `false`.
         * @see _.gte
         * @example
         *
         * _.lte(1, 3);
         * // => true
         *
         * _.lte(3, 3);
         * // => true
         *
         * _.lte(3, 1);
         * // => false
         */
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });

        /**
         * Converts `value` to an array.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Array} Returns the converted array.
         * @example
         *
         * _.toArray({ 'a': 1, 'b': 2 });
         * // => [1, 2]
         *
         * _.toArray('abc');
         * // => ['a', 'b', 'c']
         *
         * _.toArray(1);
         * // => []
         *
         * _.toArray(null);
         * // => []
         */
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value),
              func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

          return func(value);
        }

        /**
         * Converts `value` to a finite number.
         *
         * @static
         * @memberOf _
         * @since 4.12.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted number.
         * @example
         *
         * _.toFinite(3.2);
         * // => 3.2
         *
         * _.toFinite(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toFinite(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toFinite('3.2');
         * // => 3.2
         */
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = (value < 0 ? -1 : 1);
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }

        /**
         * Converts `value` to an integer.
         *
         * **Note:** This method is loosely based on
         * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toInteger(3.2);
         * // => 3
         *
         * _.toInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toInteger(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toInteger('3.2');
         * // => 3
         */
        function toInteger(value) {
          var result = toFinite(value),
              remainder = result % 1;

          return result === result ? (remainder ? result - remainder : result) : 0;
        }

        /**
         * Converts `value` to an integer suitable for use as the length of an
         * array-like object.
         *
         * **Note:** This method is based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toLength(3.2);
         * // => 3
         *
         * _.toLength(Number.MIN_VALUE);
         * // => 0
         *
         * _.toLength(Infinity);
         * // => 4294967295
         *
         * _.toLength('3.2');
         * // => 3
         */
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }

        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3.2);
         * // => 3.2
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3.2');
         * // => 3.2
         */
        function toNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
            value = isObject(other) ? (other + '') : other;
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return (isBinary || reIsOctal.test(value))
            ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
            : (reIsBadHex.test(value) ? NAN : +value);
        }

        /**
         * Converts `value` to a plain object flattening inherited enumerable string
         * keyed properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }

        /**
         * Converts `value` to a safe integer. A safe integer can be compared and
         * represented correctly.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toSafeInteger(3.2);
         * // => 3
         *
         * _.toSafeInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toSafeInteger(Infinity);
         * // => 9007199254740991
         *
         * _.toSafeInteger('3.2');
         * // => 3
         */
        function toSafeInteger(value) {
          return value
            ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
            : (value === 0 ? value : 0);
        }

        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString(value) {
          return value == null ? '' : baseToString(value);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Assigns own enumerable string keyed properties of source objects to the
         * destination object. Source objects are applied from left to right.
         * Subsequent sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object` and is loosely based on
         * [`Object.assign`](https://mdn.io/Object/assign).
         *
         * @static
         * @memberOf _
         * @since 0.10.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.assignIn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * function Bar() {
         *   this.c = 3;
         * }
         *
         * Foo.prototype.b = 2;
         * Bar.prototype.d = 4;
         *
         * _.assign({ 'a': 0 }, new Foo, new Bar);
         * // => { 'a': 1, 'c': 3 }
         */
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });

        /**
         * This method is like `_.assign` except that it iterates over own and
         * inherited source properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extend
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.assign
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * function Bar() {
         *   this.c = 3;
         * }
         *
         * Foo.prototype.b = 2;
         * Bar.prototype.d = 4;
         *
         * _.assignIn({ 'a': 0 }, new Foo, new Bar);
         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
         */
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });

        /**
         * This method is like `_.assignIn` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extendWith
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignInWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });

        /**
         * This method is like `_.assign` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignInWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });

        /**
         * Creates an array of values corresponding to `paths` of `object`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Array} Returns the picked values.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _.at(object, ['a[0].b.c', 'a[1]']);
         * // => [3, 4]
         */
        var at = flatRest(baseAt);

        /**
         * Creates an object that inherits from the `prototype` object. If a
         * `properties` object is given, its own enumerable string keyed properties
         * are assigned to the created object.
         *
         * @static
         * @memberOf _
         * @since 2.3.0
         * @category Object
         * @param {Object} prototype The object to inherit from.
         * @param {Object} [properties] The properties to assign to the object.
         * @returns {Object} Returns the new object.
         * @example
         *
         * function Shape() {
         *   this.x = 0;
         *   this.y = 0;
         * }
         *
         * function Circle() {
         *   Shape.call(this);
         * }
         *
         * Circle.prototype = _.create(Shape.prototype, {
         *   'constructor': Circle
         * });
         *
         * var circle = new Circle;
         * circle instanceof Circle;
         * // => true
         *
         * circle instanceof Shape;
         * // => true
         */
        function create(prototype, properties) {
          var result = baseCreate(prototype);
          return properties == null ? result : baseAssign(result, properties);
        }

        /**
         * Assigns own and inherited enumerable string keyed properties of source
         * objects to the destination object for all destination properties that
         * resolve to `undefined`. Source objects are applied from left to right.
         * Once a property is set, additional values of the same property are ignored.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaultsDeep
         * @example
         *
         * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var defaults = baseRest(function(object, sources) {
          object = Object(object);

          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$1;

          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }

          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;

            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];

              if (value === undefined$1 ||
                  (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                object[key] = source[key];
              }
            }
          }

          return object;
        });

        /**
         * This method is like `_.defaults` except that it recursively assigns
         * default properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaults
         * @example
         *
         * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
         * // => { 'a': { 'b': 2, 'c': 3 } }
         */
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });

        /**
         * This method is like `_.find` except that it returns the key of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element,
         *  else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findKey(users, function(o) { return o.age < 40; });
         * // => 'barney' (iteration order is not guaranteed)
         *
         * // The `_.matches` iteratee shorthand.
         * _.findKey(users, { 'age': 1, 'active': true });
         * // => 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findKey(users, 'active');
         * // => 'barney'
         */
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }

        /**
         * This method is like `_.findKey` except that it iterates over elements of
         * a collection in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element,
         *  else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findLastKey(users, function(o) { return o.age < 40; });
         * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastKey(users, { 'age': 36, 'active': true });
         * // => 'barney'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastKey(users, 'active');
         * // => 'pebbles'
         */
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }

        /**
         * Iterates over own and inherited enumerable string keyed properties of an
         * object and invokes `iteratee` for each property. The iteratee is invoked
         * with three arguments: (value, key, object). Iteratee functions may exit
         * iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forInRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forIn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
         */
        function forIn(object, iteratee) {
          return object == null
            ? object
            : baseFor(object, getIteratee(iteratee, 3), keysIn);
        }

        /**
         * This method is like `_.forIn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forIn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forInRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
         */
        function forInRight(object, iteratee) {
          return object == null
            ? object
            : baseForRight(object, getIteratee(iteratee, 3), keysIn);
        }

        /**
         * Iterates over own enumerable string keyed properties of an object and
         * invokes `iteratee` for each property. The iteratee is invoked with three
         * arguments: (value, key, object). Iteratee functions may exit iteration
         * early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwnRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forOwn(object, iteratee) {
          return object && baseForOwn(object, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.forOwn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwnRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
         */
        function forOwnRight(object, iteratee) {
          return object && baseForOwnRight(object, getIteratee(iteratee, 3));
        }

        /**
         * Creates an array of function property names from own enumerable properties
         * of `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the function names.
         * @see _.functionsIn
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functions(new Foo);
         * // => ['a', 'b']
         */
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }

        /**
         * Creates an array of function property names from own and inherited
         * enumerable properties of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the function names.
         * @see _.functions
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functionsIn(new Foo);
         * // => ['a', 'b', 'c']
         */
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }

        /**
         * Gets the value at `path` of `object`. If the resolved value is
         * `undefined`, the `defaultValue` is returned in its place.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get(object, path, defaultValue) {
          var result = object == null ? undefined$1 : baseGet(object, path);
          return result === undefined$1 ? defaultValue : result;
        }

        /**
         * Checks if `path` is a direct property of `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = { 'a': { 'b': 2 } };
         * var other = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.has(object, 'a');
         * // => true
         *
         * _.has(object, 'a.b');
         * // => true
         *
         * _.has(object, ['a', 'b']);
         * // => true
         *
         * _.has(other, 'a');
         * // => false
         */
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }

        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }

        /**
         * Creates an object composed of the inverted keys and values of `object`.
         * If `object` contains duplicate values, subsequent values overwrite
         * property assignments of previous values.
         *
         * @static
         * @memberOf _
         * @since 0.7.0
         * @category Object
         * @param {Object} object The object to invert.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invert(object);
         * // => { '1': 'c', '2': 'b' }
         */
        var invert = createInverter(function(result, value, key) {
          if (value != null &&
              typeof value.toString != 'function') {
            value = nativeObjectToString.call(value);
          }

          result[value] = key;
        }, constant(identity));

        /**
         * This method is like `_.invert` except that the inverted object is generated
         * from the results of running each element of `object` thru `iteratee`. The
         * corresponding inverted value of each inverted key is an array of keys
         * responsible for generating the inverted value. The iteratee is invoked
         * with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.1.0
         * @category Object
         * @param {Object} object The object to invert.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invertBy(object);
         * // => { '1': ['a', 'c'], '2': ['b'] }
         *
         * _.invertBy(object, function(value) {
         *   return 'group' + value;
         * });
         * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
         */
        var invertBy = createInverter(function(result, value, key) {
          if (value != null &&
              typeof value.toString != 'function') {
            value = nativeObjectToString.call(value);
          }

          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }, getIteratee);

        /**
         * Invokes the method at `path` of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
         *
         * _.invoke(object, 'a[0].b.c.slice', 1, 3);
         * // => [2, 3]
         */
        var invoke = baseRest(baseInvoke);

        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }

        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }

        /**
         * The opposite of `_.mapValues`; this method creates an object with the
         * same values as `object` and keys generated by running each own enumerable
         * string keyed property of `object` thru `iteratee`. The iteratee is invoked
         * with three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapValues
         * @example
         *
         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
         *   return key + value;
         * });
         * // => { 'a1': 1, 'b2': 2 }
         */
        function mapKeys(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);

          baseForOwn(object, function(value, key, object) {
            baseAssignValue(result, iteratee(value, key, object), value);
          });
          return result;
        }

        /**
         * Creates an object with the same keys as `object` and values generated
         * by running each own enumerable string keyed property of `object` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapKeys
         * @example
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * _.mapValues(users, function(o) { return o.age; });
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         *
         * // The `_.property` iteratee shorthand.
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */
        function mapValues(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);

          baseForOwn(object, function(value, key, object) {
            baseAssignValue(result, key, iteratee(value, key, object));
          });
          return result;
        }

        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable string keyed properties of source objects into the
         * destination object. Source properties that resolve to `undefined` are
         * skipped if a destination value exists. Array and plain object properties
         * are merged recursively. Other objects and value types are overridden by
         * assignment. Source objects are applied from left to right. Subsequent
         * sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {
         *   'a': [{ 'b': 2 }, { 'd': 4 }]
         * };
         *
         * var other = {
         *   'a': [{ 'c': 3 }, { 'e': 5 }]
         * };
         *
         * _.merge(object, other);
         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
         */
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });

        /**
         * This method is like `_.merge` except that it accepts `customizer` which
         * is invoked to produce the merged values of the destination and source
         * properties. If `customizer` returns `undefined`, merging is handled by the
         * method instead. The `customizer` is invoked with six arguments:
         * (objValue, srcValue, key, object, source, stack).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   if (_.isArray(objValue)) {
         *     return objValue.concat(srcValue);
         *   }
         * }
         *
         * var object = { 'a': [1], 'b': [2] };
         * var other = { 'a': [3], 'b': [4] };
         *
         * _.mergeWith(object, other, customizer);
         * // => { 'a': [1, 3], 'b': [2, 4] }
         */
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });

        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable property paths of `object` that are not omitted.
         *
         * **Note:** This method is considerably slower than `_.pick`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to omit.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omit(object, ['a', 'c']);
         * // => { 'b': '2' }
         */
        var omit = flatRest(function(object, paths) {
          var result = {};
          if (object == null) {
            return result;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result);
          if (isDeep) {
            result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result, paths[length]);
          }
          return result;
        });

        /**
         * The opposite of `_.pickBy`; this method creates an object composed of
         * the own and inherited enumerable string keyed properties of `object` that
         * `predicate` doesn't return truthy for. The predicate is invoked with two
         * arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omitBy(object, _.isNumber);
         * // => { 'b': '2' }
         */
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }

        /**
         * Creates an object composed of the picked `object` properties.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pick(object, ['a', 'c']);
         * // => { 'a': 1, 'c': 3 }
         */
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });

        /**
         * Creates an object composed of the `object` properties `predicate` returns
         * truthy for. The predicate is invoked with two arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pickBy(object, _.isNumber);
         * // => { 'a': 1, 'c': 3 }
         */
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }

        /**
         * This method is like `_.get` except that if the resolved value is a
         * function it's invoked with the `this` binding of its parent object and
         * its result is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to resolve.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
         *
         * _.result(object, 'a[0].b.c1');
         * // => 3
         *
         * _.result(object, 'a[0].b.c2');
         * // => 4
         *
         * _.result(object, 'a[0].b.c3', 'default');
         * // => 'default'
         *
         * _.result(object, 'a[0].b.c3', _.constant('default'));
         * // => 'default'
         */
        function result(object, path, defaultValue) {
          path = castPath(path, object);

          var index = -1,
              length = path.length;

          // Ensure the loop is entered when path is empty.
          if (!length) {
            length = 1;
            object = undefined$1;
          }
          while (++index < length) {
            var value = object == null ? undefined$1 : object[toKey(path[index])];
            if (value === undefined$1) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }

        /**
         * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
         * it's created. Arrays are created for missing index properties while objects
         * are created for all other missing properties. Use `_.setWith` to customize
         * `path` creation.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.set(object, 'a[0].b.c', 4);
         * console.log(object.a[0].b.c);
         * // => 4
         *
         * _.set(object, ['x', '0', 'y', 'z'], 5);
         * console.log(object.x[0].y.z);
         * // => 5
         */
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }

        /**
         * This method is like `_.set` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.setWith(object, '[0][1]', 'a', Object);
         * // => { '0': { '1': 'a' } }
         */
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return object == null ? object : baseSet(object, path, value, customizer);
        }

        /**
         * Creates an array of own enumerable string keyed-value pairs for `object`
         * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
         * entries are returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias entries
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairs(new Foo);
         * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
         */
        var toPairs = createToPairs(keys);

        /**
         * Creates an array of own and inherited enumerable string keyed-value pairs
         * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
         * or set, its entries are returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias entriesIn
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairsIn(new Foo);
         * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
         */
        var toPairsIn = createToPairs(keysIn);

        /**
         * An alternative to `_.reduce`; this method transforms `object` to a new
         * `accumulator` object which is the result of running each of its own
         * enumerable string keyed properties thru `iteratee`, with each invocation
         * potentially mutating the `accumulator` object. If `accumulator` is not
         * provided, a new object with the same `[[Prototype]]` will be used. The
         * iteratee is invoked with four arguments: (accumulator, value, key, object).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The custom accumulator value.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.transform([2, 3, 4], function(result, n) {
         *   result.push(n *= n);
         *   return n % 2 == 0;
         * }, []);
         * // => [4, 9]
         *
         * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] }
         */
        function transform(object, iteratee, accumulator) {
          var isArr = isArray(object),
              isArrLike = isArr || isBuffer(object) || isTypedArray(object);

          iteratee = getIteratee(iteratee, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor : [];
            }
            else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            }
            else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }

        /**
         * Removes the property at `path` of `object`.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 7 } }] };
         * _.unset(object, 'a[0].b.c');
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         *
         * _.unset(object, ['a', '0', 'b', 'c']);
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         */
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }

        /**
         * This method is like `_.set` except that accepts `updater` to produce the
         * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
         * is invoked with one argument: (value).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.update(object, 'a[0].b.c', function(n) { return n * n; });
         * console.log(object.a[0].b.c);
         * // => 9
         *
         * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
         * console.log(object.x[0].y.z);
         * // => 0
         */
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }

        /**
         * This method is like `_.update` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.updateWith(object, '[0][1]', _.constant('a'), Object);
         * // => { '0': { '1': 'a' } }
         */
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }

        /**
         * Creates an array of the own enumerable string keyed property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.values(new Foo);
         * // => [1, 2] (iteration order is not guaranteed)
         *
         * _.values('hi');
         * // => ['h', 'i']
         */
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }

        /**
         * Creates an array of the own and inherited enumerable string keyed property
         * values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.valuesIn(new Foo);
         * // => [1, 2, 3] (iteration order is not guaranteed)
         */
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }

        /*------------------------------------------------------------------------*/

        /**
         * Clamps `number` within the inclusive `lower` and `upper` bounds.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Number
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         * @example
         *
         * _.clamp(-10, -5, 5);
         * // => -5
         *
         * _.clamp(10, -5, 5);
         * // => 5
         */
        function clamp(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }

        /**
         * Checks if `n` is between `start` and up to, but not including, `end`. If
         * `end` is not specified, it's set to `start` with `start` then set to `0`.
         * If `start` is greater than `end` the params are swapped to support
         * negative ranges.
         *
         * @static
         * @memberOf _
         * @since 3.3.0
         * @category Number
         * @param {number} number The number to check.
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         * @see _.range, _.rangeRight
         * @example
         *
         * _.inRange(3, 2, 4);
         * // => true
         *
         * _.inRange(4, 8);
         * // => true
         *
         * _.inRange(4, 2);
         * // => false
         *
         * _.inRange(2, 2);
         * // => false
         *
         * _.inRange(1.2, 2);
         * // => true
         *
         * _.inRange(5.2, 4);
         * // => false
         *
         * _.inRange(-3, -2, -6);
         * // => true
         */
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }

        /**
         * Produces a random number between the inclusive `lower` and `upper` bounds.
         * If only one argument is provided a number between `0` and the given number
         * is returned. If `floating` is `true`, or either `lower` or `upper` are
         * floats, a floating-point number is returned instead of an integer.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @memberOf _
         * @since 0.7.0
         * @category Number
         * @param {number} [lower=0] The lower bound.
         * @param {number} [upper=1] The upper bound.
         * @param {boolean} [floating] Specify returning a floating-point number.
         * @returns {number} Returns the random number.
         * @example
         *
         * _.random(0, 5);
         * // => an integer between 0 and 5
         *
         * _.random(5);
         * // => also an integer between 0 and 5
         *
         * _.random(5, true);
         * // => a floating-point number between 0 and 5
         *
         * _.random(1.2, 5.2);
         * // => a floating-point number between 1.2 and 5.2
         */
        function random(lower, upper, floating) {
          if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == 'boolean') {
              floating = upper;
              upper = undefined$1;
            }
            else if (typeof lower == 'boolean') {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          }
          else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
          }
          return baseRandom(lower, upper);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the camel cased string.
         * @example
         *
         * _.camelCase('Foo Bar');
         * // => 'fooBar'
         *
         * _.camelCase('--foo-bar--');
         * // => 'fooBar'
         *
         * _.camelCase('__FOO_BAR__');
         * // => 'fooBar'
         */
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? capitalize(word) : word);
        });

        /**
         * Converts the first character of `string` to upper case and the remaining
         * to lower case.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to capitalize.
         * @returns {string} Returns the capitalized string.
         * @example
         *
         * _.capitalize('FRED');
         * // => 'Fred'
         */
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }

        /**
         * Deburrs `string` by converting
         * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
         * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
         * letters to basic Latin letters and removing
         * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to deburr.
         * @returns {string} Returns the deburred string.
         * @example
         *
         * _.deburr('dj vu');
         * // => 'deja vu'
         */
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
        }

        /**
         * Checks if `string` ends with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=string.length] The position to search up to.
         * @returns {boolean} Returns `true` if `string` ends with `target`,
         *  else `false`.
         * @example
         *
         * _.endsWith('abc', 'c');
         * // => true
         *
         * _.endsWith('abc', 'b');
         * // => false
         *
         * _.endsWith('abc', 'b', 2);
         * // => true
         */
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);

          var length = string.length;
          position = position === undefined$1
            ? length
            : baseClamp(toInteger(position), 0, length);

          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }

        /**
         * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
         * corresponding HTML entities.
         *
         * **Note:** No other characters are escaped. To escape additional
         * characters use a third-party library like [_he_](https://mths.be/he).
         *
         * Though the ">" character is escaped for symmetry, characters like
         * ">" and "/" don't need escaping in HTML and have no special meaning
         * unless they're part of a tag or unquoted attribute value. See
         * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
         * (under "semi-related fun fact") for more details.
         *
         * When working with HTML you should always
         * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
         * XSS vectors.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escape('fred, barney, & pebbles');
         * // => 'fred, barney, &amp; pebbles'
         */
        function escape(string) {
          string = toString(string);
          return (string && reHasUnescapedHtml.test(string))
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string;
        }

        /**
         * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
         * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escapeRegExp('[lodash](https://lodash.com/)');
         * // => '\[lodash\]\(https://lodash\.com/\)'
         */
        function escapeRegExp(string) {
          string = toString(string);
          return (string && reHasRegExpChar.test(string))
            ? string.replace(reRegExpChar, '\\$&')
            : string;
        }

        /**
         * Converts `string` to
         * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the kebab cased string.
         * @example
         *
         * _.kebabCase('Foo Bar');
         * // => 'foo-bar'
         *
         * _.kebabCase('fooBar');
         * // => 'foo-bar'
         *
         * _.kebabCase('__FOO_BAR__');
         * // => 'foo-bar'
         */
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });

        /**
         * Converts `string`, as space separated words, to lower case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.lowerCase('--Foo-Bar--');
         * // => 'foo bar'
         *
         * _.lowerCase('fooBar');
         * // => 'foo bar'
         *
         * _.lowerCase('__FOO_BAR__');
         * // => 'foo bar'
         */
        var lowerCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toLowerCase();
        });

        /**
         * Converts the first character of `string` to lower case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.lowerFirst('Fred');
         * // => 'fred'
         *
         * _.lowerFirst('FRED');
         * // => 'fRED'
         */
        var lowerFirst = createCaseFirst('toLowerCase');

        /**
         * Pads `string` on the left and right sides if it's shorter than `length`.
         * Padding characters are truncated if they can't be evenly divided by `length`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.pad('abc', 8);
         * // => '  abc   '
         *
         * _.pad('abc', 8, '_-');
         * // => '_-abc_-_'
         *
         * _.pad('abc', 3);
         * // => 'abc'
         */
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return (
            createPadding(nativeFloor(mid), chars) +
            string +
            createPadding(nativeCeil(mid), chars)
          );
        }

        /**
         * Pads `string` on the right side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padEnd('abc', 6);
         * // => 'abc   '
         *
         * _.padEnd('abc', 6, '_-');
         * // => 'abc_-_'
         *
         * _.padEnd('abc', 3);
         * // => 'abc'
         */
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          return (length && strLength < length)
            ? (string + createPadding(length - strLength, chars))
            : string;
        }

        /**
         * Pads `string` on the left side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padStart('abc', 6);
         * // => '   abc'
         *
         * _.padStart('abc', 6, '_-');
         * // => '_-_abc'
         *
         * _.padStart('abc', 3);
         * // => 'abc'
         */
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          return (length && strLength < length)
            ? (createPadding(length - strLength, chars) + string)
            : string;
        }

        /**
         * Converts `string` to an integer of the specified radix. If `radix` is
         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
         * hexadecimal, in which case a `radix` of `16` is used.
         *
         * **Note:** This method aligns with the
         * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category String
         * @param {string} string The string to convert.
         * @param {number} [radix=10] The radix to interpret `value` by.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.parseInt('08');
         * // => 8
         *
         * _.map(['6', '08', '10'], _.parseInt);
         * // => [6, 8, 10]
         */
        function parseInt(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
        }

        /**
         * Repeats the given string `n` times.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to repeat.
         * @param {number} [n=1] The number of times to repeat the string.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the repeated string.
         * @example
         *
         * _.repeat('*', 3);
         * // => '***'
         *
         * _.repeat('abc', 2);
         * // => 'abcabc'
         *
         * _.repeat('abc', 0);
         * // => ''
         */
        function repeat(string, n, guard) {
          if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }

        /**
         * Replaces matches for `pattern` in `string` with `replacement`.
         *
         * **Note:** This method is based on
         * [`String#replace`](https://mdn.io/String/replace).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to modify.
         * @param {RegExp|string} pattern The pattern to replace.
         * @param {Function|string} replacement The match replacement.
         * @returns {string} Returns the modified string.
         * @example
         *
         * _.replace('Hi Fred', 'Fred', 'Barney');
         * // => 'Hi Barney'
         */
        function replace() {
          var args = arguments,
              string = toString(args[0]);

          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }

        /**
         * Converts `string` to
         * [snake case](https://en.wikipedia.org/wiki/Snake_case).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the snake cased string.
         * @example
         *
         * _.snakeCase('Foo Bar');
         * // => 'foo_bar'
         *
         * _.snakeCase('fooBar');
         * // => 'foo_bar'
         *
         * _.snakeCase('--FOO-BAR--');
         * // => 'foo_bar'
         */
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });

        /**
         * Splits `string` by `separator`.
         *
         * **Note:** This method is based on
         * [`String#split`](https://mdn.io/String/split).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to split.
         * @param {RegExp|string} separator The separator pattern to split by.
         * @param {number} [limit] The length to truncate results to.
         * @returns {Array} Returns the string segments.
         * @example
         *
         * _.split('a-b-c', '-', 2);
         * // => ['a', 'b']
         */
        function split(string, separator, limit) {
          if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (
                typeof separator == 'string' ||
                (separator != null && !isRegExp(separator))
              )) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }

        /**
         * Converts `string` to
         * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
         *
         * @static
         * @memberOf _
         * @since 3.1.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the start cased string.
         * @example
         *
         * _.startCase('--foo-bar--');
         * // => 'Foo Bar'
         *
         * _.startCase('fooBar');
         * // => 'Foo Bar'
         *
         * _.startCase('__FOO_BAR__');
         * // => 'FOO BAR'
         */
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + upperFirst(word);
        });

        /**
         * Checks if `string` starts with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=0] The position to search from.
         * @returns {boolean} Returns `true` if `string` starts with `target`,
         *  else `false`.
         * @example
         *
         * _.startsWith('abc', 'a');
         * // => true
         *
         * _.startsWith('abc', 'b');
         * // => false
         *
         * _.startsWith('abc', 'b', 1);
         * // => true
         */
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null
            ? 0
            : baseClamp(toInteger(position), 0, string.length);

          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }

        /**
         * Creates a compiled template function that can interpolate data properties
         * in "interpolate" delimiters, HTML-escape interpolated data properties in
         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
         * properties may be accessed as free variables in the template. If a setting
         * object is given, it takes precedence over `_.templateSettings` values.
         *
         * **Note:** In the development build `_.template` utilizes
         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
         * for easier debugging.
         *
         * For more information on precompiling templates see
         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
         *
         * For more information on Chrome extension sandboxes see
         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The template string.
         * @param {Object} [options={}] The options object.
         * @param {RegExp} [options.escape=_.templateSettings.escape]
         *  The HTML "escape" delimiter.
         * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
         *  The "evaluate" delimiter.
         * @param {Object} [options.imports=_.templateSettings.imports]
         *  An object to import into the template as free variables.
         * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
         *  The "interpolate" delimiter.
         * @param {string} [options.sourceURL='lodash.templateSources[n]']
         *  The sourceURL of the compiled template.
         * @param {string} [options.variable='obj']
         *  The data object variable name.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the compiled template function.
         * @example
         *
         * // Use the "interpolate" delimiter to create a compiled template.
         * var compiled = _.template('hello <%= user %>!');
         * compiled({ 'user': 'fred' });
         * // => 'hello fred!'
         *
         * // Use the HTML "escape" delimiter to escape data property values.
         * var compiled = _.template('<b><%- value %></b>');
         * compiled({ 'value': '<script>' });
         * // => '<b>&lt;script&gt;</b>'
         *
         * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the internal `print` function in "evaluate" delimiters.
         * var compiled = _.template('<% print("hello " + user); %>!');
         * compiled({ 'user': 'barney' });
         * // => 'hello barney!'
         *
         * // Use the ES template literal delimiter as an "interpolate" delimiter.
         * // Disable support by replacing the "interpolate" delimiter.
         * var compiled = _.template('hello ${ user }!');
         * compiled({ 'user': 'pebbles' });
         * // => 'hello pebbles!'
         *
         * // Use backslashes to treat delimiters as plain text.
         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
         * compiled({ 'value': 'ignored' });
         * // => '<%- value %>'
         *
         * // Use the `imports` option to import `jQuery` as `jq`.
         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the `sourceURL` option to specify a custom sourceURL for the template.
         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
         * compiled(data);
         * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
         *
         * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
         * compiled.source;
         * // => function(data) {
         * //   var __t, __p = '';
         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
         * //   return __p;
         * // }
         *
         * // Use custom template delimiters.
         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
         * var compiled = _.template('hello {{ user }}!');
         * compiled({ 'user': 'mustache' });
         * // => 'hello mustache!'
         *
         * // Use the `source` property to inline compiled templates for meaningful
         * // line numbers in error messages and stack traces.
         * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
         *   var JST = {\
         *     "main": ' + _.template(mainText).source + '\
         *   };\
         * ');
         */
        function template(string, options, guard) {
          // Based on John Resig's `tmpl` implementation
          // (http://ejohn.org/blog/javascript-micro-templating/)
          // and Laura Doktorova's doT.js (https://github.com/olado/doT).
          var settings = lodash.templateSettings;

          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);

          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);

          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";

          // Compile the regexp to match each delimiter.
          var reDelimiters = RegExp(
            (options.escape || reNoMatch).source + '|' +
            interpolate.source + '|' +
            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
            (options.evaluate || reNoMatch).source + '|$'
          , 'g');

          // Use a sourceURL for easier debugging.
          // The sourceURL gets injected into the source that's eval-ed, so be careful
          // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
          // and escape the comment, thus injecting code that gets evaled.
          var sourceURL = '//# sourceURL=' +
            (hasOwnProperty.call(options, 'sourceURL')
              ? (options.sourceURL + '').replace(/\s/g, ' ')
              : ('lodash.templateSources[' + (++templateCounter) + ']')
            ) + '\n';

          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);

            // Escape characters that can't be included in string literals.
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

            // Replace delimiters with snippets.
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;

            // The JS engine embedded in Adobe products needs `match` returned in
            // order to produce the correct `offset` value.
            return match;
          });

          source += "';\n";

          // If `variable` is not specified wrap a with-statement around the generated
          // code to add the data object to the top of the scope chain.
          var variable = hasOwnProperty.call(options, 'variable') && options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          // Throw an error if a forbidden character was found in `variable`, to prevent
          // potential command injection attacks.
          else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
          }

          // Cleanup code by stripping empty strings.
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
            .replace(reEmptyStringMiddle, '$1')
            .replace(reEmptyStringTrailing, '$1;');

          // Frame code as the function body.
          source = 'function(' + (variable || 'obj') + ') {\n' +
            (variable
              ? ''
              : 'obj || (obj = {});\n'
            ) +
            "var __t, __p = ''" +
            (isEscaping
               ? ', __e = _.escape'
               : ''
            ) +
            (isEvaluating
              ? ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n"
              : ';\n'
            ) +
            source +
            'return __p\n}';

          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source)
              .apply(undefined$1, importsValues);
          });

          // Provide the compiled function's source by its `toString` method or
          // the `source` property as a convenience for inlining compiled templates.
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }

        /**
         * Converts `string`, as a whole, to lower case just like
         * [String#toLowerCase](https://mdn.io/toLowerCase).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.toLower('--Foo-Bar--');
         * // => '--foo-bar--'
         *
         * _.toLower('fooBar');
         * // => 'foobar'
         *
         * _.toLower('__FOO_BAR__');
         * // => '__foo_bar__'
         */
        function toLower(value) {
          return toString(value).toLowerCase();
        }

        /**
         * Converts `string`, as a whole, to upper case just like
         * [String#toUpperCase](https://mdn.io/toUpperCase).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.toUpper('--foo-bar--');
         * // => '--FOO-BAR--'
         *
         * _.toUpper('fooBar');
         * // => 'FOOBAR'
         *
         * _.toUpper('__foo_bar__');
         * // => '__FOO_BAR__'
         */
        function toUpper(value) {
          return toString(value).toUpperCase();
        }

        /**
         * Removes leading and trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trim('  abc  ');
         * // => 'abc'
         *
         * _.trim('-_-abc-_-', '_-');
         * // => 'abc'
         *
         * _.map(['  foo  ', '  bar  '], _.trim);
         * // => ['foo', 'bar']
         */
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              chrSymbols = stringToArray(chars),
              start = charsStartIndex(strSymbols, chrSymbols),
              end = charsEndIndex(strSymbols, chrSymbols) + 1;

          return castSlice(strSymbols, start, end).join('');
        }

        /**
         * Removes trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimEnd('  abc  ');
         * // => '  abc'
         *
         * _.trimEnd('-_-abc-_-', '_-');
         * // => '-_-abc'
         */
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

          return castSlice(strSymbols, 0, end).join('');
        }

        /**
         * Removes leading whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimStart('  abc  ');
         * // => 'abc  '
         *
         * _.trimStart('-_-abc-_-', '_-');
         * // => 'abc-_-'
         */
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              start = charsStartIndex(strSymbols, stringToArray(chars));

          return castSlice(strSymbols, start).join('');
        }

        /**
         * Truncates `string` if it's longer than the given maximum string length.
         * The last characters of the truncated string are replaced with the omission
         * string which defaults to "...".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to truncate.
         * @param {Object} [options={}] The options object.
         * @param {number} [options.length=30] The maximum string length.
         * @param {string} [options.omission='...'] The string to indicate text is omitted.
         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
         * @returns {string} Returns the truncated string.
         * @example
         *
         * _.truncate('hi-diddly-ho there, neighborino');
         * // => 'hi-diddly-ho there, neighbo...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': ' '
         * });
         * // => 'hi-diddly-ho there,...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': /,? +/
         * });
         * // => 'hi-diddly-ho there...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'omission': ' [...]'
         * });
         * // => 'hi-diddly-ho there, neig [...]'
         */
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;

          if (isObject(options)) {
            var separator = 'separator' in options ? options.separator : separator;
            length = 'length' in options ? toInteger(options.length) : length;
            omission = 'omission' in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);

          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result = strSymbols
            ? castSlice(strSymbols, 0, end).join('')
            : string.slice(0, end);

          if (separator === undefined$1) {
            return result + omission;
          }
          if (strSymbols) {
            end += (result.length - end);
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  substring = result;

              if (!separator.global) {
                separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                var newEnd = match.index;
              }
              result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }

        /**
         * The inverse of `_.escape`; this method converts the HTML entities
         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
         * their corresponding characters.
         *
         * **Note:** No other HTML entities are unescaped. To unescape additional
         * HTML entities use a third-party library like [_he_](https://mths.be/he).
         *
         * @static
         * @memberOf _
         * @since 0.6.0
         * @category String
         * @param {string} [string=''] The string to unescape.
         * @returns {string} Returns the unescaped string.
         * @example
         *
         * _.unescape('fred, barney, &amp; pebbles');
         * // => 'fred, barney, & pebbles'
         */
        function unescape(string) {
          string = toString(string);
          return (string && reHasEscapedHtml.test(string))
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string;
        }

        /**
         * Converts `string`, as space separated words, to upper case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.upperCase('--foo-bar');
         * // => 'FOO BAR'
         *
         * _.upperCase('fooBar');
         * // => 'FOO BAR'
         *
         * _.upperCase('__foo_bar__');
         * // => 'FOO BAR'
         */
        var upperCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toUpperCase();
        });

        /**
         * Converts the first character of `string` to upper case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.upperFirst('fred');
         * // => 'Fred'
         *
         * _.upperFirst('FRED');
         * // => 'FRED'
         */
        var upperFirst = createCaseFirst('toUpperCase');

        /**
         * Splits `string` into an array of its words.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {RegExp|string} [pattern] The pattern to match words.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the words of `string`.
         * @example
         *
         * _.words('fred, barney, & pebbles');
         * // => ['fred', 'barney', 'pebbles']
         *
         * _.words('fred, barney, & pebbles', /[^, ]+/g);
         * // => ['fred', 'barney', '&', 'pebbles']
         */
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined$1 : pattern;

          if (pattern === undefined$1) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }

        /*------------------------------------------------------------------------*/

        /**
         * Attempts to invoke `func`, returning either the result or the caught error
         * object. Any additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Function} func The function to attempt.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {*} Returns the `func` result or error object.
         * @example
         *
         * // Avoid throwing errors for invalid selectors.
         * var elements = _.attempt(function(selector) {
         *   return document.querySelectorAll(selector);
         * }, '>_>');
         *
         * if (_.isError(elements)) {
         *   elements = [];
         * }
         */
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });

        /**
         * Binds methods of an object to the object itself, overwriting the existing
         * method.
         *
         * **Note:** This method doesn't set the "length" property of bound functions.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {Object} object The object to bind and assign the bound methods to.
         * @param {...(string|string[])} methodNames The object method names to bind.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var view = {
         *   'label': 'docs',
         *   'click': function() {
         *     console.log('clicked ' + this.label);
         *   }
         * };
         *
         * _.bindAll(view, ['click']);
         * jQuery(element).on('click', view.click);
         * // => Logs 'clicked docs' when clicked.
         */
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });

        /**
         * Creates a function that iterates over `pairs` and invokes the corresponding
         * function of the first predicate to return truthy. The predicate-function
         * pairs are invoked with the `this` binding and arguments of the created
         * function.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {Array} pairs The predicate-function pairs.
         * @returns {Function} Returns the new composite function.
         * @example
         *
         * var func = _.cond([
         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
         *   [_.stubTrue,                      _.constant('no match')]
         * ]);
         *
         * func({ 'a': 1, 'b': 2 });
         * // => 'matches A'
         *
         * func({ 'a': 0, 'b': 1 });
         * // => 'matches B'
         *
         * func({ 'a': '1', 'b': '2' });
         * // => 'no match'
         */
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length,
              toIteratee = getIteratee();

          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });

          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }

        /**
         * Creates a function that invokes the predicate properties of `source` with
         * the corresponding property values of a given object, returning `true` if
         * all predicates return truthy, else `false`.
         *
         * **Note:** The created function is equivalent to `_.conformsTo` with
         * `source` partially applied.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 2, 'b': 1 },
         *   { 'a': 1, 'b': 2 }
         * ];
         *
         * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
         * // => [{ 'a': 1, 'b': 2 }]
         */
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */
        function constant(value) {
          return function() {
            return value;
          };
        }

        /**
         * Checks `value` to determine whether a default value should be returned in
         * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
         * or `undefined`.
         *
         * @static
         * @memberOf _
         * @since 4.14.0
         * @category Util
         * @param {*} value The value to check.
         * @param {*} defaultValue The default value.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * _.defaultTo(1, 10);
         * // => 1
         *
         * _.defaultTo(undefined, 10);
         * // => 10
         */
        function defaultTo(value, defaultValue) {
          return (value == null || value !== value) ? defaultValue : value;
        }

        /**
         * Creates a function that returns the result of invoking the given functions
         * with the `this` binding of the created function, where each successive
         * invocation is supplied the return value of the previous.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {...(Function|Function[])} [funcs] The functions to invoke.
         * @returns {Function} Returns the new composite function.
         * @see _.flowRight
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flow([_.add, square]);
         * addSquare(1, 2);
         * // => 9
         */
        var flow = createFlow();

        /**
         * This method is like `_.flow` except that it creates a function that
         * invokes the given functions from right to left.
         *
         * @static
         * @since 3.0.0
         * @memberOf _
         * @category Util
         * @param {...(Function|Function[])} [funcs] The functions to invoke.
         * @returns {Function} Returns the new composite function.
         * @see _.flow
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flowRight([square, _.add]);
         * addSquare(1, 2);
         * // => 9
         */
        var flowRight = createFlow(true);

        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */
        function identity(value) {
          return value;
        }

        /**
         * Creates a function that invokes `func` with the arguments of the created
         * function. If `func` is a property name, the created function returns the
         * property value for a given element. If `func` is an array or object, the
         * created function returns `true` for elements that contain the equivalent
         * source properties, otherwise it returns `false`.
         *
         * @static
         * @since 4.0.0
         * @memberOf _
         * @category Util
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @returns {Function} Returns the callback.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
         * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, _.iteratee(['user', 'fred']));
         * // => [{ 'user': 'fred', 'age': 40 }]
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, _.iteratee('user'));
         * // => ['barney', 'fred']
         *
         * // Create custom iteratee shorthands.
         * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
         *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
         *     return func.test(string);
         *   };
         * });
         *
         * _.filter(['abc', 'def'], /ef/);
         * // => ['def']
         */
        function iteratee(func) {
          return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that performs a partial deep comparison between a given
         * object and `source`, returning `true` if the given object has equivalent
         * property values, else `false`.
         *
         * **Note:** The created function is equivalent to `_.isMatch` with `source`
         * partially applied.
         *
         * Partial comparisons will match empty array and empty object `source`
         * values against any array or object value, respectively. See `_.isEqual`
         * for a list of supported value comparisons.
         *
         * **Note:** Multiple values can be checked by combining several matchers
         * using `_.overSome`
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 1, 'b': 2, 'c': 3 },
         *   { 'a': 4, 'b': 5, 'c': 6 }
         * ];
         *
         * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
         * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
         *
         * // Checking for several possible values
         * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
         * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
         */
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that performs a partial deep comparison between the
         * value at `path` of a given object to `srcValue`, returning `true` if the
         * object value is equivalent, else `false`.
         *
         * **Note:** Partial comparisons will match empty array and empty object
         * `srcValue` values against any array or object value, respectively. See
         * `_.isEqual` for a list of supported value comparisons.
         *
         * **Note:** Multiple values can be checked by combining several matchers
         * using `_.overSome`
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 1, 'b': 2, 'c': 3 },
         *   { 'a': 4, 'b': 5, 'c': 6 }
         * ];
         *
         * _.find(objects, _.matchesProperty('a', 4));
         * // => { 'a': 4, 'b': 5, 'c': 6 }
         *
         * // Checking for several possible values
         * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
         * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
         */
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that invokes the method at `path` of a given object.
         * Any additional arguments are provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Util
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new invoker function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': _.constant(2) } },
         *   { 'a': { 'b': _.constant(1) } }
         * ];
         *
         * _.map(objects, _.method('a.b'));
         * // => [2, 1]
         *
         * _.map(objects, _.method(['a', 'b']));
         * // => [2, 1]
         */
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });

        /**
         * The opposite of `_.method`; this method creates a function that invokes
         * the method at a given path of `object`. Any additional arguments are
         * provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Util
         * @param {Object} object The object to query.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new invoker function.
         * @example
         *
         * var array = _.times(3, _.constant),
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.methodOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
         * // => [2, 0]
         */
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });

        /**
         * Adds all own enumerable string keyed function properties of a source
         * object to the destination object. If `object` is a function, then methods
         * are added to its prototype as well.
         *
         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
         * avoid conflicts caused by modifying the original.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {Function|Object} [object=lodash] The destination object.
         * @param {Object} source The object of functions to add.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
         * @returns {Function|Object} Returns `object`.
         * @example
         *
         * function vowels(string) {
         *   return _.filter(string, function(v) {
         *     return /[aeiou]/i.test(v);
         *   });
         * }
         *
         * _.mixin({ 'vowels': vowels });
         * _.vowels('fred');
         * // => ['e']
         *
         * _('fred').vowels().value();
         * // => ['e']
         *
         * _.mixin({ 'vowels': vowels }, { 'chain': false });
         * _('fred').vowels();
         * // => ['e']
         */
        function mixin(object, source, options) {
          var props = keys(source),
              methodNames = baseFunctions(source, props);

          if (options == null &&
              !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
              isFunc = isFunction(object);

          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain || chainAll) {
                  var result = object(this.__wrapped__),
                      actions = result.__actions__ = copyArray(this.__actions__);

                  actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                  result.__chain__ = chainAll;
                  return result;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });

          return object;
        }

        /**
         * Reverts the `_` variable to its previous value and returns a reference to
         * the `lodash` function.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @returns {Function} Returns the `lodash` function.
         * @example
         *
         * var lodash = _.noConflict();
         */
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }

        /**
         * This method returns `undefined`.
         *
         * @static
         * @memberOf _
         * @since 2.3.0
         * @category Util
         * @example
         *
         * _.times(2, _.noop);
         * // => [undefined, undefined]
         */
        function noop() {
          // No operation performed.
        }

        /**
         * Creates a function that gets the argument at index `n`. If `n` is negative,
         * the nth argument from the end is returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {number} [n=0] The index of the argument to return.
         * @returns {Function} Returns the new pass-thru function.
         * @example
         *
         * var func = _.nthArg(1);
         * func('a', 'b', 'c', 'd');
         * // => 'b'
         *
         * var func = _.nthArg(-2);
         * func('a', 'b', 'c', 'd');
         * // => 'c'
         */
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }

        /**
         * Creates a function that invokes `iteratees` with the arguments it receives
         * and returns their results.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.over([Math.max, Math.min]);
         *
         * func(1, 2, 3, 4);
         * // => [4, 1]
         */
        var over = createOver(arrayMap);

        /**
         * Creates a function that checks if **all** of the `predicates` return
         * truthy when invoked with the arguments it receives.
         *
         * Following shorthands are possible for providing predicates.
         * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
         * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [predicates=[_.identity]]
         *  The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overEvery([Boolean, isFinite]);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => false
         *
         * func(NaN);
         * // => false
         */
        var overEvery = createOver(arrayEvery);

        /**
         * Creates a function that checks if **any** of the `predicates` return
         * truthy when invoked with the arguments it receives.
         *
         * Following shorthands are possible for providing predicates.
         * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
         * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [predicates=[_.identity]]
         *  The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overSome([Boolean, isFinite]);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => true
         *
         * func(NaN);
         * // => false
         *
         * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
         * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
         */
        var overSome = createOver(arraySome);

        /**
         * Creates a function that returns the value at `path` of a given object.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': 2 } },
         *   { 'a': { 'b': 1 } }
         * ];
         *
         * _.map(objects, _.property('a.b'));
         * // => [2, 1]
         *
         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
         * // => [1, 2]
         */
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }

        /**
         * The opposite of `_.property`; this method creates a function that returns
         * the value at a given path of `object`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var array = [0, 1, 2],
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
         * // => [2, 0]
         */
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined$1 : baseGet(object, path);
          };
        }

        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. A step of `-1` is used if a negative
         * `start` is specified without an `end` or `step`. If `end` is not specified,
         * it's set to `start` with `start` then set to `0`.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.rangeRight
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(-4);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        var range = createRange();

        /**
         * This method is like `_.range` except that it populates values in
         * descending order.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.range
         * @example
         *
         * _.rangeRight(4);
         * // => [3, 2, 1, 0]
         *
         * _.rangeRight(-4);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 5);
         * // => [4, 3, 2, 1]
         *
         * _.rangeRight(0, 20, 5);
         * // => [15, 10, 5, 0]
         *
         * _.rangeRight(0, -4, -1);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.rangeRight(0);
         * // => []
         */
        var rangeRight = createRange(true);

        /**
         * This method returns a new empty array.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Array} Returns the new empty array.
         * @example
         *
         * var arrays = _.times(2, _.stubArray);
         *
         * console.log(arrays);
         * // => [[], []]
         *
         * console.log(arrays[0] === arrays[1]);
         * // => false
         */
        function stubArray() {
          return [];
        }

        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */
        function stubFalse() {
          return false;
        }

        /**
         * This method returns a new empty object.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Object} Returns the new empty object.
         * @example
         *
         * var objects = _.times(2, _.stubObject);
         *
         * console.log(objects);
         * // => [{}, {}]
         *
         * console.log(objects[0] === objects[1]);
         * // => false
         */
        function stubObject() {
          return {};
        }

        /**
         * This method returns an empty string.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {string} Returns the empty string.
         * @example
         *
         * _.times(2, _.stubString);
         * // => ['', '']
         */
        function stubString() {
          return '';
        }

        /**
         * This method returns `true`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `true`.
         * @example
         *
         * _.times(2, _.stubTrue);
         * // => [true, true]
         */
        function stubTrue() {
          return true;
        }

        /**
         * Invokes the iteratee `n` times, returning an array of the results of
         * each invocation. The iteratee is invoked with one argument; (index).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.times(3, String);
         * // => ['0', '1', '2']
         *
         *  _.times(4, _.constant(0));
         * // => [0, 0, 0, 0]
         */
        function times(n, iteratee) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH,
              length = nativeMin(n, MAX_ARRAY_LENGTH);

          iteratee = getIteratee(iteratee);
          n -= MAX_ARRAY_LENGTH;

          var result = baseTimes(length, iteratee);
          while (++index < n) {
            iteratee(index);
          }
          return result;
        }

        /**
         * Converts `value` to a property path array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {*} value The value to convert.
         * @returns {Array} Returns the new property path array.
         * @example
         *
         * _.toPath('a.b.c');
         * // => ['a', 'b', 'c']
         *
         * _.toPath('a[0].b.c');
         * // => ['a', '0', 'b', 'c']
         */
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }

        /**
         * Generates a unique ID. If `prefix` is given, the ID is appended to it.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {string} [prefix=''] The value to prefix the ID with.
         * @returns {string} Returns the unique ID.
         * @example
         *
         * _.uniqueId('contact_');
         * // => 'contact_104'
         *
         * _.uniqueId();
         * // => '105'
         */
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }

        /*------------------------------------------------------------------------*/

        /**
         * Adds two numbers.
         *
         * @static
         * @memberOf _
         * @since 3.4.0
         * @category Math
         * @param {number} augend The first number in an addition.
         * @param {number} addend The second number in an addition.
         * @returns {number} Returns the total.
         * @example
         *
         * _.add(6, 4);
         * // => 10
         */
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);

        /**
         * Computes `number` rounded up to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round up.
         * @param {number} [precision=0] The precision to round up to.
         * @returns {number} Returns the rounded up number.
         * @example
         *
         * _.ceil(4.006);
         * // => 5
         *
         * _.ceil(6.004, 2);
         * // => 6.01
         *
         * _.ceil(6040, -2);
         * // => 6100
         */
        var ceil = createRound('ceil');

        /**
         * Divide two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {number} dividend The first number in a division.
         * @param {number} divisor The second number in a division.
         * @returns {number} Returns the quotient.
         * @example
         *
         * _.divide(6, 4);
         * // => 1.5
         */
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);

        /**
         * Computes `number` rounded down to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round down.
         * @param {number} [precision=0] The precision to round down to.
         * @returns {number} Returns the rounded down number.
         * @example
         *
         * _.floor(4.006);
         * // => 4
         *
         * _.floor(0.046, 2);
         * // => 0.04
         *
         * _.floor(4060, -2);
         * // => 4000
         */
        var floor = createRound('floor');

        /**
         * Computes the maximum value of `array`. If `array` is empty or falsey,
         * `undefined` is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * _.max([4, 2, 8, 6]);
         * // => 8
         *
         * _.max([]);
         * // => undefined
         */
        function max(array) {
          return (array && array.length)
            ? baseExtremum(array, identity, baseGt)
            : undefined$1;
        }

        /**
         * This method is like `_.max` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.maxBy(objects, function(o) { return o.n; });
         * // => { 'n': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.maxBy(objects, 'n');
         * // => { 'n': 2 }
         */
        function maxBy(array, iteratee) {
          return (array && array.length)
            ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
            : undefined$1;
        }

        /**
         * Computes the mean of the values in `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the mean.
         * @example
         *
         * _.mean([4, 2, 8, 6]);
         * // => 5
         */
        function mean(array) {
          return baseMean(array, identity);
        }

        /**
         * This method is like `_.mean` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be averaged.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the mean.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.meanBy(objects, function(o) { return o.n; });
         * // => 5
         *
         * // The `_.property` iteratee shorthand.
         * _.meanBy(objects, 'n');
         * // => 5
         */
        function meanBy(array, iteratee) {
          return baseMean(array, getIteratee(iteratee, 2));
        }

        /**
         * Computes the minimum value of `array`. If `array` is empty or falsey,
         * `undefined` is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * _.min([4, 2, 8, 6]);
         * // => 2
         *
         * _.min([]);
         * // => undefined
         */
        function min(array) {
          return (array && array.length)
            ? baseExtremum(array, identity, baseLt)
            : undefined$1;
        }

        /**
         * This method is like `_.min` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.minBy(objects, function(o) { return o.n; });
         * // => { 'n': 1 }
         *
         * // The `_.property` iteratee shorthand.
         * _.minBy(objects, 'n');
         * // => { 'n': 1 }
         */
        function minBy(array, iteratee) {
          return (array && array.length)
            ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
            : undefined$1;
        }

        /**
         * Multiply two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {number} multiplier The first number in a multiplication.
         * @param {number} multiplicand The second number in a multiplication.
         * @returns {number} Returns the product.
         * @example
         *
         * _.multiply(6, 4);
         * // => 24
         */
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);

        /**
         * Computes `number` rounded to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round.
         * @param {number} [precision=0] The precision to round to.
         * @returns {number} Returns the rounded number.
         * @example
         *
         * _.round(4.006);
         * // => 4
         *
         * _.round(4.006, 2);
         * // => 4.01
         *
         * _.round(4060, -2);
         * // => 4100
         */
        var round = createRound('round');

        /**
         * Subtract two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {number} minuend The first number in a subtraction.
         * @param {number} subtrahend The second number in a subtraction.
         * @returns {number} Returns the difference.
         * @example
         *
         * _.subtract(6, 4);
         * // => 2
         */
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);

        /**
         * Computes the sum of the values in `array`.
         *
         * @static
         * @memberOf _
         * @since 3.4.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.sum([4, 2, 8, 6]);
         * // => 20
         */
        function sum(array) {
          return (array && array.length)
            ? baseSum(array, identity)
            : 0;
        }

        /**
         * This method is like `_.sum` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be summed.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the sum.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.sumBy(objects, function(o) { return o.n; });
         * // => 20
         *
         * // The `_.property` iteratee shorthand.
         * _.sumBy(objects, 'n');
         * // => 20
         */
        function sumBy(array, iteratee) {
          return (array && array.length)
            ? baseSum(array, getIteratee(iteratee, 2))
            : 0;
        }

        /*------------------------------------------------------------------------*/

        // Add methods that return wrapped values in chain sequences.
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;

        // Add aliases.
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;

        // Add methods to `lodash.prototype`.
        mixin(lodash, lodash);

        /*------------------------------------------------------------------------*/

        // Add methods that return unwrapped values in chain sequences.
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;

        // Add aliases.
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;

        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }()), { 'chain': false });

        /*------------------------------------------------------------------------*/

        /**
         * The semantic version number.
         *
         * @static
         * @memberOf _
         * @type {string}
         */
        lodash.VERSION = VERSION;

        // Assign default placeholders.
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });

        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

            var result = (this.__filtered__ && !index)
              ? new LazyWrapper(this)
              : this.clone();

            if (result.__filtered__) {
              result.__takeCount__ = nativeMin(n, result.__takeCount__);
            } else {
              result.__views__.push({
                'size': nativeMin(n, MAX_ARRAY_LENGTH),
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };

          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });

        // Add `LazyWrapper` methods that accept an `iteratee` value.
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

          LazyWrapper.prototype[methodName] = function(iteratee) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getIteratee(iteratee, 3),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });

        // Add `LazyWrapper` methods for `_.head` and `_.last`.
        arrayEach(['head', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');

          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });

        // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
        arrayEach(['initial', 'tail'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');

          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });

        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };

        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };

        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };

        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == 'function') {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });

        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };

        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);

          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };

        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };

        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };

        // Add `LazyWrapper` methods to `lodash.prototype`.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
              isTaker = /^(?:head|last)$/.test(methodName),
              lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
              retUnwrapped = isTaker || /^find/.test(methodName);

          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__,
                args = isTaker ? [1] : arguments,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);

            var interceptor = function(value) {
              var result = lodashFunc.apply(lodash, arrayPush([value], args));
              return (isTaker && chainAll) ? result[0] : result;
            };

            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              // Avoid lazy use if the iteratee has a "length" value other than `1`.
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isUnwrapped = retUnwrapped && !chainAll,
                onlyLazy = isLazy && !isHybrid;

            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
              return new LodashWrapper(result, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result = this.thru(interceptor);
            return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
          };
        });

        // Add `Array` methods to `lodash.prototype`.
        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
          var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:pop|shift)$/.test(methodName);

          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value) {
              return func.apply(isArray(value) ? value : [], args);
            });
          };
        });

        // Map minified method names to their real names.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + '';
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ 'name': methodName, 'func': lodashFunc });
          }
        });

        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined$1
        }];

        // Add methods to `LazyWrapper`.
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;

        // Add chain sequence methods to the `lodash` wrapper.
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

        // Add lazy aliases.
        lodash.prototype.first = lodash.prototype.head;

        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      });

      /*--------------------------------------------------------------------------*/

      // Export lodash.
      var _ = runInContext();

      // Some AMD build optimizers, like r.js, check for condition patterns like:
      if (freeModule) {
        // Export for Node.js.
        (freeModule.exports = _)._ = _;
        // Export for CommonJS support.
        freeExports._ = _;
      }
      else {
        // Export to the global object.
        root._ = _;
      }
    }.call(commonjsGlobal));
    });

    const COLOR_MAP = {
      0: "#ebedf0",
      1: "#9be9a8",
      2: "#40c463",
      3: "#30a14e",
      4: "#216e39"
    };

    async function fetchYears(username) {
      const data = await fetch(`https://github.com/${username}`);
      const $ = cheerio.load(await data.text());
      return $(".js-year-link")
        .get()
        .map((a) => {
          const $a = $(a);
          return {
            href: $a.attr("href"),
            text: $a.text().trim()
          };
        });
    }

    async function fetchDataForYear(url, year, format) {
      const data = await fetch(`https://github.com${url}`);
      const $ = cheerio.load(await data.text());
      const $days = $("svg.js-calendar-graph-svg rect.ContributionCalendar-day");
      const contribText = $(".js-yearly-contributions h2")
        .text()
        .trim()
        .match(/^([0-9,]+)\s/);
      let contribCount;
      if (contribText) {
        [contribCount] = contribText;
        contribCount = parseInt(contribCount.replace(/,/g, ""), 10);
      }

      return {
        year,
        total: contribCount || 0,
        range: {
          start: $($days.get(0)).attr("data-date"),
          end: $($days.get($days.length - 1)).attr("data-date")
        },
        contributions: (() => {
          const parseDay = (day) => {
            const $day = $(day);
            const date = $day
              .attr("data-date")
              .split("-")
              .map((d) => parseInt(d, 10));
            const color = COLOR_MAP[$day.attr("data-level")];
            const value = {
              date: $day.attr("data-date"),
              count: parseInt($day.text().split(" ")[0], 10) || 0,
              color,
              intensity: $day.attr("data-level") || 0
            };
            return { date, value };
          };

          if (format !== "nested") {
            return $days.get().map((day) => parseDay(day).value);
          }

          return $days.get().reduce((o, day) => {
            const { date, value } = parseDay(day);
            const [y, m, d] = date;
            if (!o[y]) o[y] = {};
            if (!o[y][m]) o[y][m] = {};
            o[y][m][d] = value;
            return o;
          }, {});
        })()
      };
    }

    async function fetchDataForAllYears(username, format) {
      const years = await fetchYears(username);
      return Promise.all(
        years.map((year) => fetchDataForYear(year.href, year.text, format))
      ).then((resp) => {
        return {
          years: (() => {
            const obj = {};
            const arr = resp.map((year) => {
              const { contributions, ...rest } = year;
              lodash.setWith(obj, [rest.year], rest, Object);
              return rest;
            });
            return format === "nested" ? obj : arr;
          })(),
          contributions:
            format === "nested"
              ? resp.reduce((acc, curr) => lodash.merge(acc, curr.contributions))
              : resp
                  .reduce((list, curr) => [...list, ...curr.contributions], [])
                  .sort((a, b) => {
                    if (a.date < b.date) return 1;
                    else if (a.date > b.date) return -1;
                    return 0;
                  })
        };
      });
    }

    /* src/App.svelte generated by Svelte v3.55.1 */

    const { Object: Object_1 } = globals;
    const file = "src/App.svelte";

    function create_fragment(ctx) {
    	let main;
    	let p;
    	let t0;
    	let t1_value = (/*name*/ ctx[0] || "stranger") + "";
    	let t1;
    	let t2;
    	let t3;
    	let input;
    	let t4;
    	let div2;
    	let div1;
    	let img;
    	let img_src_value;
    	let t5;
    	let div0;
    	let h2;
    	let t6;
    	let t7;
    	let contributions_1;
    	let t8;
    	let repos;
    	let current;
    	let mounted;
    	let dispose;

    	contributions_1 = new Contributions({
    			props: {
    				contribution_list: /*contributions*/ ctx[3]
    			},
    			$$inline: true
    		});

    	repos = new Repos({
    			props: { repos_list: /*repos_sorted*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			p = element("p");
    			t0 = text$2("Hello ");
    			t1 = text$2(t1_value);
    			t2 = text$2("!");
    			t3 = space();
    			input = element("input");
    			t4 = space();
    			div2 = element("div");
    			div1 = element("div");
    			img = element("img");
    			t5 = space();
    			div0 = element("div");
    			h2 = element("h2");
    			t6 = text$2(/*username*/ ctx[2]);
    			t7 = space();
    			create_component(contributions_1.$$.fragment);
    			t8 = space();
    			create_component(repos.$$.fragment);
    			add_location(p, file, 101, 1, 4038);
    			attr_dev(input, "placeholder", "enter your name");
    			add_location(input, file, 102, 1, 4074);
    			if (!src_url_equal(img.src, img_src_value = /*src*/ ctx[1])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "profile");
    			attr_dev(img, "class", "profile svelte-1vx8etj");
    			add_location(img, file, 109, 3, 4222);
    			attr_dev(h2, "class", "svelte-1vx8etj");
    			add_location(h2, file, 111, 4, 4311);
    			attr_dev(div0, "class", "contributions_container svelte-1vx8etj");
    			add_location(div0, file, 110, 3, 4269);
    			attr_dev(div1, "class", "profile_container svelte-1vx8etj");
    			add_location(div1, file, 108, 2, 4187);
    			attr_dev(div2, "class", "container svelte-1vx8etj");
    			add_location(div2, file, 107, 1, 4161);
    			attr_dev(main, "class", "svelte-1vx8etj");
    			add_location(main, file, 100, 0, 4030);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, p);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			append_dev(main, t3);
    			append_dev(main, input);
    			set_input_value(input, /*name*/ ctx[0]);
    			append_dev(main, t4);
    			append_dev(main, div2);
    			append_dev(div2, div1);
    			append_dev(div1, img);
    			append_dev(div1, t5);
    			append_dev(div1, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t6);
    			append_dev(div0, t7);
    			mount_component(contributions_1, div0, null);
    			append_dev(div2, t8);
    			mount_component(repos, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*createCV*/ ctx[5], false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*name*/ 1) && t1_value !== (t1_value = (/*name*/ ctx[0] || "stranger") + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*name*/ 1 && input.value !== /*name*/ ctx[0]) {
    				set_input_value(input, /*name*/ ctx[0]);
    			}

    			if (!current || dirty & /*src*/ 2 && !src_url_equal(img.src, img_src_value = /*src*/ ctx[1])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (!current || dirty & /*username*/ 4) set_data_dev(t6, /*username*/ ctx[2]);
    			const contributions_1_changes = {};
    			if (dirty & /*contributions*/ 8) contributions_1_changes.contribution_list = /*contributions*/ ctx[3];
    			contributions_1.$set(contributions_1_changes);
    			const repos_changes = {};
    			if (dirty & /*repos_sorted*/ 16) repos_changes.repos_list = /*repos_sorted*/ ctx[4];
    			repos.$set(repos_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contributions_1.$$.fragment, local);
    			transition_in(repos.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contributions_1.$$.fragment, local);
    			transition_out(repos.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(contributions_1);
    			destroy_component(repos);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let name = "arditxhaferi";
    	let src = "favicon.png";
    	let username = "John Doe";
    	let contributions = [];
    	let repos_sorted = [];

    	let jokes = {
    		JavaScript: "Why was the JavaScript developer sad? Because they didn't know how to 'null' their feelings.",
    		Python: "What do you call a snake that works in a programming team? A Python developer.",
    		Java: "Why was the Java developer sad? They didn't have any closures.",
    		Ruby: "Why do Ruby developers wear glasses? Because they can't C#.",
    		PHP: "Why was the PHP developer sad? Because they didn't know what the 'else' statement was for.",
    		"C++": "Why do C++ developers wear glasses? Because they can't C#.",
    		"C#": "Why do C# developers wear glasses? Because they can't C#.",
    		TypeScript: "Why was the TypeScript developer sad? Because they didn't know how to 'null' their feelings.",
    		Shell: "Why do Shell developers wear glasses? Because they can't C#.",
    		Go: "Why was the Go developer sad? They didn't have any closures.",
    		Swift: "Why do Swift developers wear glasses? Because they can't C#.",
    		Kotlin: "Why was the Kotlin developer sad? They didn't have any closures.",
    		Scala: "Why was the Scala developer sad? They didn't have any closures.",
    		CSS: "Why was the CSS developer sad? They didn't know how to 'null' their feelings.",
    		C: "Why do C developers wear glasses? Because they can't C#.",
    		"Objective-C": "Why do Objective-C developers wear glasses? Because they can't C#.",
    		Rust: "Why was the Rust developer sad? They didn't have any closures.",
    		Dart: "Why do Dart developers wear glasses? Because they can't C#.",
    		Elixir: "Why was the Elixir developer sad? They didn't have any closures.",
    		Perl: "Why was the Perl developer sad? They didn't know what the 'else' statement was for.",
    		Groovy: "Why was the Groovy developer sad? They didn't know what the 'else' statement was for.",
    		"F#": "Why do F# developers wear glasses? Because they can't C#.",
    		CoffeeScript: "Why do CoffeeScript developers wear glasses? Because they can't C#.",
    		R: "Why was the R developer sad? They didn't have any closures.",
    		Vue: "Why do Vue developers wear glasses? Because they can't C#.",
    		Sass: "Why was the Sass developer sad? They didn't know how to 'null' their feelings.",
    		Erlang: "Why was the Erlang developer sad? They didn't have any closures.",
    		Julia: "Why was the Julia developer sad? They didn't have any closures.",
    		HTML: "Why was the HTML developer sad? They didn't know what the 'else' statement was for."
    	};

    	const githubRequest = (url, name) => {
    		return new Promise((resolve, reject) => {
    				fetch(url.replace("$name$", name)).then(response => response.json()).then(data => {
    					resolve(data);
    				}).catch(error => {
    					reject(error);
    				});
    			});
    	};

    	const createCV = async () => {
    		handleProfile();
    	}; // handleContributions()

    	const handleProfile = async () => {
    		let repos = await githubRequest(`https://api.github.com/users/$name$/repos?per_page=100`, name);

    		$$invalidate(4, repos_sorted = repos.sort(function (a, b) {
    			return b.stargazers_count - a.stargazers_count;
    		}).slice(0, 3));

    		$$invalidate(1, src = repos[0]["owner"]["avatar_url"]);
    		$$invalidate(2, username = repos[0]["owner"]["login"]);
    	};

    	const handleContributions = async () => {
    		let allContributions = await fetchDataForAllYears(name, "nested");
    		const d = new Date();
    		let year = d.getFullYear();
    		let month = d.getMonth();
    		$$invalidate(3, contributions = Object.values(Object.values(allContributions["contributions"]["contributions"][year])[month]));
    	};

    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		name = this.value;
    		$$invalidate(0, name);
    	}

    	$$self.$capture_state = () => ({
    		Contributions,
    		Repos,
    		fetchDataForAllYears,
    		Rating,
    		name,
    		src,
    		username,
    		contributions,
    		repos_sorted,
    		jokes,
    		githubRequest,
    		createCV,
    		handleProfile,
    		handleContributions
    	});

    	$$self.$inject_state = $$props => {
    		if ('name' in $$props) $$invalidate(0, name = $$props.name);
    		if ('src' in $$props) $$invalidate(1, src = $$props.src);
    		if ('username' in $$props) $$invalidate(2, username = $$props.username);
    		if ('contributions' in $$props) $$invalidate(3, contributions = $$props.contributions);
    		if ('repos_sorted' in $$props) $$invalidate(4, repos_sorted = $$props.repos_sorted);
    		if ('jokes' in $$props) jokes = $$props.jokes;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		name,
    		src,
    		username,
    		contributions,
    		repos_sorted,
    		createCV,
    		input_input_handler
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
        target: document.body,
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
